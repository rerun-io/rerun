# DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/python/mod.rs
# Based on "crates/store/re_sdk_types/definitions/rerun/testing/components/enum_test.fbs".

# You can extend this class by creating a "MultiEnumExt" class in "multi_enum_ext.py".

from __future__ import annotations

from collections.abc import Sequence
from typing import TYPE_CHECKING, Any

import pyarrow as pa
from attrs import define, field
from rerun._baseclasses import (
    BaseBatch,
)

if TYPE_CHECKING:
    from .. import datatypes

__all__ = ["MultiEnum", "MultiEnumArrayLike", "MultiEnumBatch", "MultiEnumLike"]


@define(init=False)
class MultiEnum:
    def __init__(self: Any, value1: datatypes.EnumTestLike, *, value2: datatypes.ValuedEnumLike | None = None) -> None:
        """
        Create a new instance of the MultiEnum datatype.

        Parameters
        ----------
        value1:
            The first value.
        value2:
            The second value.

        """

        # You can define your own __init__ function as a member of MultiEnumExt in multi_enum_ext.py
        self.__attrs_init__(value1=value1, value2=value2)

    value1: datatypes.EnumTest = field()
    # The first value.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    value2: datatypes.ValuedEnum | None = field(default=None)
    # The second value.
    #
    # (Docstring intentionally commented out to hide this field from the docs)


MultiEnumLike = MultiEnum
"""A type alias for any MultiEnum-like object."""

MultiEnumArrayLike = MultiEnum | Sequence[MultiEnumLike]
"""A type alias for any MultiEnum-like array object."""


class MultiEnumBatch(BaseBatch[MultiEnumArrayLike]):
    _ARROW_DATATYPE = pa.struct([
        pa.field("value1", pa.uint8(), nullable=False, metadata={}),
        pa.field("value2", pa.uint8(), nullable=True, metadata={}),
    ])

    @staticmethod
    def _native_to_pa_array(data: MultiEnumArrayLike, data_type: pa.DataType) -> pa.Array:
        from . import EnumTestBatch, ValuedEnumBatch

        typed_data: Sequence[MultiEnum]

        if isinstance(data, MultiEnum):
            typed_data = [data]
        else:
            typed_data = data

        return pa.StructArray.from_arrays(
            [
                EnumTestBatch([x.value1 for x in typed_data]).as_arrow_array(),  # type: ignore[misc, arg-type]
                ValuedEnumBatch([x.value2 for x in typed_data]).as_arrow_array(),  # type: ignore[misc, arg-type]
            ],
            fields=list(data_type),
        )
