# DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/python/mod.rs
# Based on "crates/store/re_types/definitions/rerun/blueprint/components/dataframe_view_mode.fbs".

# You can extend this class by creating a "DataframeViewModeExt" class in "dataframe_view_mode_ext.py".

from __future__ import annotations

from typing import Literal, Sequence, Union

import pyarrow as pa

from ..._baseclasses import (
    BaseBatch,
    BaseExtensionType,
    ComponentBatchMixin,
)

__all__ = [
    "DataframeViewMode",
    "DataframeViewModeArrayLike",
    "DataframeViewModeBatch",
    "DataframeViewModeLike",
    "DataframeViewModeType",
]


from enum import Enum


class DataframeViewMode(Enum):
    """**Component**: The kind of table displayed by the dataframe view."""

    LatestAt = 1
    """
    Display the entity values at the current time.

    In this mode, rows are entity instances, and columns are components. The visible time range setting is ignored.
    """

    TimeRange = 2
    """
    Display a temporal table of entity values.

    In this mode, rows are combination of entity path, timestamp, and row id, and columns are components. The
    timestamp shown are determined by each view entity's visible time range setting.
    """

    def __str__(self) -> str:
        """Returns the variant name."""
        if self == DataframeViewMode.LatestAt:
            return "LatestAt"
        elif self == DataframeViewMode.TimeRange:
            return "TimeRange"
        else:
            raise ValueError("Unknown enum variant")


DataframeViewModeLike = Union[DataframeViewMode, Literal["LatestAt", "TimeRange", "latestat", "timerange"]]
DataframeViewModeArrayLike = Union[DataframeViewModeLike, Sequence[DataframeViewModeLike]]


class DataframeViewModeType(BaseExtensionType):
    _TYPE_NAME: str = "rerun.blueprint.components.DataframeViewMode"

    def __init__(self) -> None:
        pa.ExtensionType.__init__(
            self,
            pa.sparse_union([
                pa.field("_null_markers", pa.null(), nullable=True, metadata={}),
                pa.field("LatestAt", pa.null(), nullable=True, metadata={}),
                pa.field("TimeRange", pa.null(), nullable=True, metadata={}),
            ]),
            self._TYPE_NAME,
        )


class DataframeViewModeBatch(BaseBatch[DataframeViewModeArrayLike], ComponentBatchMixin):
    _ARROW_TYPE = DataframeViewModeType()

    @staticmethod
    def _native_to_pa_array(data: DataframeViewModeArrayLike, data_type: pa.DataType) -> pa.Array:
        if isinstance(data, (DataframeViewMode, int, str)):
            data = [data]

        types: list[int] = []

        for value in data:
            if value is None:
                types.append(0)
            elif isinstance(value, DataframeViewMode):
                types.append(value.value)  # Actual enum value
            elif isinstance(value, int):
                types.append(value)  # By number
            elif isinstance(value, str):
                if hasattr(DataframeViewMode, value):
                    types.append(DataframeViewMode[value].value)  # fast path
                elif value.lower() == "latestat":
                    types.append(DataframeViewMode.LatestAt.value)
                elif value.lower() == "timerange":
                    types.append(DataframeViewMode.TimeRange.value)
                else:
                    raise ValueError(f"Unknown DataframeViewMode kind: {value}")
            else:
                raise ValueError(f"Unknown DataframeViewMode kind: {value}")

        buffers = [
            None,
            pa.array(types, type=pa.int8()).buffers()[1],
        ]
        children = (1 + 2) * [pa.nulls(len(data))]

        return pa.UnionArray.from_buffers(
            type=data_type,
            length=len(data),
            buffers=buffers,
            children=children,
        )
