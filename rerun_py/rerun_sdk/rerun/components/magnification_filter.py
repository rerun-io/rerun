# DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/python/mod.rs
# Based on "crates/store/re_sdk_types/definitions/rerun/components/magnification_filter.fbs".

# You can extend this class by creating a "MagnificationFilterExt" class in "magnification_filter_ext.py".

from __future__ import annotations

from collections.abc import Sequence
from typing import Literal

import pyarrow as pa

from .._baseclasses import (
    BaseBatch,
    ComponentBatchMixin,
)

__all__ = ["MagnificationFilter", "MagnificationFilterArrayLike", "MagnificationFilterBatch", "MagnificationFilterLike"]


from enum import Enum


class MagnificationFilter(Enum):
    """
    **Component**: Filter used when a single texel/pixel of an image is displayed larger than a single screen pixel.

    This happens when zooming into an image, when displaying a low-resolution image in a large area,
    or when viewing an image up close in 3D space.
    """

    Nearest = 1
    """
    Show the nearest pixel value.

    This will give a blocky appearance when the image is scaled up.
    Used as default when rendering 2D images.
    """

    Linear = 2
    """
    Linearly interpolate the nearest neighbors, creating a smoother look when the image is scaled up.

    Used as default for mesh rendering.
    """

    Bicubic = 3
    """
    Bicubic interpolation using a Catmull-Rom spline, creating the smoothest look when the image is scaled up.

    This is computationally more expensive than linear filtering but produces sharper results with less blurring.
    Unlike bilinear filtering, this avoids cross-shaped artifacts at texel boundaries.
    """

    @classmethod
    def auto(cls, val: str | int | MagnificationFilter) -> MagnificationFilter:
        """Best-effort converter, including a case-insensitive string matcher."""
        if isinstance(val, MagnificationFilter):
            return val
        if isinstance(val, int):
            return cls(val)
        try:
            return cls[val]
        except KeyError:
            val_lower = val.lower()
            for variant in cls:
                if variant.name.lower() == val_lower:
                    return variant
        raise ValueError(f"Cannot convert {val} to {cls.__name__}")

    def __str__(self) -> str:
        """Returns the variant name."""
        return self.name


MagnificationFilterLike = (
    MagnificationFilter | Literal["Bicubic", "Linear", "Nearest", "bicubic", "linear", "nearest"] | int
)
"""A type alias for any MagnificationFilter-like object."""

MagnificationFilterArrayLike = (
    MagnificationFilter
    | Literal["Bicubic", "Linear", "Nearest", "bicubic", "linear", "nearest"]
    | int
    | Sequence[MagnificationFilterLike]
)
"""A type alias for any MagnificationFilter-like array object."""


class MagnificationFilterBatch(BaseBatch[MagnificationFilterArrayLike], ComponentBatchMixin):
    _ARROW_DATATYPE = pa.uint8()
    _COMPONENT_TYPE: str = "rerun.components.MagnificationFilter"

    @staticmethod
    def _native_to_pa_array(data: MagnificationFilterArrayLike, data_type: pa.DataType) -> pa.Array:
        if isinstance(data, (MagnificationFilter, int, str)):
            data = [data]

        pa_data = [MagnificationFilter.auto(v).value if v is not None else None for v in data]  # type: ignore[redundant-expr]

        return pa.array(pa_data, type=data_type)
