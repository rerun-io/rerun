# DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/python/mod.rs
# Based on "crates/store/re_sdk_types/definitions/rerun/components/channel_message_counts.fbs".

# You can extend this class by creating a "ChannelMessageCountsExt" class in "channel_message_counts_ext.py".

from __future__ import annotations

from collections.abc import Sequence
from typing import TYPE_CHECKING, Any

import pyarrow as pa
from attrs import define, field

from .._baseclasses import (
    BaseBatch,
    ComponentBatchMixin,
    ComponentMixin,
)

if TYPE_CHECKING:
    from .. import datatypes

__all__ = [
    "ChannelMessageCounts",
    "ChannelMessageCountsArrayLike",
    "ChannelMessageCountsBatch",
    "ChannelMessageCountsLike",
]


@define(init=False)
class ChannelMessageCounts(ComponentMixin):
    """
    **Component**: A mapping of channel IDs to their respective message counts.

    Used in MCAP statistics to track how many messages were recorded per channel.

    ⚠️ **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**
    """

    _BATCH_TYPE = None

    def __init__(self: Any, counts: ChannelMessageCountsLike) -> None:
        """
        Create a new instance of the ChannelMessageCounts component.

        Parameters
        ----------
        counts:
            The channel ID to message count pairs.

        """

        # You can define your own __init__ function as a member of ChannelMessageCountsExt in channel_message_counts_ext.py
        self.__attrs_init__(counts=counts)

    counts: list[datatypes.ChannelCountPair] = field()
    # The channel ID to message count pairs.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    def __len__(self) -> int:
        # You can define your own __len__ function as a member of ChannelMessageCountsExt in channel_message_counts_ext.py
        return len(self.counts)


if TYPE_CHECKING:
    ChannelMessageCountsLike = ChannelMessageCounts | dict[int, int]
    """A type alias for any ChannelMessageCounts-like object."""
else:
    ChannelMessageCountsLike = Any

ChannelMessageCountsArrayLike = (
    ChannelMessageCounts | Sequence[ChannelMessageCountsLike] | dict[int, int] | Sequence[dict[int, int]]
)
"""A type alias for any ChannelMessageCounts-like array object."""


class ChannelMessageCountsBatch(BaseBatch[ChannelMessageCountsArrayLike], ComponentBatchMixin):
    _ARROW_DATATYPE = pa.list_(
        pa.field(
            "item",
            pa.struct([
                pa.field("channel_id", pa.uint16(), nullable=False, metadata={}),
                pa.field("message_count", pa.uint64(), nullable=False, metadata={}),
            ]),
            nullable=False,
            metadata={},
        )
    )
    _COMPONENT_TYPE: str = "rerun.components.ChannelMessageCounts"

    @staticmethod
    def _native_to_pa_array(data: ChannelMessageCountsArrayLike, data_type: pa.DataType) -> pa.Array:
        raise NotImplementedError(
            "Arrow serialization of ChannelMessageCounts not implemented: We lack codegen for arrow-serialization of general structs"
        )  # You need to implement native_to_pa_array_override in channel_message_counts_ext.py


# This is patched in late to avoid circular dependencies.
ChannelMessageCounts._BATCH_TYPE = ChannelMessageCountsBatch  # type: ignore[assignment]
