# DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/python/mod.rs
# Based on "crates/store/re_sdk_types/definitions/rerun/archetypes/mcap_statistics.fbs".

# You can extend this class by creating a "McapStatisticsExt" class in "mcap_statistics_ext.py".

from __future__ import annotations

from typing import Any

import numpy as np
import pyarrow as pa
from attrs import define, field

from .. import components, datatypes
from .._baseclasses import (
    Archetype,
    ComponentColumnList,
)
from ..error_utils import catch_and_log_exceptions

__all__ = ["McapStatistics"]


@define(str=False, repr=False, init=False)
class McapStatistics(Archetype):
    """
    **Archetype**: Recording-level statistics about an MCAP file, logged as a part of [`archetypes.RecordingInfo`][rerun.archetypes.RecordingInfo].

    This archetype contains summary information about an entire MCAP recording, including
    counts of messages, schemas, channels, and other records, as well as timing information
    spanning the full recording duration. It is typically logged once per recording to provide
    an overview of the dataset's structure and content.

    See also [`archetypes.McapChannel`][rerun.archetypes.McapChannel] for individual channel definitions,
    [`archetypes.McapMessage`][rerun.archetypes.McapMessage] for message content, [`archetypes.McapSchema`][rerun.archetypes.McapSchema] for schema definitions,
    and the [MCAP specification](https://mcap.dev/) for complete format details.

    ⚠️ **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**
    """

    def __init__(
        self: Any,
        *,
        message_count: datatypes.UInt64Like,
        schema_count: datatypes.UInt64Like,
        channel_count: datatypes.UInt64Like,
        attachment_count: datatypes.UInt64Like,
        metadata_count: datatypes.UInt64Like,
        chunk_count: datatypes.UInt64Like,
        message_start_time: datatypes.TimeIntLike,
        message_end_time: datatypes.TimeIntLike,
        channel_message_counts: components.ChannelMessageCountsLike | None = None,
    ) -> None:
        """
        Create a new instance of the McapStatistics archetype.

        Parameters
        ----------
        message_count:
            Total number of data messages contained in the MCAP recording.

            This count includes all timestamped data messages but excludes metadata records,
            schema definitions, and other non-message records.
        schema_count:
            Number of unique schema definitions in the recording.

            Each schema defines the structure for one or more message types used by channels.
        channel_count:
            Number of channels defined in the recording.

            Each channel represents a unique topic and encoding combination for publishing messages.
        attachment_count:
            Number of file attachments embedded in the recording.

            Attachments can include calibration files, configuration data, or other auxiliary files.
        metadata_count:
            Number of metadata records providing additional context about the recording.

            Metadata records contain key-value pairs with information about the recording environment,
            system configuration, or other contextual data.
        chunk_count:
            Number of data chunks used to organize messages in the file.

            Chunks group related messages together for efficient storage and indexed access.
        message_start_time:
            Timestamp of the earliest message in the recording.

            This marks the beginning of the recorded data timeline.
        message_end_time:
            Timestamp of the latest message in the recording.

            Together with `message_start_time`, this defines the total duration of the recording.
        channel_message_counts:
            Detailed breakdown of message counts per channel.

        """

        # You can define your own __init__ function as a member of McapStatisticsExt in mcap_statistics_ext.py
        with catch_and_log_exceptions(context=self.__class__.__name__):
            self.__attrs_init__(
                message_count=message_count,
                schema_count=schema_count,
                channel_count=channel_count,
                attachment_count=attachment_count,
                metadata_count=metadata_count,
                chunk_count=chunk_count,
                message_start_time=message_start_time,
                message_end_time=message_end_time,
                channel_message_counts=channel_message_counts,
            )
            return
        self.__attrs_clear__()

    def __attrs_clear__(self) -> None:
        """Convenience method for calling `__attrs_init__` with all `None`s."""
        self.__attrs_init__(
            message_count=None,
            schema_count=None,
            channel_count=None,
            attachment_count=None,
            metadata_count=None,
            chunk_count=None,
            message_start_time=None,
            message_end_time=None,
            channel_message_counts=None,
        )

    @classmethod
    def _clear(cls) -> McapStatistics:
        """Produce an empty McapStatistics, bypassing `__init__`."""
        inst = cls.__new__(cls)
        inst.__attrs_clear__()
        return inst

    @classmethod
    def from_fields(
        cls,
        *,
        clear_unset: bool = False,
        message_count: datatypes.UInt64Like | None = None,
        schema_count: datatypes.UInt64Like | None = None,
        channel_count: datatypes.UInt64Like | None = None,
        attachment_count: datatypes.UInt64Like | None = None,
        metadata_count: datatypes.UInt64Like | None = None,
        chunk_count: datatypes.UInt64Like | None = None,
        message_start_time: datatypes.TimeIntLike | None = None,
        message_end_time: datatypes.TimeIntLike | None = None,
        channel_message_counts: components.ChannelMessageCountsLike | None = None,
    ) -> McapStatistics:
        """
        Update only some specific fields of a `McapStatistics`.

        Parameters
        ----------
        clear_unset:
            If true, all unspecified fields will be explicitly cleared.
        message_count:
            Total number of data messages contained in the MCAP recording.

            This count includes all timestamped data messages but excludes metadata records,
            schema definitions, and other non-message records.
        schema_count:
            Number of unique schema definitions in the recording.

            Each schema defines the structure for one or more message types used by channels.
        channel_count:
            Number of channels defined in the recording.

            Each channel represents a unique topic and encoding combination for publishing messages.
        attachment_count:
            Number of file attachments embedded in the recording.

            Attachments can include calibration files, configuration data, or other auxiliary files.
        metadata_count:
            Number of metadata records providing additional context about the recording.

            Metadata records contain key-value pairs with information about the recording environment,
            system configuration, or other contextual data.
        chunk_count:
            Number of data chunks used to organize messages in the file.

            Chunks group related messages together for efficient storage and indexed access.
        message_start_time:
            Timestamp of the earliest message in the recording.

            This marks the beginning of the recorded data timeline.
        message_end_time:
            Timestamp of the latest message in the recording.

            Together with `message_start_time`, this defines the total duration of the recording.
        channel_message_counts:
            Detailed breakdown of message counts per channel.

        """

        inst = cls.__new__(cls)
        with catch_and_log_exceptions(context=cls.__name__):
            kwargs = {
                "message_count": message_count,
                "schema_count": schema_count,
                "channel_count": channel_count,
                "attachment_count": attachment_count,
                "metadata_count": metadata_count,
                "chunk_count": chunk_count,
                "message_start_time": message_start_time,
                "message_end_time": message_end_time,
                "channel_message_counts": channel_message_counts,
            }

            if clear_unset:
                kwargs = {k: v if v is not None else [] for k, v in kwargs.items()}  # type: ignore[misc]

            inst.__attrs_init__(**kwargs)
            return inst

        inst.__attrs_clear__()
        return inst

    @classmethod
    def cleared(cls) -> McapStatistics:
        """Clear all the fields of a `McapStatistics`."""
        return cls.from_fields(clear_unset=True)

    @classmethod
    def columns(
        cls,
        *,
        message_count: datatypes.UInt64ArrayLike | None = None,
        schema_count: datatypes.UInt64ArrayLike | None = None,
        channel_count: datatypes.UInt64ArrayLike | None = None,
        attachment_count: datatypes.UInt64ArrayLike | None = None,
        metadata_count: datatypes.UInt64ArrayLike | None = None,
        chunk_count: datatypes.UInt64ArrayLike | None = None,
        message_start_time: datatypes.TimeIntArrayLike | None = None,
        message_end_time: datatypes.TimeIntArrayLike | None = None,
        channel_message_counts: components.ChannelMessageCountsArrayLike | None = None,
    ) -> ComponentColumnList:
        """
        Construct a new column-oriented component bundle.

        This makes it possible to use `rr.send_columns` to send columnar data directly into Rerun.

        The returned columns will be partitioned into unit-length sub-batches by default.
        Use `ComponentColumnList.partition` to repartition the data as needed.

        Parameters
        ----------
        message_count:
            Total number of data messages contained in the MCAP recording.

            This count includes all timestamped data messages but excludes metadata records,
            schema definitions, and other non-message records.
        schema_count:
            Number of unique schema definitions in the recording.

            Each schema defines the structure for one or more message types used by channels.
        channel_count:
            Number of channels defined in the recording.

            Each channel represents a unique topic and encoding combination for publishing messages.
        attachment_count:
            Number of file attachments embedded in the recording.

            Attachments can include calibration files, configuration data, or other auxiliary files.
        metadata_count:
            Number of metadata records providing additional context about the recording.

            Metadata records contain key-value pairs with information about the recording environment,
            system configuration, or other contextual data.
        chunk_count:
            Number of data chunks used to organize messages in the file.

            Chunks group related messages together for efficient storage and indexed access.
        message_start_time:
            Timestamp of the earliest message in the recording.

            This marks the beginning of the recorded data timeline.
        message_end_time:
            Timestamp of the latest message in the recording.

            Together with `message_start_time`, this defines the total duration of the recording.
        channel_message_counts:
            Detailed breakdown of message counts per channel.

        """

        inst = cls.__new__(cls)
        with catch_and_log_exceptions(context=cls.__name__):
            inst.__attrs_init__(
                message_count=message_count,
                schema_count=schema_count,
                channel_count=channel_count,
                attachment_count=attachment_count,
                metadata_count=metadata_count,
                chunk_count=chunk_count,
                message_start_time=message_start_time,
                message_end_time=message_end_time,
                channel_message_counts=channel_message_counts,
            )

        batches = inst.as_component_batches()
        if len(batches) == 0:
            return ComponentColumnList([])

        kwargs = {
            "McapStatistics:message_count": message_count,
            "McapStatistics:schema_count": schema_count,
            "McapStatistics:channel_count": channel_count,
            "McapStatistics:attachment_count": attachment_count,
            "McapStatistics:metadata_count": metadata_count,
            "McapStatistics:chunk_count": chunk_count,
            "McapStatistics:message_start_time": message_start_time,
            "McapStatistics:message_end_time": message_end_time,
            "McapStatistics:channel_message_counts": channel_message_counts,
        }
        columns = []

        for batch in batches:
            arrow_array = batch.as_arrow_array()

            # For primitive arrays and fixed size list arrays, we infer partition size from the input shape.
            if pa.types.is_primitive(arrow_array.type) or pa.types.is_fixed_size_list(arrow_array.type):
                param = kwargs[batch.component_descriptor().component]  # type: ignore[index]
                shape = np.shape(param)  # type: ignore[arg-type]
                elem_flat_len = int(np.prod(shape[1:])) if len(shape) > 1 else 1  # type: ignore[redundant-expr,misc]

                if pa.types.is_fixed_size_list(arrow_array.type) and arrow_array.type.list_size == elem_flat_len:
                    # If the product of the last dimensions of the shape are equal to the size of the fixed size list array,
                    # we have `num_rows` single element batches (each element is a fixed sized list).
                    # (This should have been already validated by conversion to the arrow_array)
                    batch_length = 1
                else:
                    batch_length = shape[1] if len(shape) > 1 else 1  # type: ignore[redundant-expr,misc]

                num_rows = shape[0] if len(shape) >= 1 else 1  # type: ignore[redundant-expr,misc]
                sizes = batch_length * np.ones(num_rows)
            else:
                # For non-primitive types, default to partitioning each element separately.
                sizes = np.ones(len(arrow_array))

            columns.append(batch.partition(sizes))

        return ComponentColumnList(columns)

    message_count: components.CountBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.CountBatch._converter,  # type: ignore[misc]
    )
    # Total number of data messages contained in the MCAP recording.
    #
    # This count includes all timestamped data messages but excludes metadata records,
    # schema definitions, and other non-message records.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    schema_count: components.CountBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.CountBatch._converter,  # type: ignore[misc]
    )
    # Number of unique schema definitions in the recording.
    #
    # Each schema defines the structure for one or more message types used by channels.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    channel_count: components.CountBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.CountBatch._converter,  # type: ignore[misc]
    )
    # Number of channels defined in the recording.
    #
    # Each channel represents a unique topic and encoding combination for publishing messages.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    attachment_count: components.CountBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.CountBatch._converter,  # type: ignore[misc]
    )
    # Number of file attachments embedded in the recording.
    #
    # Attachments can include calibration files, configuration data, or other auxiliary files.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    metadata_count: components.CountBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.CountBatch._converter,  # type: ignore[misc]
    )
    # Number of metadata records providing additional context about the recording.
    #
    # Metadata records contain key-value pairs with information about the recording environment,
    # system configuration, or other contextual data.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    chunk_count: components.CountBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.CountBatch._converter,  # type: ignore[misc]
    )
    # Number of data chunks used to organize messages in the file.
    #
    # Chunks group related messages together for efficient storage and indexed access.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    message_start_time: components.TimestampBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.TimestampBatch._converter,  # type: ignore[misc]
    )
    # Timestamp of the earliest message in the recording.
    #
    # This marks the beginning of the recorded data timeline.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    message_end_time: components.TimestampBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.TimestampBatch._converter,  # type: ignore[misc]
    )
    # Timestamp of the latest message in the recording.
    #
    # Together with `message_start_time`, this defines the total duration of the recording.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    channel_message_counts: components.ChannelMessageCountsBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.ChannelMessageCountsBatch._converter,  # type: ignore[misc]
    )
    # Detailed breakdown of message counts per channel.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    __str__ = Archetype.__str__
    __repr__ = Archetype.__repr__  # type: ignore[assignment]
