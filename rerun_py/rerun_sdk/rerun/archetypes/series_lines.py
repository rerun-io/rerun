# DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/python/mod.rs
# Based on "crates/store/re_types/definitions/rerun/archetypes/series_lines.fbs".

# You can extend this class by creating a "SeriesLinesExt" class in "series_lines_ext.py".

from __future__ import annotations

from typing import Any

import numpy as np
import pyarrow as pa
from attrs import define, field

from .. import components, datatypes
from .._baseclasses import (
    Archetype,
    ComponentColumnList,
)
from ..error_utils import catch_and_log_exceptions

__all__ = ["SeriesLines"]


@define(str=False, repr=False, init=False)
class SeriesLines(Archetype):
    """
    **Archetype**: Define the style properties for one or more line series in a chart.

    This archetype only provides styling information.
    Changes over time are supported for most but not all its fields (see respective fields for details),
    it's generally recommended to log this type as static.

    The underlying data needs to be logged to the same entity-path using [`archetypes.Scalars`][rerun.archetypes.Scalars].
    Dimensionality of the scalar arrays logged at each time point is assumed to be the same over time.

    Example
    -------
    ### Line series:
    ```python
    from math import cos, sin, tau

    import rerun as rr

    rr.init("rerun_example_series_line_style", spawn=True)

    # Set up plot styling:
    # They are logged as static as they don't change over time and apply to all timelines.
    # Log two lines series under a shared root so that they show in the same plot by default.
    rr.log("trig/sin", rr.SeriesLines(colors=[255, 0, 0], names="sin(0.01t)", widths=2), static=True)
    rr.log("trig/cos", rr.SeriesLines(colors=[0, 255, 0], names="cos(0.01t)", widths=4), static=True)

    # Log the data on a timeline called "step".
    for t in range(int(tau * 2 * 100.0)):
        rr.set_time("step", sequence=t)

        rr.log("trig/sin", rr.Scalars(sin(float(t) / 100.0)))
        rr.log("trig/cos", rr.Scalars(cos(float(t) / 100.0)))
    ```
    <center>
    <picture>
      <source media="(max-width: 480px)" srcset="https://static.rerun.io/series_line_style/d2616d98b1e46bdb85849b8669154fdf058e3453/480w.png">
      <source media="(max-width: 768px)" srcset="https://static.rerun.io/series_line_style/d2616d98b1e46bdb85849b8669154fdf058e3453/768w.png">
      <source media="(max-width: 1024px)" srcset="https://static.rerun.io/series_line_style/d2616d98b1e46bdb85849b8669154fdf058e3453/1024w.png">
      <source media="(max-width: 1200px)" srcset="https://static.rerun.io/series_line_style/d2616d98b1e46bdb85849b8669154fdf058e3453/1200w.png">
      <img src="https://static.rerun.io/series_line_style/d2616d98b1e46bdb85849b8669154fdf058e3453/full.png" width="640">
    </picture>
    </center>

    """

    def __init__(
        self: Any,
        *,
        colors: datatypes.Rgba32ArrayLike | None = None,
        widths: datatypes.Float32ArrayLike | None = None,
        names: datatypes.Utf8ArrayLike | None = None,
        visible_series: datatypes.BoolArrayLike | None = None,
        aggregation_policy: components.AggregationPolicyLike | None = None,
    ) -> None:
        """
        Create a new instance of the SeriesLines archetype.

        Parameters
        ----------
        colors:
            Color for the corresponding series.

            May change over time, but can cause discontinuities in the line.
        widths:
            Stroke width for the corresponding series.

            May change over time, but can cause discontinuities in the line.
        names:
            Display name of the series.

            Used in the legend. Expected to be unchanging over time.
        visible_series:
            Which lines are visible.

            If not set, all line series on this entity are visible.
            Unlike with the regular visibility property of the entire entity, any series that is hidden
            via this property will still be visible in the legend.

            May change over time, but can cause discontinuities in the line.
        aggregation_policy:
            Configures the zoom-dependent scalar aggregation.

            This is done only if steps on the X axis go below a single pixel,
            i.e. a single pixel covers more than one tick worth of data. It can greatly improve performance
            (and readability) in such situations as it prevents overdraw.

            Expected to be unchanging over time.

        """

        # You can define your own __init__ function as a member of SeriesLinesExt in series_lines_ext.py
        with catch_and_log_exceptions(context=self.__class__.__name__):
            self.__attrs_init__(
                colors=colors,
                widths=widths,
                names=names,
                visible_series=visible_series,
                aggregation_policy=aggregation_policy,
            )
            return
        self.__attrs_clear__()

    def __attrs_clear__(self) -> None:
        """Convenience method for calling `__attrs_init__` with all `None`s."""
        self.__attrs_init__(
            colors=None,
            widths=None,
            names=None,
            visible_series=None,
            aggregation_policy=None,
        )

    @classmethod
    def _clear(cls) -> SeriesLines:
        """Produce an empty SeriesLines, bypassing `__init__`."""
        inst = cls.__new__(cls)
        inst.__attrs_clear__()
        return inst

    @classmethod
    def from_fields(
        cls,
        *,
        clear_unset: bool = False,
        colors: datatypes.Rgba32ArrayLike | None = None,
        widths: datatypes.Float32ArrayLike | None = None,
        names: datatypes.Utf8ArrayLike | None = None,
        visible_series: datatypes.BoolArrayLike | None = None,
        aggregation_policy: components.AggregationPolicyLike | None = None,
    ) -> SeriesLines:
        """
        Update only some specific fields of a `SeriesLines`.

        Parameters
        ----------
        clear_unset:
            If true, all unspecified fields will be explicitly cleared.
        colors:
            Color for the corresponding series.

            May change over time, but can cause discontinuities in the line.
        widths:
            Stroke width for the corresponding series.

            May change over time, but can cause discontinuities in the line.
        names:
            Display name of the series.

            Used in the legend. Expected to be unchanging over time.
        visible_series:
            Which lines are visible.

            If not set, all line series on this entity are visible.
            Unlike with the regular visibility property of the entire entity, any series that is hidden
            via this property will still be visible in the legend.

            May change over time, but can cause discontinuities in the line.
        aggregation_policy:
            Configures the zoom-dependent scalar aggregation.

            This is done only if steps on the X axis go below a single pixel,
            i.e. a single pixel covers more than one tick worth of data. It can greatly improve performance
            (and readability) in such situations as it prevents overdraw.

            Expected to be unchanging over time.

        """

        inst = cls.__new__(cls)
        with catch_and_log_exceptions(context=cls.__name__):
            kwargs = {
                "colors": colors,
                "widths": widths,
                "names": names,
                "visible_series": visible_series,
                "aggregation_policy": aggregation_policy,
            }

            if clear_unset:
                kwargs = {k: v if v is not None else [] for k, v in kwargs.items()}  # type: ignore[misc]

            inst.__attrs_init__(**kwargs)
            return inst

        inst.__attrs_clear__()
        return inst

    @classmethod
    def cleared(cls) -> SeriesLines:
        """Clear all the fields of a `SeriesLines`."""
        return cls.from_fields(clear_unset=True)

    @classmethod
    def columns(
        cls,
        *,
        colors: datatypes.Rgba32ArrayLike | None = None,
        widths: datatypes.Float32ArrayLike | None = None,
        names: datatypes.Utf8ArrayLike | None = None,
        visible_series: datatypes.BoolArrayLike | None = None,
        aggregation_policy: components.AggregationPolicyArrayLike | None = None,
    ) -> ComponentColumnList:
        """
        Construct a new column-oriented component bundle.

        This makes it possible to use `rr.send_columns` to send columnar data directly into Rerun.

        The returned columns will be partitioned into unit-length sub-batches by default.
        Use `ComponentColumnList.partition` to repartition the data as needed.

        Parameters
        ----------
        colors:
            Color for the corresponding series.

            May change over time, but can cause discontinuities in the line.
        widths:
            Stroke width for the corresponding series.

            May change over time, but can cause discontinuities in the line.
        names:
            Display name of the series.

            Used in the legend. Expected to be unchanging over time.
        visible_series:
            Which lines are visible.

            If not set, all line series on this entity are visible.
            Unlike with the regular visibility property of the entire entity, any series that is hidden
            via this property will still be visible in the legend.

            May change over time, but can cause discontinuities in the line.
        aggregation_policy:
            Configures the zoom-dependent scalar aggregation.

            This is done only if steps on the X axis go below a single pixel,
            i.e. a single pixel covers more than one tick worth of data. It can greatly improve performance
            (and readability) in such situations as it prevents overdraw.

            Expected to be unchanging over time.

        """

        inst = cls.__new__(cls)
        with catch_and_log_exceptions(context=cls.__name__):
            inst.__attrs_init__(
                colors=colors,
                widths=widths,
                names=names,
                visible_series=visible_series,
                aggregation_policy=aggregation_policy,
            )

        batches = inst.as_component_batches()
        if len(batches) == 0:
            return ComponentColumnList([])

        kwargs = {
            "SeriesLines:colors": colors,
            "SeriesLines:widths": widths,
            "SeriesLines:names": names,
            "SeriesLines:visible_series": visible_series,
            "SeriesLines:aggregation_policy": aggregation_policy,
        }
        columns = []

        for batch in batches:
            arrow_array = batch.as_arrow_array()

            # For primitive arrays and fixed size list arrays, we infer partition size from the input shape.
            if pa.types.is_primitive(arrow_array.type) or pa.types.is_fixed_size_list(arrow_array.type):
                param = kwargs[batch.component_descriptor().component]  # type: ignore[index]
                shape = np.shape(param)  # type: ignore[arg-type]
                elem_flat_len = int(np.prod(shape[1:])) if len(shape) > 1 else 1  # type: ignore[redundant-expr,misc]

                if pa.types.is_fixed_size_list(arrow_array.type) and arrow_array.type.list_size == elem_flat_len:
                    # If the product of the last dimensions of the shape are equal to the size of the fixed size list array,
                    # we have `num_rows` single element batches (each element is a fixed sized list).
                    # (This should have been already validated by conversion to the arrow_array)
                    batch_length = 1
                else:
                    batch_length = shape[1] if len(shape) > 1 else 1  # type: ignore[redundant-expr,misc]

                num_rows = shape[0] if len(shape) >= 1 else 1  # type: ignore[redundant-expr,misc]
                sizes = batch_length * np.ones(num_rows)
            else:
                # For non-primitive types, default to partitioning each element separately.
                sizes = np.ones(len(arrow_array))

            columns.append(batch.partition(sizes))

        return ComponentColumnList(columns)

    colors: components.ColorBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.ColorBatch._converter,  # type: ignore[misc]
    )
    # Color for the corresponding series.
    #
    # May change over time, but can cause discontinuities in the line.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    widths: components.StrokeWidthBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.StrokeWidthBatch._converter,  # type: ignore[misc]
    )
    # Stroke width for the corresponding series.
    #
    # May change over time, but can cause discontinuities in the line.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    names: components.NameBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.NameBatch._converter,  # type: ignore[misc]
    )
    # Display name of the series.
    #
    # Used in the legend. Expected to be unchanging over time.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    visible_series: components.SeriesVisibleBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.SeriesVisibleBatch._converter,  # type: ignore[misc]
    )
    # Which lines are visible.
    #
    # If not set, all line series on this entity are visible.
    # Unlike with the regular visibility property of the entire entity, any series that is hidden
    # via this property will still be visible in the legend.
    #
    # May change over time, but can cause discontinuities in the line.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    aggregation_policy: components.AggregationPolicyBatch | None = field(
        metadata={"component": True},
        default=None,
        converter=components.AggregationPolicyBatch._converter,  # type: ignore[misc]
    )
    # Configures the zoom-dependent scalar aggregation.
    #
    # This is done only if steps on the X axis go below a single pixel,
    # i.e. a single pixel covers more than one tick worth of data. It can greatly improve performance
    # (and readability) in such situations as it prevents overdraw.
    #
    # Expected to be unchanging over time.
    #
    # (Docstring intentionally commented out to hide this field from the docs)

    __str__ = Archetype.__str__
    __repr__ = Archetype.__repr__  # type: ignore[assignment]
