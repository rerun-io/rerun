# NOTE: This file was autogenerated by re_types_builder; DO NOT EDIT.

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Sequence, Tuple, Union

import pyarrow as pa
from attrs import define, field

from .. import datatypes
from .._baseclasses import (
    BaseExtensionArray,
    BaseExtensionType,
)
from ._overrides import annotationinfo_native_to_pa_array  # noqa: F401

__all__ = [
    "AnnotationInfo",
    "AnnotationInfoArray",
    "AnnotationInfoArrayLike",
    "AnnotationInfoLike",
    "AnnotationInfoType",
]


def _annotationinfo_label_converter(x: datatypes.LabelLike | None) -> datatypes.Label | None:
    if x is None:
        return None
    elif isinstance(x, datatypes.Label):
        return x
    else:
        return datatypes.Label(x)


def _annotationinfo_color_converter(x: datatypes.ColorLike | None) -> datatypes.Color | None:
    if x is None:
        return None
    elif isinstance(x, datatypes.Color):
        return x
    else:
        return datatypes.Color(x)


@define
class AnnotationInfo:
    """
    Annotation info annotating a class id or key-point id.

    Color and label will be used to annotate entities/keypoints which reference the id.
    The id refers either to a class or key-point id
    """

    id: int = field(converter=int)
    """
    `ClassId` or `KeypointId` to which this annotation info belongs.
    """

    label: datatypes.Label | None = field(default=None, converter=_annotationinfo_label_converter)
    """
    The label that will be shown in the UI.
    """

    color: datatypes.Color | None = field(default=None, converter=_annotationinfo_color_converter)
    """
    The color that will be applied to the annotated entity.
    """


if TYPE_CHECKING:
    AnnotationInfoLike = Union[AnnotationInfo, Tuple[int, str], Tuple[int, str, datatypes.ColorLike]]
else:
    AnnotationInfoLike = Any

AnnotationInfoArrayLike = Union[
    AnnotationInfo,
    Sequence[AnnotationInfoLike],
]


# --- Arrow support ---


class AnnotationInfoType(BaseExtensionType):
    def __init__(self) -> None:
        pa.ExtensionType.__init__(
            self,
            pa.struct(
                [
                    pa.field("id", pa.uint16(), nullable=False, metadata={}),
                    pa.field("label", pa.utf8(), nullable=True, metadata={}),
                    pa.field("color", pa.uint32(), nullable=True, metadata={}),
                ]
            ),
            "rerun.datatypes.AnnotationInfo",
        )


class AnnotationInfoArray(BaseExtensionArray[AnnotationInfoArrayLike]):
    _EXTENSION_NAME = "rerun.datatypes.AnnotationInfo"
    _EXTENSION_TYPE = AnnotationInfoType

    @staticmethod
    def _native_to_pa_array(data: AnnotationInfoArrayLike, data_type: pa.DataType) -> pa.Array:
        return annotationinfo_native_to_pa_array(data, data_type)


AnnotationInfoType._ARRAY_TYPE = AnnotationInfoArray

# TODO(cmc): bring back registration to pyarrow once legacy types are gone
# pa.register_extension_type(AnnotationInfoType())
