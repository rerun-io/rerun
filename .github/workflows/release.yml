name: Release

on:
  workflow_dispatch:
    inputs:
      release-type:
        description: "What kind of release is this?"
        type: choice
        options:
          - alpha
          - rc
          - final
        required: true

concurrency:
  group: ${{ github.ref_name }}
  cancel-in-progress: true

permissions: # wants to push commits and create a PR
  contents: write
  id-token: write

jobs:
  # Re-entrancy:
  # - `version` is re-entrant because it doesn't commit/create PR if the version doesn't change,
  #   and the version doesn't change if we're already on the final version specified by the branch name.
  # - `update-docs` is re-entrant because it overwrites history of the `gh-pages` branch, so any
  #   previous partial update will just be overwritten by the next successful run.
  # - `publish-crates` is re-entrant because the `crates.py` script correctly handles publish failures
  #   by first checking if a crate has already been published before attempting to publish it.
  # - `build-and-publish-wheels` is re-entrant because all the uploaded artifacts will be overwritten
  #   by any subsequent runs, and the final upload to PyPI has the `--skip-existing` flag, which ignores
  #   any wheels already uploaded.
  # - `build-and-publish-web` is re-entrant for the same reason as `build-and-publish-wheels`,
  #   except that uploads are done to GCS instead of PyPI.
  version:
    name: "Versioning"
    runs-on: ubuntu-latest

    outputs:
      previous: ${{ steps.versioning.outputs.previous }}
      current: ${{ steps.versioning.outputs.current }}
      final: ${{ steps.versioning.outputs.final }}
      # will be set to `github.sha` if the pull request already exists
      # this is the last (and not merge) commit in the release branch
      release-commit: ${{ steps.commit.outputs.version_bump_commit_sha || github.sha }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.RERUN_BOT_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.x

      - name: Install deps
        run: |
          python3 -m pip install -r ./scripts/ci/requirements.txt

      - name: Update crate versions
        id: versioning
        run: |

          # parse the release version from the branch name
          #   `release-0.8.1-meta.N` -> `0.8.1`
          release_version=$(python3 scripts/ci/crates.py get-version --from-git --finalize)

          # store version before the update, so we can later detect if it changed
          previous=$(python3 scripts/ci/crates.py get-version)

          # if the version minus prerelease/build metadata is not the same as the release version,
          # then update it.
          if [ $(python3 scripts/ci/crates.py get-version --finalize) != $release_version ]; then
            python3 scripts/ci/crates.py version --exact $release_version
          fi

          # if this is an `rc`, additionally set add `-rc.N`
          # this will also bump the `N` if `-rc.N` is already set
          if [ ${{ inputs.release-type }} = "rc" ]; then
            python3 scripts/ci/crates.py version --bump prerelease --pre-id=rc
          fi

          # if this is an `alpha`, set the version to whatever is in the git branch name.
          if [ ${{ inputs.release-type }} = "alpha" ]; then
            python3 scripts/ci/crates.py version --exact $(python3 scripts/ci/crates.py get-version --from-git)
          fi

          # if this is a `final`, set the version to the final release version
          if [ ${{ inputs.release-type }} = "final" ]; then
            python3 scripts/ci/crates.py version --exact $release_version
          fi

          # store version after the update, and the expected "final" release version
          current=$(python3 scripts/ci/crates.py get-version)
          final=$(python3 scripts/ci/crates.py get-version --finalize)

          # output everything for use in other steps
          echo "previous=$previous" >> "$GITHUB_OUTPUT"
          echo "current=$current"   >> "$GITHUB_OUTPUT"
          echo "final=$final"       >> "$GITHUB_OUTPUT"

      - name: Commit new version
        id: commit
        if: steps.versioning.outputs.previous != steps.versioning.outputs.current
        run: |
          git config --global user.name "rerun-bot"
          git config --global user.email "bot@rerun.io"
          git commit -am "Bump versions to ${{ steps.versioning.outputs.current }}"
          git push
          echo "version_bump_commit_sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Create pull request
        env:
          GH_TOKEN: ${{ secrets.RERUN_BOT_TOKEN }}
        run: |
          pr=$(gh pr view --json headRefName 2>/dev/null)
          if echo "$pr" | jq '. | has("headRefName")' | grep -q 'true'; then
            echo "PR already exists"
            exit 0
          fi

          echo "PR does not exist, creating…"

          cat <<EOF > pr-body.txt
          # Release ${{ steps.versioning.outputs.final }}

          ### Next steps
          - [Test the release](#testing)
          - If this is an `alpha` release, you can just merge the pull request.
          - Otherwise:
            - For any added commits, run the release workflow in `rc` mode again
            - After testing, run the release workflow in `release` mode
            - Once the final release workflow finishes, [create a GitHub release](https://github.com/rerun-io/rerun/releases/new)
          EOF

          gh pr create \
            --base main \
            --head $(git branch --show-current) \
            --label "⛴ release" \
            --label "exclude from changelog" \
            --fill \
            --body-file pr-body.txt

  update-docs:
    name: "Update Docs"
    needs: [version]
    uses: ./.github/workflows/reusable_deploy_docs.yml
    with:
      CONCURRENCY: ${{ github.ref_name }}
      PY_DOCS_VERSION_NAME: ${{ inputs.release-type == 'final' && needs.version.outputs.final || 'dev' }}
      RS_DOCS_VERSION_NAME: ${{ inputs.release-type == 'final' && 'stable' || 'dev' }}
      UPDATE_LATEST: ${{ inputs.release-type == 'final' }}
      RELEASE_COMMIT: ${{ needs.version.outputs.release-commit }}
    secrets: inherit

  publish-crates:
    name: "Publish Crates"
    needs: [version]
    uses: ./.github/workflows/reusable_release_crates.yml
    with:
      CONCURRENCY: ${{ github.ref_name }}
      RELEASE_COMMIT: ${{ needs.version.outputs.release-commit }}
    secrets: inherit

  build-and-publish-wheels:
    name: "Build and Publish Wheels"
    needs: [version]
    uses: ./.github/workflows/reusable_build_and_publish_wheels.yml
    with:
      release-version: ${{ needs.version.outputs.current }}
      concurrency: ${{ github.ref_name }}
      linux-wheel-name: linux-wheel
      linux-rrd-name: linux-rrd
      release-commit: ${{ needs.version.outputs.release-commit }}
    secrets: inherit

  build-and-publish-web:
    name: "Build and Publish Web"
    needs: [version, build-and-publish-wheels]
    uses: ./.github/workflows/reusable_build_and_publish_web.yml
    with:
      release-version: ${{ needs.version.outputs.current }}
      release-commit: ${{ needs.version.outputs.release-commit }}
      concurrency: ${{ github.ref_name }}
      wheel-artifact-name: linux-wheel
      rrd-artifact-name: linux-rrd
      update-latest: ${{ inputs.release-type == 'final' }}
    secrets: inherit

  update-latest-branch:
    name: "Update Latest Branch"
    if: inputs.release-type == 'final'
    needs: [version, update-docs, publish-crates, build-and-publish-wheels, build-and-publish-web]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.version.outputs.release-commit }}

      - name: Update latest branch
        run: |
          git fetch
          git checkout ${{ github.ref_name }}
          git push --force origin ${{ github.ref_name }}:latest

  alpha-version-bump:
    name: "Alpha Version Bump"
    if: inputs.release-type == 'alpha'
    needs: [version, update-docs, publish-crates, build-and-publish-wheels, build-and-publish-web]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.RERUN_BOT_TOKEN }}

      - name: Install dependencies
        run: |
          python3 -m pip install -r scripts/ci/requirements.txt

      # After an alpha release, we bump the prerelease version and append `+dev`.
      - name: Update version
        id: update-version
        run: |
          python3 scripts/ci/crates.py version --bump prerelease --dev
          echo "version=$(python3 scripts/ci/crates.py get-version)" >> "$GITHUB_OUTPUT"

      - name: Commit new version
        run: |
          git config --global user.name "rerun-bot"
          git config --global user.email "bot@rerun.io"
          git commit -am "Bump versions to ${{ steps.update-version.outputs.version }}"
          git push

  final-version-bump:
    name: "Post-release Version Bump"
    if: inputs.release-type == 'final'
    needs: [version, update-docs, publish-crates, build-and-publish-wheels, build-and-publish-web]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.RERUN_BOT_TOKEN }}

      - name: Install dependencies
        run: |
          python3 -m pip install -r scripts/ci/requirements.txt

      # After a release, we bump the minor version and append `+dev`.
      - name: Update version
        id: update-version
        run: |
          python3 scripts/ci/crates.py version --bump minor --dev
          echo "version=$(python3 scripts/ci/crates.py get-version)" >> "$GITHUB_OUTPUT"

      - name: Commit new version
        id: commit-version
        run: |
          branch_name="bump-${{ steps.update-version.outputs.version }}"
          git checkout -b $branch_name
          git commit -am "Bump versions to ${{ steps.update-version.outputs.version }}"
          git push -u origin $branch_name
          echo "branch=$branch_name" >> "$GITHUB_OUTPUT"

      - name: Create pull request
        env:
          GH_TOKEN: ${{ secrets.RERUN_BOT_TOKEN }}
        run: |
          cat <<EOF > pr-body.txt
          ### What

          - [x] Bump all crate versions to `${{ steps.update-version.outputs.version }}`
          EOF

          gh pr create \
            --base main \
            --head ${{ steps.commit-version.outputs.branch }} \
            --label "⛴ release" \
            --label "exclude from changelog" \
            --fill \
            --body-file pr-body.txt

