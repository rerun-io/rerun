use re_log_types::{EncodedMesh3D, Mesh3D, MeshFormat, RawMesh3D};

use re_renderer::resource_managers::{MeshManager, ResourceLifeTime, TextureManager2D};

pub struct CpuMesh {
    name: String,

    // TODO(andreas): We should only have MeshHandles here (which are generated by the MeshManager!)
    // Can't do that right now because it's too hard to pass the render context through.
    pub mesh_instances: Vec<re_renderer::renderer::MeshInstance>,

    bbox: macaw::BoundingBox,
}

impl CpuMesh {
    pub fn load(
        name: String,
        mesh: &Mesh3D,
        mesh_manager: &mut MeshManager,
        texture_manager: &mut TextureManager2D,
    ) -> anyhow::Result<Self> {
        // TODO(emilk): load CpuMesh in background thread.
        match mesh {
            // Mesh from user logging some triangles.
            Mesh3D::Encoded(encoded_mesh) => {
                Self::load_encoded_mesh(name, encoded_mesh, mesh_manager, texture_manager)
            }
            // Mesh from some file format. File passed in bytes.
            Mesh3D::Raw(raw_mesh) => Ok(Self::load_raw_mesh(
                name,
                raw_mesh,
                mesh_manager,
                texture_manager,
            )),
        }
    }

    pub fn load_raw(
        name: String,
        format: MeshFormat,
        bytes: &[u8],
        mesh_manager: &mut MeshManager,
        texture_manager: &mut TextureManager2D,
    ) -> anyhow::Result<Self> {
        crate::profile_function!();
        let mesh_instances = match format {
            MeshFormat::Glb | MeshFormat::Gltf => {
                re_renderer::importer::gltf::load_gltf_from_buffer(
                    &name,
                    bytes,
                    ResourceLifeTime::LongLived,
                    mesh_manager,
                    texture_manager,
                )
            }
            MeshFormat::Obj => re_renderer::importer::obj::load_obj_from_buffer(
                bytes,
                ResourceLifeTime::LongLived,
                mesh_manager,
                texture_manager,
            ),
        }?;
        let bbox = re_renderer::importer::calculate_bounding_box(mesh_manager, &mesh_instances);

        Ok(Self {
            name,
            bbox,
            mesh_instances,
        })
    }

    fn load_encoded_mesh(
        name: String,
        encoded_mesh: &EncodedMesh3D,
        mesh_manager: &mut MeshManager,
        texture_manager: &mut TextureManager2D,
    ) -> anyhow::Result<Self> {
        crate::profile_function!();
        let EncodedMesh3D {
            format,
            bytes,
            transform,
        } = encoded_mesh;

        let mut slf = Self::load_raw(name, *format, bytes, mesh_manager, texture_manager)?;

        let (scale, rotation, translation) =
            glam::Affine3A::from_cols_array_2d(transform).to_scale_rotation_translation();
        let transform = macaw::Conformal3::from_scale_rotation_translation(
            re_renderer::importer::to_uniform_scale(scale),
            rotation,
            translation,
        );
        for instance in &mut slf.mesh_instances {
            instance.world_from_mesh = transform * instance.world_from_mesh;
        }
        slf.bbox = re_renderer::importer::calculate_bounding_box(mesh_manager, &slf.mesh_instances);

        Ok(slf)
    }

    fn load_raw_mesh(
        name: String,
        raw_mesh: &RawMesh3D,
        mesh_manager: &mut MeshManager,
        texture_manager: &mut TextureManager2D,
    ) -> Self {
        crate::profile_function!();

        let bbox = macaw::BoundingBox::from_points(
            raw_mesh.positions.iter().map(|p| glam::Vec3::from(*p)),
        );

        let mesh_instances = vec![re_renderer::renderer::MeshInstance {
            mesh: mesh_manager.store_resource(
                re_renderer::mesh::Mesh {
                    label: name.clone().into(),
                    indices: raw_mesh.indices.iter().flatten().cloned().collect(),
                    vertex_positions: raw_mesh
                        .positions
                        .iter()
                        .map(|p| glam::Vec3::from(*p))
                        .collect(),
                    // TODO(andreas): Calculate normals
                    vertex_data: std::iter::repeat(
                        re_renderer::mesh::mesh_vertices::MeshVertexData {
                            normal: glam::Vec3::ZERO,
                            texcoord: glam::Vec2::ZERO,
                        },
                    )
                    .take(raw_mesh.positions.len())
                    .collect(),
                    materials: smallvec::smallvec![re_renderer::mesh::Material {
                        label: name.clone().into(),
                        index_range: 0..raw_mesh.indices.len() as _,
                        albedo: texture_manager.white_texture(),
                    }],
                },
                ResourceLifeTime::LongLived,
            ),
            world_from_mesh: Default::default(),
            additive_tint_srgb: [0, 0, 0, 0],
        }];

        Self {
            name,
            bbox,
            mesh_instances,
        }
    }

    #[allow(dead_code)]
    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn bbox(&self) -> &macaw::BoundingBox {
        &self.bbox
    }
}
