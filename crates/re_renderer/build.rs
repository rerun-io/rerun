use cargo_metadata::{CargoOpt, Metadata, MetadataCommand, Package, PackageId};
use std::{
    collections::{HashMap, HashSet},
    ffi::OsString,
    path::{Path, PathBuf},
    process::{Command, Stdio},
};
use walkdir::{DirEntry, WalkDir};

// ---

// Mapping to cargo:rerun-if-changed with glob support
fn rerun_if_changed(path: &str) {
    for path in glob::glob(path).unwrap() {
        println!("cargo:rerun-if-changed={}", path.unwrap().to_string_lossy());
    }
}

// ---

// TODO: document how hermetism work

fn main() {
    let metadata = MetadataCommand::new()
        .features(CargoOpt::AllFeatures)
        .exec()
        .unwrap();

    let root_path: &Path = metadata.workspace_root.as_ref();
    let src_path = Path::new(&std::env::var("CARGO_MANIFEST_DIR").unwrap()).join("src");
    let file_path = src_path.join("workspace_shaders.rs");

    fn is_wgsl(entry: &DirEntry) -> bool {
        let is_dir = entry.file_type().is_dir();
        let is_wgsl = entry
            .file_name()
            .to_str()
            .map(|s| s.ends_with(".wgsl"))
            .unwrap_or(false);
        is_dir || is_wgsl
    }

    let mut contents = r#"
        // This file is autogenerated via build.rs.
        // DO NOT EDIT.

        #[cfg(all(not(target_arch = "wasm32"), debug_assertions))] // non-wasm + debug build
        pub fn workspace_shaders() {}

        #[cfg(not(all(not(target_arch = "wasm32"), debug_assertions)))] // otherwise
        static ONCE: ::std::sync::atomic::AtomicBool = ::std::sync::atomic::AtomicBool::new(false);

        #[cfg(not(all(not(target_arch = "wasm32"), debug_assertions)))] // otherwise
        pub fn workspace_shaders() {
            if ONCE.swap(true, ::std::sync::atomic::Ordering::Relaxed) {
                return;
            }

            println!("coucou");

            use crate::file_system::FileSystem as _;
            let fs = crate::MemFileSystem::get();
        "#
    .to_string();

    // TODO: explain
    let to_be_stripped = {
        let mut to_be_stripped = root_path.to_path_buf();
        to_be_stripped.pop();
        to_be_stripped.to_string_lossy().to_string()
    };

    let walker = WalkDir::new(root_path).into_iter();
    for entry in walker.filter_entry(|de| is_wgsl(de)) {
        let entry = entry.unwrap();

        if !entry.file_type().is_file() {
            continue;
        }

        rerun_if_changed(entry.path().to_string_lossy().as_ref());

        let relpath = pathdiff::diff_paths(entry.path(), &src_path).unwrap();
        let virtpath = entry.path().strip_prefix(&to_be_stripped).unwrap();

        contents += &format!(
            "
            {{
                let virtpath = ::std::path::Path::new({virtpath:?});
                fs.create_file(&virtpath, include_str!({relpath:?}).into()).unwrap();
            }}
            ",
        );
    }

    contents += "}";

    std::fs::write(&file_path, contents).unwrap();

    let output = Command::new(std::env::var("CARGO").unwrap_or("cargo".to_string()))
        .args(["fmt", "--", file_path.to_string_lossy().as_ref()])
        .output()
        .expect("failed to execute process");

    eprintln!("status: {}", output.status);
    eprintln!("stderr: {}", String::from_utf8_lossy(&output.stderr));

    assert!(output.status.success());
}
