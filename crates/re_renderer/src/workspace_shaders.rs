// This file is autogenerated via build.rs.
// DO NOT EDIT.

static ONCE: ::std::sync::atomic::AtomicBool = ::std::sync::atomic::AtomicBool::new(false);

pub fn init() {
    if ONCE.swap(true, ::std::sync::atomic::Ordering::Relaxed) {
        return;
    }

    use crate::file_system::FileSystem as _;
    let fs = crate::MemFileSystem::get();

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/generic_skybox.wgsl");
        fs.create_file(
            &virtpath,
            include_str!("../shader/generic_skybox.wgsl").into(),
        )
        .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/global_bindings.wgsl");
        fs.create_file(
            &virtpath,
            include_str!("../shader/global_bindings.wgsl").into(),
        )
        .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/instanced_mesh.wgsl");
        fs.create_file(
            &virtpath,
            include_str!("../shader/instanced_mesh.wgsl").into(),
        )
        .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/lines.wgsl");
        fs.create_file(&virtpath, include_str!("../shader/lines.wgsl").into())
            .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/mesh_vertex.wgsl");
        fs.create_file(&virtpath, include_str!("../shader/mesh_vertex.wgsl").into())
            .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/point_cloud.wgsl");
        fs.create_file(&virtpath, include_str!("../shader/point_cloud.wgsl").into())
            .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/screen_triangle.wgsl");
        fs.create_file(
            &virtpath,
            include_str!("../shader/screen_triangle.wgsl").into(),
        )
        .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/test_triangle.wgsl");
        fs.create_file(
            &virtpath,
            include_str!("../shader/test_triangle.wgsl").into(),
        )
        .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/tonemap.wgsl");
        fs.create_file(&virtpath, include_str!("../shader/tonemap.wgsl").into())
            .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/types.wgsl");
        fs.create_file(&virtpath, include_str!("../shader/types.wgsl").into())
            .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/utils/encoding.wgsl");
        fs.create_file(
            &virtpath,
            include_str!("../shader/utils/encoding.wgsl").into(),
        )
        .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/utils/quaternion.wgsl");
        fs.create_file(
            &virtpath,
            include_str!("../shader/utils/quaternion.wgsl").into(),
        )
        .unwrap();
    }

    {
        let virtpath = ::std::path::Path::new("crates/re_renderer/shader/utils/srgb.wgsl");
        fs.create_file(&virtpath, include_str!("../shader/utils/srgb.wgsl").into())
            .unwrap();
    }
}
