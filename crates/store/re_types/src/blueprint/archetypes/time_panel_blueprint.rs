// DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/rust/api.rs
// Based on "crates/store/re_types/definitions/rerun/blueprint/archetypes/panel_blueprint.fbs".

#![allow(unused_braces)]
#![allow(unused_imports)]
#![allow(unused_parens)]
#![allow(clippy::allow_attributes)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::cloned_instead_of_copied)]
#![allow(clippy::map_flatten)]
#![allow(clippy::needless_question_mark)]
#![allow(clippy::new_without_default)]
#![allow(clippy::redundant_closure)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::too_many_lines)]
#![allow(clippy::wildcard_imports)]

use ::re_types_core::SerializationResult;
use ::re_types_core::try_serialize_field;
use ::re_types_core::{ComponentBatch as _, SerializedComponentBatch};
use ::re_types_core::{ComponentDescriptor, ComponentType};
use ::re_types_core::{DeserializationError, DeserializationResult};

/// **Archetype**: Time panel specific state.
///
/// ⚠️ **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**
#[derive(Clone, Debug, Default)]
pub struct TimePanelBlueprint {
    /// Current state of the panel.
    pub state: Option<SerializedComponentBatch>,

    /// What timeline the panel is on.
    pub timeline: Option<SerializedComponentBatch>,

    /// What time the time cursor should be on.
    pub time: Option<SerializedComponentBatch>,

    /// A time playback speed multiplier.
    pub playback_speed: Option<SerializedComponentBatch>,

    /// Frames per second. Only applicable for sequence timelines.
    pub fps: Option<SerializedComponentBatch>,

    /// If the time is currently paused, playing, or following.
    ///
    /// Defaults to either playing or following, depending on the data source.
    pub play_state: Option<SerializedComponentBatch>,

    /// How the time should loop. A selection loop only works if there is also a `time_selection` passed.
    ///
    /// Defaults to off.
    pub loop_mode: Option<SerializedComponentBatch>,

    /// Selects a range of time on the time panel.
    pub time_selection: Option<SerializedComponentBatch>,
}

impl TimePanelBlueprint {
    /// Returns the [`ComponentDescriptor`] for [`Self::state`].
    ///
    /// The corresponding component is [`crate::blueprint::components::PanelState`].
    #[inline]
    pub fn descriptor_state() -> ComponentDescriptor {
        ComponentDescriptor {
            archetype: Some("rerun.blueprint.archetypes.TimePanelBlueprint".into()),
            component: "TimePanelBlueprint:state".into(),
            component_type: Some("rerun.blueprint.components.PanelState".into()),
        }
    }

    /// Returns the [`ComponentDescriptor`] for [`Self::timeline`].
    ///
    /// The corresponding component is [`crate::blueprint::components::TimelineName`].
    #[inline]
    pub fn descriptor_timeline() -> ComponentDescriptor {
        ComponentDescriptor {
            archetype: Some("rerun.blueprint.archetypes.TimePanelBlueprint".into()),
            component: "TimePanelBlueprint:timeline".into(),
            component_type: Some("rerun.blueprint.components.TimelineName".into()),
        }
    }

    /// Returns the [`ComponentDescriptor`] for [`Self::time`].
    ///
    /// The corresponding component is [`crate::blueprint::components::TimeInt`].
    #[inline]
    pub fn descriptor_time() -> ComponentDescriptor {
        ComponentDescriptor {
            archetype: Some("rerun.blueprint.archetypes.TimePanelBlueprint".into()),
            component: "TimePanelBlueprint:time".into(),
            component_type: Some("rerun.blueprint.components.TimeInt".into()),
        }
    }

    /// Returns the [`ComponentDescriptor`] for [`Self::playback_speed`].
    ///
    /// The corresponding component is [`crate::blueprint::components::PlaybackSpeed`].
    #[inline]
    pub fn descriptor_playback_speed() -> ComponentDescriptor {
        ComponentDescriptor {
            archetype: Some("rerun.blueprint.archetypes.TimePanelBlueprint".into()),
            component: "TimePanelBlueprint:playback_speed".into(),
            component_type: Some("rerun.blueprint.components.PlaybackSpeed".into()),
        }
    }

    /// Returns the [`ComponentDescriptor`] for [`Self::fps`].
    ///
    /// The corresponding component is [`crate::blueprint::components::Fps`].
    #[inline]
    pub fn descriptor_fps() -> ComponentDescriptor {
        ComponentDescriptor {
            archetype: Some("rerun.blueprint.archetypes.TimePanelBlueprint".into()),
            component: "TimePanelBlueprint:fps".into(),
            component_type: Some("rerun.blueprint.components.Fps".into()),
        }
    }

    /// Returns the [`ComponentDescriptor`] for [`Self::play_state`].
    ///
    /// The corresponding component is [`crate::blueprint::components::PlayState`].
    #[inline]
    pub fn descriptor_play_state() -> ComponentDescriptor {
        ComponentDescriptor {
            archetype: Some("rerun.blueprint.archetypes.TimePanelBlueprint".into()),
            component: "TimePanelBlueprint:play_state".into(),
            component_type: Some("rerun.blueprint.components.PlayState".into()),
        }
    }

    /// Returns the [`ComponentDescriptor`] for [`Self::loop_mode`].
    ///
    /// The corresponding component is [`crate::blueprint::components::LoopMode`].
    #[inline]
    pub fn descriptor_loop_mode() -> ComponentDescriptor {
        ComponentDescriptor {
            archetype: Some("rerun.blueprint.archetypes.TimePanelBlueprint".into()),
            component: "TimePanelBlueprint:loop_mode".into(),
            component_type: Some("rerun.blueprint.components.LoopMode".into()),
        }
    }

    /// Returns the [`ComponentDescriptor`] for [`Self::time_selection`].
    ///
    /// The corresponding component is [`crate::blueprint::components::AbsoluteTimeRange`].
    #[inline]
    pub fn descriptor_time_selection() -> ComponentDescriptor {
        ComponentDescriptor {
            archetype: Some("rerun.blueprint.archetypes.TimePanelBlueprint".into()),
            component: "TimePanelBlueprint:time_selection".into(),
            component_type: Some("rerun.blueprint.components.AbsoluteTimeRange".into()),
        }
    }
}

static REQUIRED_COMPONENTS: std::sync::LazyLock<[ComponentDescriptor; 0usize]> =
    std::sync::LazyLock::new(|| []);

static RECOMMENDED_COMPONENTS: std::sync::LazyLock<[ComponentDescriptor; 0usize]> =
    std::sync::LazyLock::new(|| []);

static OPTIONAL_COMPONENTS: std::sync::LazyLock<[ComponentDescriptor; 8usize]> =
    std::sync::LazyLock::new(|| {
        [
            TimePanelBlueprint::descriptor_state(),
            TimePanelBlueprint::descriptor_timeline(),
            TimePanelBlueprint::descriptor_time(),
            TimePanelBlueprint::descriptor_playback_speed(),
            TimePanelBlueprint::descriptor_fps(),
            TimePanelBlueprint::descriptor_play_state(),
            TimePanelBlueprint::descriptor_loop_mode(),
            TimePanelBlueprint::descriptor_time_selection(),
        ]
    });

static ALL_COMPONENTS: std::sync::LazyLock<[ComponentDescriptor; 8usize]> =
    std::sync::LazyLock::new(|| {
        [
            TimePanelBlueprint::descriptor_state(),
            TimePanelBlueprint::descriptor_timeline(),
            TimePanelBlueprint::descriptor_time(),
            TimePanelBlueprint::descriptor_playback_speed(),
            TimePanelBlueprint::descriptor_fps(),
            TimePanelBlueprint::descriptor_play_state(),
            TimePanelBlueprint::descriptor_loop_mode(),
            TimePanelBlueprint::descriptor_time_selection(),
        ]
    });

impl TimePanelBlueprint {
    /// The total number of components in the archetype: 0 required, 0 recommended, 8 optional
    pub const NUM_COMPONENTS: usize = 8usize;
}

impl ::re_types_core::Archetype for TimePanelBlueprint {
    #[inline]
    fn name() -> ::re_types_core::ArchetypeName {
        "rerun.blueprint.archetypes.TimePanelBlueprint".into()
    }

    #[inline]
    fn display_name() -> &'static str {
        "Time panel blueprint"
    }

    #[inline]
    fn required_components() -> ::std::borrow::Cow<'static, [ComponentDescriptor]> {
        REQUIRED_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn recommended_components() -> ::std::borrow::Cow<'static, [ComponentDescriptor]> {
        RECOMMENDED_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn optional_components() -> ::std::borrow::Cow<'static, [ComponentDescriptor]> {
        OPTIONAL_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn all_components() -> ::std::borrow::Cow<'static, [ComponentDescriptor]> {
        ALL_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn from_arrow_components(
        arrow_data: impl IntoIterator<Item = (ComponentDescriptor, arrow::array::ArrayRef)>,
    ) -> DeserializationResult<Self> {
        re_tracing::profile_function!();
        use ::re_types_core::{Loggable as _, ResultExt as _};
        let arrays_by_descr: ::nohash_hasher::IntMap<_, _> = arrow_data.into_iter().collect();
        let state = arrays_by_descr
            .get(&Self::descriptor_state())
            .map(|array| SerializedComponentBatch::new(array.clone(), Self::descriptor_state()));
        let timeline = arrays_by_descr
            .get(&Self::descriptor_timeline())
            .map(|array| SerializedComponentBatch::new(array.clone(), Self::descriptor_timeline()));
        let time = arrays_by_descr
            .get(&Self::descriptor_time())
            .map(|array| SerializedComponentBatch::new(array.clone(), Self::descriptor_time()));
        let playback_speed = arrays_by_descr
            .get(&Self::descriptor_playback_speed())
            .map(|array| {
                SerializedComponentBatch::new(array.clone(), Self::descriptor_playback_speed())
            });
        let fps = arrays_by_descr
            .get(&Self::descriptor_fps())
            .map(|array| SerializedComponentBatch::new(array.clone(), Self::descriptor_fps()));
        let play_state = arrays_by_descr
            .get(&Self::descriptor_play_state())
            .map(|array| {
                SerializedComponentBatch::new(array.clone(), Self::descriptor_play_state())
            });
        let loop_mode = arrays_by_descr
            .get(&Self::descriptor_loop_mode())
            .map(|array| {
                SerializedComponentBatch::new(array.clone(), Self::descriptor_loop_mode())
            });
        let time_selection = arrays_by_descr
            .get(&Self::descriptor_time_selection())
            .map(|array| {
                SerializedComponentBatch::new(array.clone(), Self::descriptor_time_selection())
            });
        Ok(Self {
            state,
            timeline,
            time,
            playback_speed,
            fps,
            play_state,
            loop_mode,
            time_selection,
        })
    }
}

impl ::re_types_core::AsComponents for TimePanelBlueprint {
    #[inline]
    fn as_serialized_batches(&self) -> Vec<SerializedComponentBatch> {
        use ::re_types_core::Archetype as _;
        [
            self.state.clone(),
            self.timeline.clone(),
            self.time.clone(),
            self.playback_speed.clone(),
            self.fps.clone(),
            self.play_state.clone(),
            self.loop_mode.clone(),
            self.time_selection.clone(),
        ]
        .into_iter()
        .flatten()
        .collect()
    }
}

impl ::re_types_core::ArchetypeReflectionMarker for TimePanelBlueprint {}

impl TimePanelBlueprint {
    /// Create a new `TimePanelBlueprint`.
    #[inline]
    pub fn new() -> Self {
        Self {
            state: None,
            timeline: None,
            time: None,
            playback_speed: None,
            fps: None,
            play_state: None,
            loop_mode: None,
            time_selection: None,
        }
    }

    /// Update only some specific fields of a `TimePanelBlueprint`.
    #[inline]
    pub fn update_fields() -> Self {
        Self::default()
    }

    /// Clear all the fields of a `TimePanelBlueprint`.
    #[inline]
    pub fn clear_fields() -> Self {
        use ::re_types_core::Loggable as _;
        Self {
            state: Some(SerializedComponentBatch::new(
                crate::blueprint::components::PanelState::arrow_empty(),
                Self::descriptor_state(),
            )),
            timeline: Some(SerializedComponentBatch::new(
                crate::blueprint::components::TimelineName::arrow_empty(),
                Self::descriptor_timeline(),
            )),
            time: Some(SerializedComponentBatch::new(
                crate::blueprint::components::TimeInt::arrow_empty(),
                Self::descriptor_time(),
            )),
            playback_speed: Some(SerializedComponentBatch::new(
                crate::blueprint::components::PlaybackSpeed::arrow_empty(),
                Self::descriptor_playback_speed(),
            )),
            fps: Some(SerializedComponentBatch::new(
                crate::blueprint::components::Fps::arrow_empty(),
                Self::descriptor_fps(),
            )),
            play_state: Some(SerializedComponentBatch::new(
                crate::blueprint::components::PlayState::arrow_empty(),
                Self::descriptor_play_state(),
            )),
            loop_mode: Some(SerializedComponentBatch::new(
                crate::blueprint::components::LoopMode::arrow_empty(),
                Self::descriptor_loop_mode(),
            )),
            time_selection: Some(SerializedComponentBatch::new(
                crate::blueprint::components::AbsoluteTimeRange::arrow_empty(),
                Self::descriptor_time_selection(),
            )),
        }
    }

    /// Current state of the panel.
    #[inline]
    pub fn with_state(
        mut self,
        state: impl Into<crate::blueprint::components::PanelState>,
    ) -> Self {
        self.state = try_serialize_field(Self::descriptor_state(), [state]);
        self
    }

    /// What timeline the panel is on.
    #[inline]
    pub fn with_timeline(
        mut self,
        timeline: impl Into<crate::blueprint::components::TimelineName>,
    ) -> Self {
        self.timeline = try_serialize_field(Self::descriptor_timeline(), [timeline]);
        self
    }

    /// What time the time cursor should be on.
    #[inline]
    pub fn with_time(mut self, time: impl Into<crate::blueprint::components::TimeInt>) -> Self {
        self.time = try_serialize_field(Self::descriptor_time(), [time]);
        self
    }

    /// A time playback speed multiplier.
    #[inline]
    pub fn with_playback_speed(
        mut self,
        playback_speed: impl Into<crate::blueprint::components::PlaybackSpeed>,
    ) -> Self {
        self.playback_speed =
            try_serialize_field(Self::descriptor_playback_speed(), [playback_speed]);
        self
    }

    /// Frames per second. Only applicable for sequence timelines.
    #[inline]
    pub fn with_fps(mut self, fps: impl Into<crate::blueprint::components::Fps>) -> Self {
        self.fps = try_serialize_field(Self::descriptor_fps(), [fps]);
        self
    }

    /// If the time is currently paused, playing, or following.
    ///
    /// Defaults to either playing or following, depending on the data source.
    #[inline]
    pub fn with_play_state(
        mut self,
        play_state: impl Into<crate::blueprint::components::PlayState>,
    ) -> Self {
        self.play_state = try_serialize_field(Self::descriptor_play_state(), [play_state]);
        self
    }

    /// How the time should loop. A selection loop only works if there is also a `time_selection` passed.
    ///
    /// Defaults to off.
    #[inline]
    pub fn with_loop_mode(
        mut self,
        loop_mode: impl Into<crate::blueprint::components::LoopMode>,
    ) -> Self {
        self.loop_mode = try_serialize_field(Self::descriptor_loop_mode(), [loop_mode]);
        self
    }

    /// Selects a range of time on the time panel.
    #[inline]
    pub fn with_time_selection(
        mut self,
        time_selection: impl Into<crate::blueprint::components::AbsoluteTimeRange>,
    ) -> Self {
        self.time_selection =
            try_serialize_field(Self::descriptor_time_selection(), [time_selection]);
        self
    }
}

impl ::re_byte_size::SizeBytes for TimePanelBlueprint {
    #[inline]
    fn heap_size_bytes(&self) -> u64 {
        self.state.heap_size_bytes()
            + self.timeline.heap_size_bytes()
            + self.time.heap_size_bytes()
            + self.playback_speed.heap_size_bytes()
            + self.fps.heap_size_bytes()
            + self.play_state.heap_size_bytes()
            + self.loop_mode.heap_size_bytes()
            + self.time_selection.heap_size_bytes()
    }
}
