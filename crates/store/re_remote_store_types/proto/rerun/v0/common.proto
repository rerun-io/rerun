syntax = "proto3";

package rerun.remote_store.v0;

// unique recording identifier. At this point in time it is the same id as the ChunkStore's StoreId
message RecordingId {
    string id = 1;
}

// A recording can have multiple timelines, each is identified by a name, for example `log_tick`, `log_time`, etc.
message Timeline {
    string name = 1;
}

// A time range between start and end time points. Each 64 bit number can represent different time point data
// depending on the timeline it is associated with.
message TimeRange {
    int64 start = 1;
    int64 end = 2;
}

// arrow IPC serialized schema
message Schema {
    bytes arrow_schema = 1;
}

message Query {
    // database view defined by entity paths and components
    ViewContents view_contents = 1;
    // define whethere the view_contents should include semantically empty columns
    bool include_semantically_empty_columns = 2;
    // define whether the view_contents should ignore columns corresponding to indicator components
    bool include_indicator_columns = 3;
    // define whether the view_contents should ignore columns corresponding to `Clear`-related components.
    bool include_tombstone_columns = 4;
    // filtering index (just a string i.e. a name of the timeline for starters)
    IndexColumnSelector filtered_index = 5;
    // Optional specific range for the index selector
    IndexRange filtered_index_range = 6;
    // Optional specific values for the index selector
    IndexValues filtered_index_values = 7;
    // Optional index selector sampling
    IndexValues using_index_values = 8;
    // PoV (filtering) component
    ComponentColumnSelector filtered_pov = 9;
    // which columns to include in the response
    // Note - we have one more layer of indiraction to ensure the field is optional,
    // same as in the query expression. We can't have both 'repeated' and 'optional' field labels.
    ColumnSelection column_selection = 10;
    // how are null values filled in the response
    SparseFillStrategy sparse_fill_strategy = 11;
}

message ColumnSelection {
    repeated ColumnSelector columns = 1;
}

message ColumnSelector {
    oneof selector_type {
        ComponentColumnSelector component_column = 2;
        TimeColumnSelector time_column = 3;
    }
}

message IndexColumnSelector {
    // TODO(zehiko) we need to add support for other types of index selectors
    Timeline timeline = 1;
}

message IndexRange {
    // TODO(zehiko) support for other ranges for other index selectors
    TimeRange time_range = 1;
}

message IndexValues {
    // TODO(zehiko) we need to add support for other types of index selectors
    repeated TimeInt time_points = 1;
}

message SampledIndexValues {
    repeated TimeInt sample_points = 1;
}

message TimeInt {
    int64 time = 1;
}

message ViewContents {
    repeated ViewContentsPart contents = 1;
}

message ViewContentsPart {
    EntityPath path = 1;
    ComponentsSet components = 2;
}

message ComponentsSet {
    repeated Component components = 1;
}

message EntityPath {
    string path = 1;
}

message Component {
    // component name needs to be a string as user can define their own component
    string name = 1;
}

message TimeColumnSelector {
    Timeline timeline = 1;
}

message ComponentColumnSelector {
    EntityPath entity_path = 1;
    Component component = 2;
}

enum SparseFillStrategy {
    NONE = 0;
    LATEST_AL_GLOBAL = 1;
}
