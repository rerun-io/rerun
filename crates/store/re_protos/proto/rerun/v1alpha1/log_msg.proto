syntax = "proto3";

package rerun.log_msg.v1alpha1;

import "rerun/v1alpha1/common.proto";

// There are 3 different `LogMsg`-related types that you will very often encounter: `re_log_types::LogMsg`,
// `re_protos::log_msg::v1alpha1::LogMsg` and `re_protos::log_msg::v1alpha1::log_msg::Msg`.
//
// Mixing them up is a common source of pain and confusion, so let's go over what each does:
// * `re_log_types::LogMsg` is the application-level type that we use all across the viewer
//   codebase. It can be obtained by calling `to_application()` on one of the transport-level
//   `LogMsg` types which, among many other things, will perform Chunk/Sorbet-level migrations.
//   `re_log_types::LogMsg` isn't used in Redap, where everything is done at the transport-level, always.
// * `re_protos::log_msg::v1alpha1::LogMsg` is the transport-level definition of `LogMsg`. It is an
//   artifact of how `oneof` works in Protobuf: all it does is carry a `re_protos::log_msg::v1alpha1::log_msg::Msg`.
//   For that reason, it is never directly used, except by the legacy SDK comms protocol.
// * Finally, `re_protos::log_msg::v1alpha1::log_msg::Msg` is the real transport-level type that we
//   care about. It is used all over the place when encoding and decoding RRD streams.
//
// TODO(#8631): Remove `LogMsg`
message LogMsg {
  oneof msg {
    // A message that contains a new store info.
    SetStoreInfo set_store_info = 1;

    // A message that contains an Arrow-IPC encoded message.
    ArrowMsg arrow_msg = 2;

    // A message that contains a blueprint activation command.
    BlueprintActivationCommand blueprint_activation_command = 3;
  }
}

// Corresponds to `LogMsg::SetStoreInfo`. Used to identify a recording.
message SetStoreInfo {
  // A time-based UID that is used to determine how a `StoreInfo` fits in the global ordering of events.
  rerun.common.v1alpha1.Tuid row_id = 1;

  // The new store info.
  StoreInfo info = 2;
}

// The encoding of the message payload.
enum Encoding {
  // We don't know what encoding the payload is in.
  ENCODING_UNSPECIFIED = 0;

  // The payload is encoded as Arrow-IPC.
  ENCODING_ARROW_IPC = 1;
}

// Corresponds to `LogMsg::ArrowMsg`. Used to transmit actual data.
message ArrowMsg {
  // The ID of the store that this message is for.
  rerun.common.v1alpha1.StoreId store_id = 1;

  // If the payload is a chunk, this is its ID. Otherwise empty.
  optional rerun.common.v1alpha1.Tuid chunk_id = 6;

  // Compression algorithm used.
  rerun.common.v1alpha1.Compression compression = 2;

  uint64 uncompressed_size = 3;

  // Encoding of the payload.
  Encoding encoding = 4;

  // Arrow-IPC encoded schema and chunk, compressed according to the `compression` field.
  bytes payload = 5;

  // If true, this is guaranteed to be a chunk containing only static data.
  optional bool is_static = 7;
}

// Corresponds to `LogMsg::BlueprintActivationCommand`.
//
// Used for activating a blueprint once it has been fully transmitted,
// because showing a blueprint before it is fully transmitted can lead to
// a confusing user experience, or inconsistent results due to heuristics.
message BlueprintActivationCommand {
  // The ID of the blueprint to activate.
  rerun.common.v1alpha1.StoreId blueprint_id = 1;

  // Whether to make the blueprint active immediately.
  bool make_active = 2;

  // Whether to make the blueprint the default.
  bool make_default = 3;
}

// Information about a recording or blueprint.
message StoreInfo {
  // User-chosen name of the application doing the logging.
  //
  // This is deprecated and kept for backward compatibility.
  //TODO(#10730): turn that into `reserved` statement when removing backward compatibility
  rerun.common.v1alpha1.ApplicationId application_id = 1 [deprecated = true];

  // Unique ID of the recording.
  rerun.common.v1alpha1.StoreId store_id = 2;

  reserved 3;
  reserved "is_official_example";

  reserved 4;
  reserved "started";

  // Where the recording came from.
  StoreSource store_source = 5;

  // Version of the store crate.
  StoreVersion store_version = 6;
}

// The source of a recording or blueprint.
message StoreSource {
  // Determines what is encoded in `extra`.
  StoreSourceKind kind = 1;

  // Store source payload. See `StoreSourceKind` for what exactly is encoded here.
  StoreSourceExtra extra = 2;
}

// A newtype for `StoreSource` payload.
//
// This exists to that we can implement conversions on the newtype for convenience.
message StoreSourceExtra {
  bytes payload = 1;
}

// What kind of source a recording comes from.
enum StoreSourceKind {
  // We don't know anything about the source of this recording.
  //
  // `extra` is unused.
  STORE_SOURCE_KIND_UNSPECIFIED = 0;

  // The recording came from the C++ SDK.
  //
  // `extra` is unused.
  STORE_SOURCE_KIND_C_SDK = 1;

  // The recording came from the Python SDK.
  //
  // `extra` is `PythonVersion`.
  STORE_SOURCE_KIND_PYTHON_SDK = 2;

  // The recording came from the Rust SDK.
  //
  // `extra` is `CrateInfo`.
  STORE_SOURCE_KIND_RUST_SDK = 3;

  // The recording came from a file.
  //
  // `extra` is `FileSource`.
  STORE_SOURCE_KIND_FILE = 4;

  // The recording came from some action in the viewer.
  //
  // `extra` is unused.
  STORE_SOURCE_KIND_VIEWER = 5;

  // The recording came from some other source.
  //
  // `extra` is a string.
  STORE_SOURCE_KIND_OTHER = 6;
}

// Version of the Python SDK that created the recording.
message PythonVersion {
  int32 major = 1;
  int32 minor = 2;
  int32 patch = 3;
  string suffix = 4;
}

// Information about the Rust SDK that created the recording.
message CrateInfo {
  // Version of the Rust compiler used to compile the SDK.
  string rustc_version = 1;

  // Version of LLVM used by the Rust compiler.
  string llvm_version = 2;
}

// A recording which came from a file.
message FileSource {
  FileSourceKind kind = 1;
}

// Determines where the file came from.
enum FileSourceKind {
  // We don't know where the file came from.
  FILE_SOURCE_KIND_UNSPECIFIED = 0;

  // The file came from the command line.
  FILE_SOURCE_KIND_CLI = 1;

  // The file was served over HTTP.
  FILE_SOURCE_KIND_URI = 2;

  // The file was dragged into the viewer.
  FILE_SOURCE_KIND_DRAG_AND_DROP = 3;

  // The file was opened using a file dialog.
  FILE_SOURCE_KIND_FILE_DIALOG = 4;

  // The recording was produced using a data loader, such as when logging a mesh file.
  FILE_SOURCE_KIND_SDK = 5;
}

message StoreVersion {
  // Crate version encoded using our custom scheme.
  //
  // See `CrateVersion` in `re_build_info`.
  int32 crate_version_bits = 1;
}

// This is the payload that is carried in messages of type `::End` in RRD streams.
//
// It keeps track of various useful information about the associated recording.
//
// During normal operations, there can only be a single `::End` message in an RRD stream, and
// therefore a single `RrdFooter`.
// It is possible to break that invariant by concatenating streams using external tools,
// e.g. by doing something like `cat *.rrd > all_my_recordings.rrd`.
// Passing that stream back through Rerun tools, e.g. `cat *.rrd | rerun rrd merge > all_my_recordings.rrd`,
// would once again guarantee that only one `::End` message is present though.
// I.e. that invariant holds as long as one stays within our ecosystem of tools.
//
// This is a transport-level type, the associated application-level type can be found
// in `re_log_encoding::RrdFooter`.
message RrdFooter {
  // All the `RrdManifest`s that were found in this RRD stream.
  //
  // Each `RrdManifest` corresponds to one, and exactly one, recording.
  //
  // The order is unspecified.
  repeated RrdManifest manifests = 1;
}

// This is the payload found in `RrdFooter`s.
//
// Each `RrdManifest` corresponds to one, and exactly one, RRD stream (i.e. recording).
// This restriction exists to make working with multiple RRD streams much simpler: due to the way
// the Rerun data model works, filtering rows of data from a manifest can have hard-to-predict
// second order effects on the schema of the stream as a whole.
// By keeping manifests for different recordings separate, we remove the need to filter per
// recording ID, greatly simplifying the process.
//
// This is a transport-level type, the associated application-level type can be found
// in `re_log_encoding::RrdManifest`.
message RrdManifest {
  // The recording ID that was used to identify the original recording.
  //
  // This is extracted from the `SetStoreInfo` message of the associated RRD stream.
  rerun.common.v1alpha1.StoreId store_id = 1;

  // The Sorbet schema of the associated RRD stream.
  //
  // ⚠️ This is the Sorbet schema of the recording being indexed by this manifest, *not* the
  // schema of `Self::manifest`.
  rerun.common.v1alpha1.Schema sorbet_schema = 2;

  // The SHA256 hash of the Sorbet schema of the associated RRD stream.
  //
  // This is always computed by sorting the fields of the schema by name first.
  optional bytes sorbet_schema_sha256 = 3;

  // The complete manifest for the associated RRD stream.
  //
  // Each row in this dataframe describes a unique chunk (ID, offset, size, timeline & component stats, etc).
  // This can be used to compute relevancy queries (latest-at, range, dataframe), without needing to load
  // any of the actual data in memory.
  rerun.common.v1alpha1.DataframePart data = 4;
}
