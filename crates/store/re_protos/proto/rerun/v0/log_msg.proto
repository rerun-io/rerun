syntax = "proto3";

package rerun.log_msg.v0;

import "rerun/v0/common.proto";

/*
// not actually protobuf
message MessageHeader {
    enum MessageKind {
        UNKNOWN_KIND = 0;
        ARROW_MSG = 1;
        SET_STORE_INFO = 2;
        BLUEPRINT_ACTIVATION_COMMAND = 3;
    }

    MessageKind kind = 1;

    // len-prefixed
    bytes payload = 1000;
}
*/

message SetStoreInfo {
    rerun.common.v0.Tuid row_id = 1;

    StoreInfo info = 2;
}

enum Compression {
    NONE = 0;
    LZ4 = 1;
}

enum Encoding {
    UNKNOWN = 0;
    ARROW_IPC = 1;
}

message ArrowMsg {
    rerun.common.v0.StoreId store_id = 1;
    Compression compression = 2;
    Encoding encoding = 3;

    // Arrow-IPC encoded schema and chunk,
    // compressed according to `compression`
    bytes payload = 1000;
}

message BlueprintActivationCommand {
    rerun.common.v0.StoreId blueprint_id = 1;
    bool make_active = 2;
    bool make_default = 3;
}

message StoreInfo {
    // User-chosen name of the application doing the logging.
    rerun.common.v0.ApplicationId application_id = 1;

    // Unique ID of the recording.
    rerun.common.v0.StoreId store_id = 2;

    /// True if the recording is one of the official Rerun examples.
    bool is_official_example = 3;

    // When the recording started.
    rerun.common.v0.Time started = 4;

    StoreSource store_source = 5;
}

message StoreSource {
    // Determines what is encoded in `extra`.
    StoreSourceKind kind = 1;
    StoreSourceExtra extra = 2;
}

enum StoreSourceKind {
    // `extra` is unused.
    UNKNOWN_KIND = 0;
    // `extra` is unused.
    C_SDK = 1;
    // `extra` is `PythonVersion`.
    PYTHON_SDK = 2;
    // `extra` is `CrateInfo`.
    RUST_SDK = 3;
    // `extra` is `FileSource`.
    FILE = 4;
    // `extra` is unused.
    VIEWER = 5;
    // `extra` is a string.
    OTHER = 6;
}

message StoreSourceExtra {
    bytes payload = 1;
}

message PythonVersion {
    // [u8; major, minor, patch, ..suffix]
    bytes version = 1;
}

message CrateInfo {
    string rustc_version = 1;
    string llvm_version = 2;
}

message FileSource {
    FileSourceKind kind = 1;
}

enum FileSourceKind {
    UNKNOWN_SOURCE = 0;
    CLI = 1;
    URI = 2;
    DRAG_AND_DROP = 3;
    FILE_DIALOG = 4;
    SDK = 5;
}

/*
pub struct StoreInfo {
    /// The user-chosen name of the application doing the logging.
    pub application_id: ApplicationId,

    /// Should be unique for each recording.
    pub store_id: StoreId,

    /// If this store is the result of a clone, which store was it cloned from?
    ///
    /// A cloned store always gets a new unique ID.
    ///
    /// We currently only clone stores for blueprints:
    /// when we receive a _default_ blueprints on the wire (e.g. from a recording),
    /// we clone it and make the clone the _active_ blueprint.
    /// This means all active blueprints are clones.
    pub cloned_from: Option<StoreId>,

    /// True if the recording is one of the official Rerun examples.
    pub is_official_example: bool,

    /// When the recording started.
    ///
    /// Should be an absolute time, i.e. relative to Unix Epoch.
    pub started: Time,

    pub store_source: StoreSource,

    /// The Rerun version used to encoded the RRD data.
    ///
    // NOTE: The version comes directly from the decoded RRD stream's header, duplicating it here
    // would probably only lead to more issues down the line.
    #[cfg_attr(feature = "serde", serde(skip))]
    pub store_version: Option<CrateVersion>,
}

pub enum StoreSource {
    Unknown,

    /// The official Rerun C Logging SDK
    CSdk,

    /// The official Rerun Python Logging SDK
    PythonSdk(PythonVersion),

    /// The official Rerun Rust Logging SDK
    RustSdk {
        /// Rust version of the code compiling the Rust SDK
        rustc_version: String,

        /// LLVM version of the code compiling the Rust SDK
        llvm_version: String,
    },

    /// Loading a file via CLI, drag-and-drop, a file-dialog, etc.
    File {
        file_source: FileSource,
    },

    /// Generated from the viewer itself.
    Viewer,

    /// Perhaps from some manual data ingestion?
    Other(String),
}
*/
