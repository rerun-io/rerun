// This file is @generated by prost-build.
/// unique recording identifier. At this point in time it is the same id as the ChunkStore's StoreId
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordingId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// A recording can have multiple timelines, each is identified by a name, for example `log_tick`, `log_time`, etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Timeline {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A time range between start and end time points. Each 64 bit number can represent different time point data
/// depending on the timeline it is associated with. Time range is inclusive for both start and end time points.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeRange {
    #[prost(int64, tag = "1")]
    pub start: i64,
    #[prost(int64, tag = "2")]
    pub end: i64,
}
/// arrow IPC serialized schema
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(bytes = "vec", tag = "1")]
    pub arrow_schema: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Query {
    /// The subset of the database that the query will run on: a set of EntityPath(s) and their
    /// associated Component(s)
    #[prost(message, optional, tag = "1")]
    pub view_contents: ::core::option::Option<ViewContents>,
    /// Whether the view_contents should ignore semantically empty columns
    /// A semantically empty column is a column that either contains no data at all, or where all
    /// values are either nulls or empty arrays (\[\]).
    #[prost(bool, tag = "2")]
    pub include_semantically_empty_columns: bool,
    /// Whether the view_contents should ignore columns corresponding to indicator components
    /// Indicator components are marker components, generally automatically inserted by Rerun, that
    /// helps keep track of the original context in which a piece of data was logged/sent.
    #[prost(bool, tag = "3")]
    pub include_indicator_columns: bool,
    /// Whether the view_contents should ignore columns corresponding to Clear-related components
    #[prost(bool, tag = "4")]
    pub include_tombstone_columns: bool,
    /// The index used to filter out _rows_ from the view contents.
    /// Only rows where at least 1 column contains non-null data at that index will be kept in the
    /// final dataset. If left unspecified, the results will only contain static data.
    #[prost(message, optional, tag = "5")]
    pub filtered_index: ::core::option::Option<IndexColumnSelector>,
    /// The range of index values used to filter out _rows_ from the view contents
    /// Only rows where at least 1 of the view-contents contains non-null data within that range will be kept in
    /// the final dataset.
    /// This has no effect if filtered_index isn't set.
    /// This has no effect if using_index_values is set.
    #[prost(message, optional, tag = "6")]
    pub filtered_index_range: ::core::option::Option<IndexRange>,
    /// The specific index values used to filter out _rows_ from the view contents.
    /// Only rows where at least 1 column contains non-null data at these specific values will be kept
    /// in the final dataset.
    /// This has no effect if filtered_index isn't set.
    /// This has no effect if using_index_values is set.
    #[prost(message, optional, tag = "7")]
    pub filtered_index_values: ::core::option::Option<IndexValues>,
    /// The specific index values used to sample _rows_ from the view contents.
    /// The final dataset will contain one row per sampled index value, regardless of whether data
    /// existed for that index value in the view contents.
    /// The semantics of the query are consistent with all other settings: the results will be
    /// sorted on the filtered_index, and only contain unique index values.
    ///
    /// This has no effect if filtered_index isn't set.
    /// If set, this overrides both filtered_index_range and filtered_index_values.
    #[prost(message, optional, tag = "8")]
    pub using_index_values: ::core::option::Option<IndexValues>,
    /// The component column used to filter out _rows_ from the view contents.
    /// Only rows where this column contains non-null data be kept in the final dataset.
    #[prost(message, optional, tag = "9")]
    pub filtered_is_not_null: ::core::option::Option<ComponentColumnSelector>,
    /// / The specific _columns_ to sample from the final view contents.
    /// / The order of the samples will be respected in the final result.
    /// /
    /// / If unspecified, it means - everything.
    #[prost(message, optional, tag = "10")]
    pub column_selection: ::core::option::Option<ColumnSelection>,
    /// Specifies how null values should be filled in the returned dataframe.
    #[prost(enumeration = "SparseFillStrategy", tag = "11")]
    pub sparse_fill_strategy: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnSelection {
    #[prost(message, repeated, tag = "1")]
    pub columns: ::prost::alloc::vec::Vec<ColumnSelector>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnSelector {
    #[prost(oneof = "column_selector::SelectorType", tags = "2, 3")]
    pub selector_type: ::core::option::Option<column_selector::SelectorType>,
}
/// Nested message and enum types in `ColumnSelector`.
pub mod column_selector {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SelectorType {
        #[prost(message, tag = "2")]
        ComponentColumn(super::ComponentColumnSelector),
        #[prost(message, tag = "3")]
        TimeColumn(super::TimeColumnSelector),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexColumnSelector {
    /// TODO(zehiko) we need to add support for other types of index selectors
    #[prost(message, optional, tag = "1")]
    pub timeline: ::core::option::Option<Timeline>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexRange {
    /// TODO(zehiko) support for other ranges for other index selectors
    #[prost(message, optional, tag = "1")]
    pub time_range: ::core::option::Option<TimeRange>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexValues {
    /// TODO(zehiko) we need to add support for other types of index selectors
    #[prost(message, repeated, tag = "1")]
    pub time_points: ::prost::alloc::vec::Vec<TimeInt>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SampledIndexValues {
    #[prost(message, repeated, tag = "1")]
    pub sample_points: ::prost::alloc::vec::Vec<TimeInt>,
}
/// A 64-bit number describing either nanoseconds, sequence numbers or fully static data.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeInt {
    #[prost(int64, tag = "1")]
    pub time: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewContents {
    #[prost(message, repeated, tag = "1")]
    pub contents: ::prost::alloc::vec::Vec<ViewContentsPart>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ViewContentsPart {
    #[prost(message, optional, tag = "1")]
    pub path: ::core::option::Option<EntityPath>,
    #[prost(message, optional, tag = "2")]
    pub components: ::core::option::Option<ComponentsSet>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComponentsSet {
    #[prost(message, repeated, tag = "1")]
    pub components: ::prost::alloc::vec::Vec<Component>,
}
/// The unique identifier of an entity, e.g. `camera/3/points`
/// See <<https://www.rerun.io/docs/concepts/entity-path>> for more on entity paths.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityPath {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
/// Component describes semantic data that can be used by any number of  rerun's archetypes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Component {
    /// component name needs to be a string as user can define their own component
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Used to telect a time column.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeColumnSelector {
    #[prost(message, optional, tag = "1")]
    pub timeline: ::core::option::Option<Timeline>,
}
/// Used to select a component based on its EntityPath and Component name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComponentColumnSelector {
    #[prost(message, optional, tag = "1")]
    pub entity_path: ::core::option::Option<EntityPath>,
    #[prost(message, optional, tag = "2")]
    pub component: ::core::option::Option<Component>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreId {
    #[prost(enumeration = "StoreKind", tag = "1")]
    pub kind: i32,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
/// A date-time represented as nanoseconds since unix epoch
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Time {
    #[prost(int64, tag = "1")]
    pub nanos_since_epoch: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Tuid {
    /// Approximate nanoseconds since epoch.
    #[prost(fixed64, tag = "1")]
    pub time_ns: u64,
    /// Initialized to something random on each thread,
    /// then incremented for each new `Tuid` being allocated.
    #[prost(fixed64, tag = "2")]
    pub inc: u64,
}
/// Specifies how null values should be filled in the returned dataframe.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SparseFillStrategy {
    None = 0,
    LatestAtGlobal = 1,
}
impl SparseFillStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::LatestAtGlobal => "LATEST_AT_GLOBAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "LATEST_AT_GLOBAL" => Some(Self::LatestAtGlobal),
            _ => None,
        }
    }
}
/// Error codes for application level errors
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCode {
    /// unused
    Unused = 0,
    /// object store access error
    ObjectStoreError = 1,
    /// metadata database access error
    MetadataDbError = 2,
}
impl ErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unused => "_UNUSED",
            Self::ObjectStoreError => "OBJECT_STORE_ERROR",
            Self::MetadataDbError => "METADATA_DB_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "_UNUSED" => Some(Self::Unused),
            "OBJECT_STORE_ERROR" => Some(Self::ObjectStoreError),
            "METADATA_DB_ERROR" => Some(Self::MetadataDbError),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StoreKind {
    Recording = 0,
    Blueprint = 1,
}
impl StoreKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Recording => "RECORDING",
            Self::Blueprint => "BLUEPRINT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECORDING" => Some(Self::Recording),
            "BLUEPRINT" => Some(Self::Blueprint),
            _ => None,
        }
    }
}
