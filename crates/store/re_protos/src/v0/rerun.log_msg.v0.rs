// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetStoreInfo {
    #[prost(message, optional, tag = "1")]
    pub row_id: ::core::option::Option<super::super::common::v0::Tuid>,
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<StoreInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrowMsg {
    #[prost(message, optional, tag = "1")]
    pub store_id: ::core::option::Option<super::super::common::v0::StoreId>,
    #[prost(enumeration = "Compression", tag = "2")]
    pub compression: i32,
    #[prost(enumeration = "Encoding", tag = "3")]
    pub encoding: i32,
    /// Arrow-IPC encoded schema and chunk,
    /// compressed according to `compression`
    #[prost(bytes = "vec", tag = "1000")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlueprintActivationCommand {
    #[prost(message, optional, tag = "1")]
    pub blueprint_id: ::core::option::Option<super::super::common::v0::StoreId>,
    #[prost(bool, tag = "2")]
    pub make_active: bool,
    #[prost(bool, tag = "3")]
    pub make_default: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreInfo {
    /// User-chosen name of the application doing the logging.
    #[prost(message, optional, tag = "1")]
    pub application_id: ::core::option::Option<super::super::common::v0::ApplicationId>,
    /// Unique ID of the recording.
    #[prost(message, optional, tag = "2")]
    pub store_id: ::core::option::Option<super::super::common::v0::StoreId>,
    /// / True if the recording is one of the official Rerun examples.
    #[prost(bool, tag = "3")]
    pub is_official_example: bool,
    /// When the recording started.
    #[prost(message, optional, tag = "4")]
    pub started: ::core::option::Option<super::super::common::v0::Time>,
    #[prost(message, optional, tag = "5")]
    pub store_source: ::core::option::Option<StoreSource>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreSource {
    /// Determines what is encoded in `extra`.
    #[prost(enumeration = "StoreSourceKind", tag = "1")]
    pub kind: i32,
    #[prost(message, optional, tag = "2")]
    pub extra: ::core::option::Option<StoreSourceExtra>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreSourceExtra {
    #[prost(bytes = "vec", tag = "1")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PythonVersion {
    /// \[u8; major, minor, patch, ..suffix\]
    #[prost(bytes = "vec", tag = "1")]
    pub version: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrateInfo {
    #[prost(string, tag = "1")]
    pub rustc_version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub llvm_version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FileSource {
    #[prost(enumeration = "FileSourceKind", tag = "1")]
    pub kind: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Compression {
    None = 0,
    Lz4 = 1,
}
impl Compression {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::Lz4 => "LZ4",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "LZ4" => Some(Self::Lz4),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Encoding {
    Unknown = 0,
    ArrowIpc = 1,
}
impl Encoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::ArrowIpc => "ARROW_IPC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "ARROW_IPC" => Some(Self::ArrowIpc),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StoreSourceKind {
    /// `extra` is unused.
    UnknownKind = 0,
    /// `extra` is unused.
    CSdk = 1,
    /// `extra` is `PythonVersion`.
    PythonSdk = 2,
    /// `extra` is `CrateInfo`.
    RustSdk = 3,
    /// `extra` is `FileSource`.
    File = 4,
    /// `extra` is unused.
    Viewer = 5,
    /// `extra` is a string.
    Other = 6,
}
impl StoreSourceKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownKind => "UNKNOWN_KIND",
            Self::CSdk => "C_SDK",
            Self::PythonSdk => "PYTHON_SDK",
            Self::RustSdk => "RUST_SDK",
            Self::File => "FILE",
            Self::Viewer => "VIEWER",
            Self::Other => "OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_KIND" => Some(Self::UnknownKind),
            "C_SDK" => Some(Self::CSdk),
            "PYTHON_SDK" => Some(Self::PythonSdk),
            "RUST_SDK" => Some(Self::RustSdk),
            "FILE" => Some(Self::File),
            "VIEWER" => Some(Self::Viewer),
            "OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FileSourceKind {
    UnknownSource = 0,
    Cli = 1,
    Uri = 2,
    DragAndDrop = 3,
    FileDialog = 4,
    Sdk = 5,
}
impl FileSourceKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownSource => "UNKNOWN_SOURCE",
            Self::Cli => "CLI",
            Self::Uri => "URI",
            Self::DragAndDrop => "DRAG_AND_DROP",
            Self::FileDialog => "FILE_DIALOG",
            Self::Sdk => "SDK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_SOURCE" => Some(Self::UnknownSource),
            "CLI" => Some(Self::Cli),
            "URI" => Some(Self::Uri),
            "DRAG_AND_DROP" => Some(Self::DragAndDrop),
            "FILE_DIALOG" => Some(Self::FileDialog),
            "SDK" => Some(Self::Sdk),
            _ => None,
        }
    }
}
