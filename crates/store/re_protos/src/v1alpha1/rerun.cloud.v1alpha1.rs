// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VersionRequest {}
impl ::prost::Name for VersionRequest {
    const NAME: &'static str = "VersionRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.VersionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.VersionRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VersionResponse {
    #[prost(message, optional, tag = "1")]
    pub build_info: ::core::option::Option<super::super::common::v1alpha1::BuildInfo>,
    /// A single version string representing the version of the whole stack.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for VersionResponse {
    const NAME: &'static str = "VersionResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.VersionResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.VersionResponse".into()
    }
}
/// Application level error - used as `details` in the `google.rpc.Status` message
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Error {
    /// error code
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub code: i32,
    /// unique identifier associated with the request (e.g. recording id, recording storage url)
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// human readable details about the error
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
impl ::prost::Name for Error {
    const NAME: &'static str = "Error";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.Error".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.Error".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DataSource {
    /// Where is the data for this data source stored (e.g. s3://bucket/file or file:///path/to/file)?
    #[prost(string, optional, tag = "1")]
    pub storage_url: ::core::option::Option<::prost::alloc::string::String>,
    /// / Which segment layer should this data source be registered to?
    /// /
    /// / Defaults to `base` if unspecified.
    #[prost(string, optional, tag = "3")]
    pub layer: ::core::option::Option<::prost::alloc::string::String>,
    /// / Is this a prefix URL (a directory)?
    /// / If true, all files of `typ` under this prefix will be
    /// / considered part of this data source.
    #[prost(bool, tag = "4")]
    pub prefix: bool,
    /// What kind of data is it (e.g. rrd, mcap, Lance, etc)?
    #[prost(enumeration = "DataSourceKind", tag = "2")]
    pub typ: i32,
}
impl ::prost::Name for DataSource {
    const NAME: &'static str = "DataSource";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DataSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DataSource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterWithDatasetRequest {
    #[prost(message, repeated, tag = "2")]
    pub data_sources: ::prost::alloc::vec::Vec<DataSource>,
    #[prost(
        enumeration = "super::super::common::v1alpha1::IfDuplicateBehavior",
        tag = "3"
    )]
    pub on_duplicate: i32,
}
impl ::prost::Name for RegisterWithDatasetRequest {
    const NAME: &'static str = "RegisterWithDatasetRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.RegisterWithDatasetRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.RegisterWithDatasetRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegisterWithDatasetResponse {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for RegisterWithDatasetResponse {
    const NAME: &'static str = "RegisterWithDatasetResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.RegisterWithDatasetResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.RegisterWithDatasetResponse".into()
    }
}
/// This request acts as a *product* filter:
/// * empty `segments_to_drop` + empty `layers_to_drop`: invalid argument error
/// * empty `segments_to_drop` + non-empty `layers_to_drop`: remove specified layers for *all* segments
/// * non-empty `segments_to_drop` + empty `layers_to_drop`: remove *all* layers for specified segments
/// * non-empty `segments_to_drop` + non-empty `layers_to_drop`: delete *all* specified layers for *all* specified segments
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterFromDatasetRequest {
    /// The segment IDs to drop. All of them if empty.
    ///
    /// The final filter will be the *outer product* of this and `layers_to_drop`.
    #[prost(message, repeated, tag = "1")]
    pub segments_to_drop: ::prost::alloc::vec::Vec<super::super::common::v1alpha1::SegmentId>,
    /// The layer names to drop. All of them if empty.
    ///
    /// The final filter will be the *outer product* of this and `segments_to_drop`.
    #[prost(string, repeated, tag = "2")]
    pub layers_to_drop: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If true, deletion will go through regardless of the segments/layers' current statuses.
    ///
    /// This is only useful in the very specific, catatrophic scenario where the contents of the
    /// task queue were lost and some tasks are now stuck in `status=pending` forever.
    ///
    /// Do not use this unless you know exactly what you're doing.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
impl ::prost::Name for UnregisterFromDatasetRequest {
    const NAME: &'static str = "UnregisterFromDatasetRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.UnregisterFromDatasetRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.UnregisterFromDatasetRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnregisterFromDatasetResponse {
    /// This contains all the information about the segments and layers that were actually removed.
    ///
    /// This dataframe is always guaranteed to be a subset of the one found in `ScanDatasetManifestResponse`.
    /// They share the same semantics, schemas, etc.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for UnregisterFromDatasetResponse {
    const NAME: &'static str = "UnregisterFromDatasetResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.UnregisterFromDatasetResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.UnregisterFromDatasetResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WriteChunksRequest {
    #[prost(message, optional, tag = "1")]
    pub chunk: ::core::option::Option<super::super::common::v1alpha1::RerunChunk>,
}
impl ::prost::Name for WriteChunksRequest {
    const NAME: &'static str = "WriteChunksRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.WriteChunksRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.WriteChunksRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WriteChunksResponse {}
impl ::prost::Name for WriteChunksResponse {
    const NAME: &'static str = "WriteChunksResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.WriteChunksResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.WriteChunksResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSegmentTableSchemaRequest {}
impl ::prost::Name for GetSegmentTableSchemaRequest {
    const NAME: &'static str = "GetSegmentTableSchemaRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.GetSegmentTableSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.GetSegmentTableSchemaRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSegmentTableSchemaResponse {
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<super::super::common::v1alpha1::Schema>,
}
impl ::prost::Name for GetSegmentTableSchemaResponse {
    const NAME: &'static str = "GetSegmentTableSchemaResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.GetSegmentTableSchemaResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.GetSegmentTableSchemaResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScanSegmentTableRequest {
    /// A list of column names to be projected server-side.
    ///
    /// If empty, all columns are returned.
    ///
    /// If not empty, the returned `RecordBatch` are guaranteed to only have the requested column, in the order they were
    /// requested.
    ///
    /// If a projected column does not exist, or is projected more than once, the `ScanSegmentTable` call will fail with
    /// an `InvalidArgument` error.
    #[prost(string, repeated, tag = "1")]
    pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for ScanSegmentTableRequest {
    const NAME: &'static str = "ScanSegmentTableRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ScanSegmentTableRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ScanSegmentTableRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScanSegmentTableResponse {
    /// Segments metadata as Arrow RecordBatch.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for ScanSegmentTableResponse {
    const NAME: &'static str = "ScanSegmentTableResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ScanSegmentTableResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ScanSegmentTableResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDatasetManifestSchemaRequest {}
impl ::prost::Name for GetDatasetManifestSchemaRequest {
    const NAME: &'static str = "GetDatasetManifestSchemaRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.GetDatasetManifestSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.GetDatasetManifestSchemaRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDatasetManifestSchemaResponse {
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<super::super::common::v1alpha1::Schema>,
}
impl ::prost::Name for GetDatasetManifestSchemaResponse {
    const NAME: &'static str = "GetDatasetManifestSchemaResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.GetDatasetManifestSchemaResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.GetDatasetManifestSchemaResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScanDatasetManifestRequest {
    /// A list of column names to be projected server-side.
    ///
    /// If empty, all columns are returned.
    ///
    /// If not empty, the returned `RecordBatch` are guaranteed to only have the requested column, in the order they were
    /// requested.
    ///
    /// If a projected column does not exist, or is projected more than once, the `ScanDatasetManifest` call will fail with
    /// an `InvalidArgument` error.
    #[prost(string, repeated, tag = "3")]
    pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for ScanDatasetManifestRequest {
    const NAME: &'static str = "ScanDatasetManifestRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ScanDatasetManifestRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ScanDatasetManifestRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScanDatasetManifestResponse {
    /// The contents of the dataset manifest (i.e. information about layers) as Arrow RecordBatch.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for ScanDatasetManifestResponse {
    const NAME: &'static str = "ScanDatasetManifestResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ScanDatasetManifestResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ScanDatasetManifestResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDatasetSchemaRequest {}
impl ::prost::Name for GetDatasetSchemaRequest {
    const NAME: &'static str = "GetDatasetSchemaRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.GetDatasetSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.GetDatasetSchemaRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDatasetSchemaResponse {
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<super::super::common::v1alpha1::Schema>,
}
impl ::prost::Name for GetDatasetSchemaResponse {
    const NAME: &'static str = "GetDatasetSchemaResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.GetDatasetSchemaResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.GetDatasetSchemaResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRrdManifestRequest {
    #[prost(message, optional, tag = "1")]
    pub segment_id: ::core::option::Option<super::super::common::v1alpha1::SegmentId>,
}
impl ::prost::Name for GetRrdManifestRequest {
    const NAME: &'static str = "GetRrdManifestRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.GetRrdManifestRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.GetRrdManifestRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRrdManifestResponse {
    #[prost(message, optional, tag = "1")]
    pub rrd_manifest: ::core::option::Option<super::super::log_msg::v1alpha1::RrdManifest>,
}
impl ::prost::Name for GetRrdManifestResponse {
    const NAME: &'static str = "GetRrdManifestResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.GetRrdManifestResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.GetRrdManifestResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateIndexRequest {
    #[prost(message, optional, tag = "3")]
    pub config: ::core::option::Option<IndexConfig>,
}
impl ::prost::Name for CreateIndexRequest {
    const NAME: &'static str = "CreateIndexRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.CreateIndexRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.CreateIndexRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateIndexResponse {
    /// The properties/configuration of the newly created index.
    #[prost(message, optional, tag = "3")]
    pub index: ::core::option::Option<IndexConfig>,
    /// Backend-specific statistics about the index.
    ///
    /// This is guaranteed to be valid JSON.
    #[prost(bytes = "bytes", tag = "4")]
    pub statistics_json: ::prost::bytes::Bytes,
    /// Optional debug information about the index-creation task
    #[prost(message, optional, tag = "2")]
    pub debug_info: ::core::option::Option<DebugInfo>,
}
impl ::prost::Name for CreateIndexResponse {
    const NAME: &'static str = "CreateIndexResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.CreateIndexResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.CreateIndexResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListIndexesRequest {}
impl ::prost::Name for ListIndexesRequest {
    const NAME: &'static str = "ListIndexesRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ListIndexesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ListIndexesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexesResponse {
    /// The respective properties/configuration of the indexes.
    #[prost(message, repeated, tag = "1")]
    pub indexes: ::prost::alloc::vec::Vec<IndexConfig>,
    /// Backend-specific statistics about the indexes.
    ///
    /// This is guaranteed to be valid JSON.
    ///
    /// If non-empty, this is the same length as `indexes`, and in the same order.
    #[prost(bytes = "bytes", repeated, tag = "2")]
    pub statistics_json: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
impl ::prost::Name for ListIndexesResponse {
    const NAME: &'static str = "ListIndexesResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ListIndexesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ListIndexesResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIndexesRequest {
    /// Which column to delete the indexes for.
    #[prost(message, optional, tag = "1")]
    pub column: ::core::option::Option<IndexColumn>,
}
impl ::prost::Name for DeleteIndexesRequest {
    const NAME: &'static str = "DeleteIndexesRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DeleteIndexesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DeleteIndexesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIndexesResponse {
    /// Which indexes were actually deleted.
    ///
    /// Can be empty if no matching indexes were found.
    #[prost(message, repeated, tag = "1")]
    pub indexes: ::prost::alloc::vec::Vec<IndexConfig>,
}
impl ::prost::Name for DeleteIndexesResponse {
    const NAME: &'static str = "DeleteIndexesResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DeleteIndexesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DeleteIndexesResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexConfig {
    /// what kind of index do we want to create and what are its index specific properties.
    #[prost(message, optional, tag = "1")]
    pub properties: ::core::option::Option<IndexProperties>,
    /// Component / column we want to index.
    #[prost(message, optional, tag = "2")]
    pub column: ::core::option::Option<IndexColumn>,
    /// What is the filter index i.e. timeline for which we will query the timepoints.
    ///
    /// TODO(zehiko) this might go away and we might just index across all the timelines
    #[prost(message, optional, tag = "3")]
    pub time_index: ::core::option::Option<super::super::common::v1alpha1::IndexColumnSelector>,
}
impl ::prost::Name for IndexConfig {
    const NAME: &'static str = "IndexConfig";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.IndexConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.IndexConfig".into()
    }
}
/// used to define which column we want to index
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexColumn {
    /// The path of the entity.
    #[prost(message, optional, tag = "1")]
    pub entity_path: ::core::option::Option<super::super::common::v1alpha1::EntityPath>,
    /// Component details
    #[prost(message, optional, tag = "2")]
    pub component: ::core::option::Option<super::super::common::v1alpha1::ComponentDescriptor>,
}
impl ::prost::Name for IndexColumn {
    const NAME: &'static str = "IndexColumn";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.IndexColumn".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.IndexColumn".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexProperties {
    #[prost(oneof = "index_properties::Props", tags = "1, 2, 3")]
    pub props: ::core::option::Option<index_properties::Props>,
}
/// Nested message and enum types in `IndexProperties`.
pub mod index_properties {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Props {
        #[prost(message, tag = "1")]
        Inverted(super::InvertedIndex),
        #[prost(message, tag = "2")]
        Vector(super::VectorIvfPqIndex),
        #[prost(message, tag = "3")]
        Btree(super::BTreeIndex),
    }
}
impl ::prost::Name for IndexProperties {
    const NAME: &'static str = "IndexProperties";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.IndexProperties".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.IndexProperties".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InvertedIndex {
    #[prost(bool, optional, tag = "1")]
    pub store_position: ::core::option::Option<bool>,
    /// TODO(zehiko) add other properties as needed
    #[prost(string, optional, tag = "2")]
    pub base_tokenizer: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for InvertedIndex {
    const NAME: &'static str = "InvertedIndex";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.InvertedIndex".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.InvertedIndex".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VectorIvfPqIndex {
    #[prost(uint32, optional, tag = "2")]
    pub num_sub_vectors: ::core::option::Option<u32>,
    #[prost(enumeration = "VectorDistanceMetric", tag = "3")]
    pub distance_metrics: i32,
    /// Target size of the IVF partition in rows.
    /// NOTE: "partition" here refers to Lance's IVF (Inverted File Index) partitions,
    /// not Rerun segments.
    ///
    /// This maps to lance's underlying `target_partition_size` property
    /// and it indirectly determines how many inverted indices (partitions)
    /// to build (the larger this value, the fewer partitions will be built):
    /// num_partitions = total_vectors / target_partition_num_rows
    ///
    /// A smaller number here will lead to more partitions, which can improve
    /// search recall at the cost of higher training time and memory usage.
    ///
    /// If missing, we let Lance will pick a default value, which, today, is
    /// 8192 rows per partition.
    ///
    /// Note that Lance will cap the maximum `num_partitions` to 4096:
    /// `num_partitions = min(4096, total_vectors / target_partition_num_rows)`
    /// So this means that setting this value too low will have no effect for
    /// large enough datasets.
    ///
    /// References:
    /// - \[<https://github.com/rerun-io/lance/blob/547bf3e288ff0bc13e96f29c7af46155fbd9f5c2/rust/lance/src/index/vector.rs#L336\]>
    /// - \[<https://github.com/rerun-io/lance/blob/a55c3afe250bcbe4d338c108ebe4a03d8a92697b/rust/lance-index/src/vector/ivf/builder.rs#L123\]>
    /// - \[<https://github.com/rerun-io/lance/blob/a55c3afe250bcbe4d338c108ebe4a03d8a92697b/rust/lance-index/src/lib.rs#L280\]>
    #[prost(uint32, optional, tag = "4")]
    pub target_partition_num_rows: ::core::option::Option<u32>,
}
impl ::prost::Name for VectorIvfPqIndex {
    const NAME: &'static str = "VectorIvfPqIndex";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.VectorIvfPqIndex".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.VectorIvfPqIndex".into()
    }
}
/// TODO(zehiko) add properties as needed
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BTreeIndex {}
impl ::prost::Name for BTreeIndex {
    const NAME: &'static str = "BTreeIndex";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.BTreeIndex".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.BTreeIndex".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDatasetRequest {
    /// Index column that is queried
    #[prost(message, optional, tag = "2")]
    pub column: ::core::option::Option<IndexColumn>,
    /// Query data - type of data is index specific. Caller must ensure
    /// to provide the right type. For vector search this should
    /// be a vector of appropriate size, for inverted index this should be a string.
    /// Query data is represented as a unit (single row) RecordBatch with 1 column.
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
    /// Index type specific properties
    #[prost(message, optional, tag = "4")]
    pub properties: ::core::option::Option<IndexQueryProperties>,
    /// Scan parameters
    #[prost(message, optional, tag = "5")]
    pub scan_parameters: ::core::option::Option<super::super::common::v1alpha1::ScanParameters>,
}
impl ::prost::Name for SearchDatasetRequest {
    const NAME: &'static str = "SearchDatasetRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.SearchDatasetRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.SearchDatasetRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SearchDatasetResponse {
    /// Chunks as arrow RecordBatch
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for SearchDatasetResponse {
    const NAME: &'static str = "SearchDatasetResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.SearchDatasetResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.SearchDatasetResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexQueryProperties {
    /// specific index query properties based on the index type
    #[prost(oneof = "index_query_properties::Props", tags = "1, 2, 3")]
    pub props: ::core::option::Option<index_query_properties::Props>,
}
/// Nested message and enum types in `IndexQueryProperties`.
pub mod index_query_properties {
    /// specific index query properties based on the index type
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Props {
        #[prost(message, tag = "1")]
        Inverted(super::InvertedIndexQuery),
        #[prost(message, tag = "2")]
        Vector(super::VectorIndexQuery),
        #[prost(message, tag = "3")]
        Btree(super::BTreeIndexQuery),
    }
}
impl ::prost::Name for IndexQueryProperties {
    const NAME: &'static str = "IndexQueryProperties";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.IndexQueryProperties".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.IndexQueryProperties".into()
    }
}
/// TODO(zehiko) add properties as needed
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InvertedIndexQuery {}
impl ::prost::Name for InvertedIndexQuery {
    const NAME: &'static str = "InvertedIndexQuery";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.InvertedIndexQuery".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.InvertedIndexQuery".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VectorIndexQuery {
    #[prost(uint32, optional, tag = "1")]
    pub top_k: ::core::option::Option<u32>,
}
impl ::prost::Name for VectorIndexQuery {
    const NAME: &'static str = "VectorIndexQuery";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.VectorIndexQuery".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.VectorIndexQuery".into()
    }
}
/// TODO(zehiko) add properties as needed
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BTreeIndexQuery {}
impl ::prost::Name for BTreeIndexQuery {
    const NAME: &'static str = "BTreeIndexQuery";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.BTreeIndexQuery".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.BTreeIndexQuery".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDatasetRequest {
    /// Client can specify what segments are queried. If left unspecified (empty list),
    /// all segments will be queried.
    #[prost(message, repeated, tag = "11")]
    pub segment_ids: ::prost::alloc::vec::Vec<super::super::common::v1alpha1::SegmentId>,
    /// Client can specify specific chunk ids to include. If left unspecified (empty list),
    /// all chunks that match other query parameters will be included.
    #[prost(message, repeated, tag = "3")]
    pub chunk_ids: ::prost::alloc::vec::Vec<super::super::common::v1alpha1::Tuid>,
    /// Which entity paths are we interested in? Leave empty, and set `select_all_entity_paths`,
    /// in order to query all of them.
    #[prost(message, repeated, tag = "4")]
    pub entity_paths: ::prost::alloc::vec::Vec<super::super::common::v1alpha1::EntityPath>,
    /// If set, the query will cover all existing entity paths.
    ///
    /// `entity_paths` must be empty, otherwise an error will be raised.
    ///
    /// Truth table:
    /// ```text
    /// select_all_entity_paths | entity_paths   | result
    /// ------------------------+----------------+--------
    /// false                   | \[\]             | valid query, empty results (no entity paths selected)
    /// false                   | \['foo', 'bar'\] | valid query, 'foo' & 'bar' selected
    /// true                    | \[\]             | valid query, all entity paths selected
    /// true                    | \['foo', 'bar'\] | invalid query, error
    /// ```
    #[prost(bool, tag = "7")]
    pub select_all_entity_paths: bool,
    /// Which components are we interested in?
    ///
    /// If left unspecified, all existing components are considered of interest.
    ///
    /// This will perform a basic fuzzy match on the available columns' descriptors.
    /// The fuzzy logic is a simple case-sensitive `contains()` query.
    /// For example, given a `log_tick__SeriesLines:width` index, all of the following
    /// would match: `SeriesLines:width`, `Width`, `SeriesLines`, etc.
    #[prost(string, repeated, tag = "10")]
    pub fuzzy_descriptors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If set, static data will be excluded from the results.
    #[prost(bool, tag = "8")]
    pub exclude_static_data: bool,
    /// If set, temporal data will be excluded from the results.
    #[prost(bool, tag = "9")]
    pub exclude_temporal_data: bool,
    /// Generic parameters that will influence the behavior of the Lance scanner.
    #[prost(message, optional, tag = "5")]
    pub scan_parameters: ::core::option::Option<super::super::common::v1alpha1::ScanParameters>,
    #[prost(message, optional, tag = "6")]
    pub query: ::core::option::Option<Query>,
}
impl ::prost::Name for QueryDatasetRequest {
    const NAME: &'static str = "QueryDatasetRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.QueryDatasetRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.QueryDatasetRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryDatasetResponse {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for QueryDatasetResponse {
    const NAME: &'static str = "QueryDatasetResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.QueryDatasetResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.QueryDatasetResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Query {
    /// If specified, will perform a latest-at query with the given parameters.
    ///
    /// You can combine this with a `QueryRange` in order to gather all the relevant chunks for
    /// a full-fledged dataframe query (i.e. they get OR'd together).
    #[prost(message, optional, tag = "1")]
    pub latest_at: ::core::option::Option<QueryLatestAt>,
    /// If specified, will perform a range query with the given parameters.
    ///
    /// You can combine this with a `QueryLatestAt` in order to gather all the relevant chunks for
    /// a full-fledged dataframe query (i.e. they get OR'd together).
    #[prost(message, optional, tag = "2")]
    pub range: ::core::option::Option<QueryRange>,
    /// If true, `columns` will contain the entire schema.
    #[prost(bool, tag = "3")]
    pub columns_always_include_everything: bool,
    /// If true, `columns` always includes `byte_offset` and `byte_size`.
    #[prost(bool, tag = "5")]
    pub columns_always_include_byte_offsets: bool,
    /// If true, `columns` always includes `entity_path`.
    #[prost(bool, tag = "6")]
    pub columns_always_include_entity_paths: bool,
    /// If true, `columns` always includes all static component-level indexes.
    #[prost(bool, tag = "7")]
    pub columns_always_include_static_indexes: bool,
    /// If true, `columns` always includes all temporal chunk-level indexes.
    #[prost(bool, tag = "8")]
    pub columns_always_include_global_indexes: bool,
    /// If true, `columns` always includes all component-level indexes.
    #[prost(bool, tag = "9")]
    pub columns_always_include_component_indexes: bool,
}
impl ::prost::Name for Query {
    const NAME: &'static str = "Query";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.Query".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.Query".into()
    }
}
/// A chunk-level latest-at query, aka `LatestAtRelevantChunks`.
///
/// This has the exact same semantics as the query of the same name on our `ChunkStore`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryLatestAt {
    /// Which index column should we perform the query on? E.g. `log_time`.
    ///
    /// Leave this empty to query for static data.
    #[prost(message, optional, tag = "1")]
    pub index: ::core::option::Option<super::super::common::v1alpha1::IndexColumnSelector>,
    /// What index value are we looking for?
    ///
    /// Leave this empty to query for static data.
    #[prost(int64, optional, tag = "2")]
    pub at: ::core::option::Option<i64>,
}
impl ::prost::Name for QueryLatestAt {
    const NAME: &'static str = "QueryLatestAt";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.QueryLatestAt".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.QueryLatestAt".into()
    }
}
/// / A chunk-level range query, aka `RangeRelevantChunks`.
///
/// This has the exact same semantics as the query of the same name on our `ChunkStore`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryRange {
    /// Which index column should we perform the query on? E.g. `log_time`.
    #[prost(message, optional, tag = "1")]
    pub index: ::core::option::Option<super::super::common::v1alpha1::IndexColumnSelector>,
    /// What index range are we looking for?
    #[prost(message, optional, tag = "2")]
    pub index_range: ::core::option::Option<super::super::common::v1alpha1::TimeRange>,
}
impl ::prost::Name for QueryRange {
    const NAME: &'static str = "QueryRange";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.QueryRange".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.QueryRange".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchChunksRequest {
    /// Information about the chunks to fetch. These dataframes have to include the following columns:
    /// * `chunk_id` - Chunk unique identifier
    /// * `segment_id` - segment this chunk belongs to. Currently needed as we pass this metadata back and forth
    /// * `segment_layer` - specific segment layer. Currently needed as we pass this metadata back and forth
    /// * `chunk_key` - chunk location details
    #[prost(message, repeated, tag = "1")]
    pub chunk_infos: ::prost::alloc::vec::Vec<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for FetchChunksRequest {
    const NAME: &'static str = "FetchChunksRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.FetchChunksRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.FetchChunksRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchChunksResponse {
    /// Every gRPC response, even within the confines of a stream, involves HTTP2 overhead, which isn't
    /// cheap by any means, which is why we're returning a batch of `ArrowMsg` rather than a single one.
    #[prost(message, repeated, tag = "1")]
    pub chunks: ::prost::alloc::vec::Vec<super::super::log_msg::v1alpha1::ArrowMsg>,
}
impl ::prost::Name for FetchChunksResponse {
    const NAME: &'static str = "FetchChunksResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.FetchChunksResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.FetchChunksResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTableSchemaRequest {
    #[prost(message, optional, tag = "1")]
    pub table_id: ::core::option::Option<super::super::common::v1alpha1::EntryId>,
}
impl ::prost::Name for GetTableSchemaRequest {
    const NAME: &'static str = "GetTableSchemaRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.GetTableSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.GetTableSchemaRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTableSchemaResponse {
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<super::super::common::v1alpha1::Schema>,
}
impl ::prost::Name for GetTableSchemaResponse {
    const NAME: &'static str = "GetTableSchemaResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.GetTableSchemaResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.GetTableSchemaResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScanTableRequest {
    /// TODO(jleibs): support ScanParameters iff we can plumb them into Datafusion TableProvider
    /// Otherwise, just wait for Arrow Flight
    /// rerun.common.v1alpha1.ScanParameters scan_parameters = 2;
    #[prost(message, optional, tag = "1")]
    pub table_id: ::core::option::Option<super::super::common::v1alpha1::EntryId>,
}
impl ::prost::Name for ScanTableRequest {
    const NAME: &'static str = "ScanTableRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ScanTableRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ScanTableRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScanTableResponse {
    #[prost(message, optional, tag = "1")]
    pub dataframe_part: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for ScanTableResponse {
    const NAME: &'static str = "ScanTableResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ScanTableResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ScanTableResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WriteTableRequest {
    #[prost(message, optional, tag = "1")]
    pub dataframe_part: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
    #[prost(enumeration = "TableInsertMode", tag = "2")]
    pub insert_mode: i32,
}
impl ::prost::Name for WriteTableRequest {
    const NAME: &'static str = "WriteTableRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.WriteTableRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.WriteTableRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WriteTableResponse {}
impl ::prost::Name for WriteTableResponse {
    const NAME: &'static str = "WriteTableResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.WriteTableResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.WriteTableResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DoMaintenanceRequest {
    /// Optimize all builtin and user-defined indexes on this dataset.
    ///
    /// This merges all individual index deltas back in the main index, improving runtime performance
    /// of all indexes.
    #[prost(bool, tag = "2")]
    pub optimize_indexes: bool,
    /// Retrain all user-defined indexes on this dataset from scratch.
    ///
    /// This retrains all user-defined indexes from scratch for optimal runtime performance.
    /// This is faster than re-creating the indexes, and automatically keeps track of their configurations.
    ///
    /// This implies `optimize_indexes`.
    #[prost(bool, tag = "6")]
    pub retrain_indexes: bool,
    /// Compact the underlying Lance fragments, for all Rerun Manifests.
    ///
    /// Hardcoded to the default (optimal) settings.
    #[prost(bool, tag = "3")]
    pub compact_fragments: bool,
    /// If set, all Lance fragments older than this date will be removed, for all Rerun Manifests.
    ///
    /// In case requested date is more recent than 1 hour, it will be ignored and 1 hour ago
    /// timestamp will be used. This is to prevent still used files (like recent transaction files)
    /// to be removed and cause Lance Dataset update issues.
    ///
    /// See <https://docs.rs/lance/latest/lance/dataset/cleanup/index.html>
    /// and <https://docs.rs/lance/latest/lance/dataset/cleanup/fn.cleanup_old_versions.html>
    #[prost(message, optional, tag = "4")]
    pub cleanup_before: ::core::option::Option<::prost_types::Timestamp>,
    /// Override default platform behavior and allow cleanup of recent files. This will respect
    /// the value of `cleanup_before` timestamp even if it's more recent than 1 hour.
    ///
    /// ⚠️ Do not ever use this unless you know exactly what you're doing. Improper use will lead to data loss.
    #[prost(bool, tag = "5")]
    pub unsafe_allow_recent_cleanup: bool,
}
impl ::prost::Name for DoMaintenanceRequest {
    const NAME: &'static str = "DoMaintenanceRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DoMaintenanceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DoMaintenanceRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DoMaintenanceResponse {
    #[prost(string, tag = "1")]
    pub report: ::prost::alloc::string::String,
}
impl ::prost::Name for DoMaintenanceResponse {
    const NAME: &'static str = "DoMaintenanceResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DoMaintenanceResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DoMaintenanceResponse".into()
    }
}
/// Request all maintenance operations to run on all datasets
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DoGlobalMaintenanceRequest {}
impl ::prost::Name for DoGlobalMaintenanceRequest {
    const NAME: &'static str = "DoGlobalMaintenanceRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DoGlobalMaintenanceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DoGlobalMaintenanceRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DoGlobalMaintenanceResponse {}
impl ::prost::Name for DoGlobalMaintenanceResponse {
    const NAME: &'static str = "DoGlobalMaintenanceResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DoGlobalMaintenanceResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DoGlobalMaintenanceResponse".into()
    }
}
/// `QueryTasksRequest` is the request message for querying tasks status
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTasksRequest {
    /// Empty queries for all tasks if the server allows it.
    #[prost(message, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<super::super::common::v1alpha1::TaskId>,
}
impl ::prost::Name for QueryTasksRequest {
    const NAME: &'static str = "QueryTasksRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.QueryTasksRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.QueryTasksRequest".into()
    }
}
/// `QueryTasksResponse` is the response message for querying tasks status
/// encoded as a record batch
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryTasksResponse {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for QueryTasksResponse {
    const NAME: &'static str = "QueryTasksResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.QueryTasksResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.QueryTasksResponse".into()
    }
}
/// `QueryTasksOnCompletionRequest` is the request message for querying tasks status.
/// This is close-to-a-copy of `QueryTasksRequest`, with the addition of a timeout.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTasksOnCompletionRequest {
    /// Empty queries for all tasks if the server allows it.
    #[prost(message, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<super::super::common::v1alpha1::TaskId>,
    /// Time limit for the server to wait for task completion.
    /// The actual maximum time may be arbitrarily capped by the server.
    #[prost(message, optional, tag = "2")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
}
impl ::prost::Name for QueryTasksOnCompletionRequest {
    const NAME: &'static str = "QueryTasksOnCompletionRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.QueryTasksOnCompletionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.QueryTasksOnCompletionRequest".into()
    }
}
/// `QueryTaskOnCompletionResponse` is the response message for querying tasks status
/// encoded as a record batch. This is a copy of `QueryTasksResponse`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryTasksOnCompletionResponse {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for QueryTasksOnCompletionResponse {
    const NAME: &'static str = "QueryTasksOnCompletionResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.QueryTasksOnCompletionResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.QueryTasksOnCompletionResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FindEntriesRequest {
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<EntryFilter>,
}
impl ::prost::Name for FindEntriesRequest {
    const NAME: &'static str = "FindEntriesRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.FindEntriesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.FindEntriesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindEntriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<EntryDetails>,
}
impl ::prost::Name for FindEntriesResponse {
    const NAME: &'static str = "FindEntriesResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.FindEntriesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.FindEntriesResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteEntryRequest {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::v1alpha1::EntryId>,
}
impl ::prost::Name for DeleteEntryRequest {
    const NAME: &'static str = "DeleteEntryRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DeleteEntryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DeleteEntryRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteEntryResponse {}
impl ::prost::Name for DeleteEntryResponse {
    const NAME: &'static str = "DeleteEntryResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DeleteEntryResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DeleteEntryResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateEntryRequest {
    /// The entry to modify.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::v1alpha1::EntryId>,
    /// The new values for updatable fields.
    #[prost(message, optional, tag = "2")]
    pub entry_details_update: ::core::option::Option<EntryDetailsUpdate>,
}
impl ::prost::Name for UpdateEntryRequest {
    const NAME: &'static str = "UpdateEntryRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.UpdateEntryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.UpdateEntryRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateEntryResponse {
    /// The updated entry details
    #[prost(message, optional, tag = "1")]
    pub entry_details: ::core::option::Option<EntryDetails>,
}
impl ::prost::Name for UpdateEntryResponse {
    const NAME: &'static str = "UpdateEntryResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.UpdateEntryResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.UpdateEntryResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateDatasetEntryRequest {
    /// Name of the dataset entry to create.
    ///
    /// The name should be a short human-readable string. It must be unique within all entries in the catalog. If an entry
    /// with the same name already exists, the request will fail. Entry names ending with `__manifest` are reserved.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// If specified, create the entry using this specific ID. Use at your own risk.
    #[prost(message, optional, tag = "2")]
    pub id: ::core::option::Option<super::super::common::v1alpha1::EntryId>,
}
impl ::prost::Name for CreateDatasetEntryRequest {
    const NAME: &'static str = "CreateDatasetEntryRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.CreateDatasetEntryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.CreateDatasetEntryRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateDatasetEntryResponse {
    #[prost(message, optional, tag = "1")]
    pub dataset: ::core::option::Option<DatasetEntry>,
}
impl ::prost::Name for CreateDatasetEntryResponse {
    const NAME: &'static str = "CreateDatasetEntryResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.CreateDatasetEntryResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.CreateDatasetEntryResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateTableEntryRequest {
    /// Name of the dataset entry to create.
    ///
    /// The name should be a short human-readable string. It must be unique within all entries in the catalog. If an entry
    /// with the same name already exists, the request will fail. Entry names ending with `__manifest` are reserved.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Information about the table to register.
    ///
    /// This must be encoded message of one of the following supported types:
    /// - LanceTable
    #[prost(message, optional, tag = "2")]
    pub provider_details: ::core::option::Option<::prost_types::Any>,
    /// Schema of the table to create
    #[prost(message, optional, tag = "3")]
    pub schema: ::core::option::Option<super::super::common::v1alpha1::Schema>,
}
impl ::prost::Name for CreateTableEntryRequest {
    const NAME: &'static str = "CreateTableEntryRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.CreateTableEntryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.CreateTableEntryRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateTableEntryResponse {
    #[prost(message, optional, tag = "1")]
    pub table: ::core::option::Option<TableEntry>,
}
impl ::prost::Name for CreateTableEntryResponse {
    const NAME: &'static str = "CreateTableEntryResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.CreateTableEntryResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.CreateTableEntryResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadDatasetEntryRequest {}
impl ::prost::Name for ReadDatasetEntryRequest {
    const NAME: &'static str = "ReadDatasetEntryRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ReadDatasetEntryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ReadDatasetEntryRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadDatasetEntryResponse {
    #[prost(message, optional, tag = "1")]
    pub dataset: ::core::option::Option<DatasetEntry>,
}
impl ::prost::Name for ReadDatasetEntryResponse {
    const NAME: &'static str = "ReadDatasetEntryResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ReadDatasetEntryResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ReadDatasetEntryResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateDatasetEntryRequest {
    /// The dataset to modify.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::v1alpha1::EntryId>,
    /// The new values.
    #[prost(message, optional, tag = "2")]
    pub dataset_details: ::core::option::Option<DatasetDetails>,
}
impl ::prost::Name for UpdateDatasetEntryRequest {
    const NAME: &'static str = "UpdateDatasetEntryRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.UpdateDatasetEntryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.UpdateDatasetEntryRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateDatasetEntryResponse {
    /// The updated dataset entry
    #[prost(message, optional, tag = "1")]
    pub dataset: ::core::option::Option<DatasetEntry>,
}
impl ::prost::Name for UpdateDatasetEntryResponse {
    const NAME: &'static str = "UpdateDatasetEntryResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.UpdateDatasetEntryResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.UpdateDatasetEntryResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegisterTableRequest {
    /// Name of the table entry to create.
    ///
    /// The name should be a short human-readable string. It must be unique within all entries in the catalog. If an entry
    /// with the same name already exists, the request will fail. Entry names ending with `__manifest` are reserved.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Information about the table to register.
    ///
    /// This must be encoded message of one one of the following supported types:
    /// - LanceTable
    #[prost(message, optional, tag = "2")]
    pub provider_details: ::core::option::Option<::prost_types::Any>,
}
impl ::prost::Name for RegisterTableRequest {
    const NAME: &'static str = "RegisterTableRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.RegisterTableRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.RegisterTableRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegisterTableResponse {
    /// Details about the table that was created and registered.
    #[prost(message, optional, tag = "1")]
    pub table_entry: ::core::option::Option<TableEntry>,
}
impl ::prost::Name for RegisterTableResponse {
    const NAME: &'static str = "RegisterTableResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.RegisterTableResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.RegisterTableResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadTableEntryRequest {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::v1alpha1::EntryId>,
}
impl ::prost::Name for ReadTableEntryRequest {
    const NAME: &'static str = "ReadTableEntryRequest";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ReadTableEntryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ReadTableEntryRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadTableEntryResponse {
    #[prost(message, optional, tag = "1")]
    pub table: ::core::option::Option<TableEntry>,
}
impl ::prost::Name for ReadTableEntryResponse {
    const NAME: &'static str = "ReadTableEntryResponse";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.ReadTableEntryResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.ReadTableEntryResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EntryFilter {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::v1alpha1::EntryId>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "EntryKind", optional, tag = "3")]
    pub entry_kind: ::core::option::Option<i32>,
}
impl ::prost::Name for EntryFilter {
    const NAME: &'static str = "EntryFilter";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.EntryFilter".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.EntryFilter".into()
    }
}
/// Minimal info about an Entry for high-level catalog summary
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EntryDetails {
    /// The EntryId is immutable
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::common::v1alpha1::EntryId>,
    /// The name of this entry.
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The kind of entry
    #[prost(enumeration = "EntryKind", tag = "3")]
    pub entry_kind: i32,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for EntryDetails {
    const NAME: &'static str = "EntryDetails";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.EntryDetails".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.EntryDetails".into()
    }
}
/// Updatable fields of an Entry
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EntryDetailsUpdate {
    /// The name of this entry.
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for EntryDetailsUpdate {
    const NAME: &'static str = "EntryDetailsUpdate";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.EntryDetailsUpdate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.EntryDetailsUpdate".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatasetDetails {
    /// The blueprint dataset associated with this dataset (if any).
    #[prost(message, optional, tag = "3")]
    pub blueprint_dataset: ::core::option::Option<super::super::common::v1alpha1::EntryId>,
    /// The segment of the blueprint dataset corresponding to the default blueprint (if any).
    #[prost(message, optional, tag = "5")]
    pub default_blueprint_segment:
        ::core::option::Option<super::super::common::v1alpha1::SegmentId>,
}
impl ::prost::Name for DatasetDetails {
    const NAME: &'static str = "DatasetDetails";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DatasetDetails".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DatasetDetails".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatasetEntry {
    #[prost(message, optional, tag = "1")]
    pub details: ::core::option::Option<EntryDetails>,
    /// Dataset-specific information, may be update with `UpdateDatasetEntry`
    #[prost(message, optional, tag = "4")]
    pub dataset_details: ::core::option::Option<DatasetDetails>,
    /// Read-only
    #[prost(message, optional, tag = "2")]
    pub dataset_handle: ::core::option::Option<super::super::common::v1alpha1::DatasetHandle>,
}
impl ::prost::Name for DatasetEntry {
    const NAME: &'static str = "DatasetEntry";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DatasetEntry".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DatasetEntry".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TableEntry {
    #[prost(message, optional, tag = "1")]
    pub details: ::core::option::Option<EntryDetails>,
    /// Details specific to the table-provider
    #[prost(message, optional, tag = "3")]
    pub provider_details: ::core::option::Option<::prost_types::Any>,
}
impl ::prost::Name for TableEntry {
    const NAME: &'static str = "TableEntry";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.TableEntry".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.TableEntry".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SystemTable {
    #[prost(enumeration = "SystemTableKind", tag = "1")]
    pub kind: i32,
}
impl ::prost::Name for SystemTable {
    const NAME: &'static str = "SystemTable";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.SystemTable".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.SystemTable".into()
    }
}
/// A foreign table stored as a Lance table.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LanceTable {
    /// The URL of the Lance table.
    #[prost(string, tag = "1")]
    pub table_url: ::prost::alloc::string::String,
}
impl ::prost::Name for LanceTable {
    const NAME: &'static str = "LanceTable";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.LanceTable".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.LanceTable".into()
    }
}
/// Optional debug info
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DebugInfo {
    /// The amount of memory used by the task or service call in bytes
    #[prost(uint64, optional, tag = "1")]
    pub memory_used: ::core::option::Option<u64>,
}
impl ::prost::Name for DebugInfo {
    const NAME: &'static str = "DebugInfo";
    const PACKAGE: &'static str = "rerun.cloud.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.cloud.v1alpha1.DebugInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.cloud.v1alpha1.DebugInfo".into()
    }
}
/// Error codes for application level errors
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCode {
    /// unused
    Unspecified = 0,
    /// object store access error
    ObjectStoreError = 1,
    /// metadata database access error
    MetadataDbError = 2,
    /// Encoding / decoding error
    CodecError = 3,
}
impl ErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ERROR_CODE_UNSPECIFIED",
            Self::ObjectStoreError => "ERROR_CODE_OBJECT_STORE_ERROR",
            Self::MetadataDbError => "ERROR_CODE_METADATA_DB_ERROR",
            Self::CodecError => "ERROR_CODE_CODEC_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_CODE_OBJECT_STORE_ERROR" => Some(Self::ObjectStoreError),
            "ERROR_CODE_METADATA_DB_ERROR" => Some(Self::MetadataDbError),
            "ERROR_CODE_CODEC_ERROR" => Some(Self::CodecError),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataSourceKind {
    Unspecified = 0,
    Rrd = 1,
}
impl DataSourceKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATA_SOURCE_KIND_UNSPECIFIED",
            Self::Rrd => "DATA_SOURCE_KIND_RRD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_SOURCE_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "DATA_SOURCE_KIND_RRD" => Some(Self::Rrd),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum VectorDistanceMetric {
    Unspecified = 0,
    L2 = 1,
    Cosine = 2,
    Dot = 3,
    Hamming = 4,
}
impl VectorDistanceMetric {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VECTOR_DISTANCE_METRIC_UNSPECIFIED",
            Self::L2 => "VECTOR_DISTANCE_METRIC_L2",
            Self::Cosine => "VECTOR_DISTANCE_METRIC_COSINE",
            Self::Dot => "VECTOR_DISTANCE_METRIC_DOT",
            Self::Hamming => "VECTOR_DISTANCE_METRIC_HAMMING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VECTOR_DISTANCE_METRIC_UNSPECIFIED" => Some(Self::Unspecified),
            "VECTOR_DISTANCE_METRIC_L2" => Some(Self::L2),
            "VECTOR_DISTANCE_METRIC_COSINE" => Some(Self::Cosine),
            "VECTOR_DISTANCE_METRIC_DOT" => Some(Self::Dot),
            "VECTOR_DISTANCE_METRIC_HAMMING" => Some(Self::Hamming),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TableInsertMode {
    /// Always reserve unspecified as default value
    Unspecified = 0,
    /// Appends new rows to the existing table without modifying any existing rows.
    Append = 1,
    /// Overwrites all existing rows in the table with the new rows.
    Overwrite = 2,
    /// Overwrite rows based on the rerun_table_index fields.
    Replace = 3,
}
impl TableInsertMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TABLE_INSERT_MODE_UNSPECIFIED",
            Self::Append => "TABLE_INSERT_MODE_APPEND",
            Self::Overwrite => "TABLE_INSERT_MODE_OVERWRITE",
            Self::Replace => "TABLE_INSERT_MODE_REPLACE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TABLE_INSERT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "TABLE_INSERT_MODE_APPEND" => Some(Self::Append),
            "TABLE_INSERT_MODE_OVERWRITE" => Some(Self::Overwrite),
            "TABLE_INSERT_MODE_REPLACE" => Some(Self::Replace),
            _ => None,
        }
    }
}
/// What type of entry. This has strong implication on which APIs are available for this entry.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EntryKind {
    /// Always reserve unspecified as default value
    Unspecified = 0,
    /// Order as TYPE, TYPE_VIEW so things stay consistent as we introduce new types.
    Dataset = 1,
    DatasetView = 2,
    Table = 3,
    TableView = 4,
    BlueprintDataset = 5,
}
impl EntryKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENTRY_KIND_UNSPECIFIED",
            Self::Dataset => "ENTRY_KIND_DATASET",
            Self::DatasetView => "ENTRY_KIND_DATASET_VIEW",
            Self::Table => "ENTRY_KIND_TABLE",
            Self::TableView => "ENTRY_KIND_TABLE_VIEW",
            Self::BlueprintDataset => "ENTRY_KIND_BLUEPRINT_DATASET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTRY_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "ENTRY_KIND_DATASET" => Some(Self::Dataset),
            "ENTRY_KIND_DATASET_VIEW" => Some(Self::DatasetView),
            "ENTRY_KIND_TABLE" => Some(Self::Table),
            "ENTRY_KIND_TABLE_VIEW" => Some(Self::TableView),
            "ENTRY_KIND_BLUEPRINT_DATASET" => Some(Self::BlueprintDataset),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SystemTableKind {
    /// Always reserve unspecified as default value
    Unspecified = 0,
    /// Not used yet
    Namespaces = 1,
    /// All of the entries in the associated namespace
    Entries = 2,
}
impl SystemTableKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SYSTEM_TABLE_KIND_UNSPECIFIED",
            Self::Namespaces => "SYSTEM_TABLE_KIND_NAMESPACES",
            Self::Entries => "SYSTEM_TABLE_KIND_ENTRIES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SYSTEM_TABLE_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "SYSTEM_TABLE_KIND_NAMESPACES" => Some(Self::Namespaces),
            "SYSTEM_TABLE_KIND_ENTRIES" => Some(Self::Entries),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod rerun_cloud_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The Rerun Cloud public API.
    ///
    /// ## Headers
    ///
    /// Most endpoints in the Rerun Cloud service require specific gRPC headers to be set.
    ///
    /// The so-called "standard dataset headers" correspond to at least one of the following headers:
    /// * x-rerun-entry-id: ID of the entry of interest, e.g. `1860390B087BC65F602d68eb646c385c`.
    /// * x-rerun-entry-name-bin: Name of the entry of interest, e.g. `droid:sample2k`.
    ///
    /// Headers with a -bin suffix must be base64-encoded (HTTP only supports ASCII values, UTF8 strings must
    /// binary encoded).
    #[derive(Debug, Clone)]
    pub struct RerunCloudServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RerunCloudServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RerunCloudServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::Body>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RerunCloudServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn version(
            &mut self,
            request: impl tonic::IntoRequest<super::VersionRequest>,
        ) -> std::result::Result<tonic::Response<super::VersionResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/Version",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "Version",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_entries(
            &mut self,
            request: impl tonic::IntoRequest<super::FindEntriesRequest>,
        ) -> std::result::Result<tonic::Response<super::FindEntriesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/FindEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "FindEntries",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteEntryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/DeleteEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "DeleteEntry",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateEntryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/UpdateEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "UpdateEntry",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_dataset_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDatasetEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateDatasetEntryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/CreateDatasetEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "CreateDatasetEntry",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_table_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTableEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateTableEntryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/CreateTableEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "CreateTableEntry",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Fetch metadata about a specific dataset.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn read_dataset_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadDatasetEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadDatasetEntryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/ReadDatasetEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "ReadDatasetEntry",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_dataset_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDatasetEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateDatasetEntryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/UpdateDatasetEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "UpdateDatasetEntry",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn read_table_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadTableEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadTableEntryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/ReadTableEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "ReadTableEntry",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Register new segments with the Dataset.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn register_with_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterWithDatasetRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterWithDatasetResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/RegisterWithDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "RegisterWithDataset",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Unregisters segments and layers from the Dataset.
        ///
        /// Excluding IO errors, this will always succeed as long the target dataset exists.
        /// Corollary: unregistering data that doesn't exist is a no-op.
        ///
        /// This always returns a subset of the data from `ScanDatasetManifest`, and therefore the data will
        /// also follow the schema returned by `GetDatasetManifestSchema`.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn unregister_from_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::UnregisterFromDatasetRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::UnregisterFromDatasetResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/UnregisterFromDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "UnregisterFromDataset",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Write chunks to one or more segments.
        ///
        /// The segment ID for each individual chunk is extracted from their metadata (`rerun:segment_id`).
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn write_chunks(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::WriteChunksRequest>,
        ) -> std::result::Result<tonic::Response<super::WriteChunksResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/WriteChunks",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "WriteChunks",
            ));
            self.inner.client_streaming(req, path, codec).await
        }
        /// Returns the schema of the segment table.
        ///
        /// This is not to be confused with the schema of the dataset itself. For that, refer to `GetDatasetSchema`.
        ///
        /// To inspect the data of the segment table, which is guaranteed to match the schema returned by
        /// this endpoint, check out `ScanSegmentTable`.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn get_segment_table_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSegmentTableSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSegmentTableSchemaResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/GetSegmentTableSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "GetSegmentTableSchema",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Inspect the contents of the segment table.
        ///
        /// The data will follow the schema returned by `GetSegmentTableSchema`.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn scan_segment_table(
            &mut self,
            request: impl tonic::IntoRequest<super::ScanSegmentTableRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ScanSegmentTableResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/ScanSegmentTable",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "ScanSegmentTable",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Returns the schema of the dataset manifest.
        ///
        /// To inspect the data of the dataset manifest, which is guaranteed to match the schema returned by
        /// this endpoint, check out `ScanDatasetManifest`.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn get_dataset_manifest_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDatasetManifestSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDatasetManifestSchemaResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/GetDatasetManifestSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "GetDatasetManifestSchema",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Inspect the contents of the dataset manifest.
        ///
        /// The data will follow the schema returned by `GetDatasetManifestSchema`.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn scan_dataset_manifest(
            &mut self,
            request: impl tonic::IntoRequest<super::ScanDatasetManifestRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ScanDatasetManifestResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/ScanDatasetManifest",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "ScanDatasetManifest",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Returns the schema of the dataset.
        ///
        /// This is the union of all the schemas from all the underlying segments. It will contain all the indexes,
        /// entities and components present in the dataset.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn get_dataset_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDatasetSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::GetDatasetSchemaResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/GetDatasetSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "GetDatasetSchema",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get the RRD Footer manifest.
        ///
        /// This includes details about what chunks there are, and what kind of data they contain.
        pub async fn get_rrd_manifest(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRrdManifestRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetRrdManifestResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/GetRrdManifest",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "GetRrdManifest",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Creates a custom index for a specific column (vector search, full-text search, etc).
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn create_index(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIndexRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateIndexResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/CreateIndex",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "CreateIndex",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// List all user-defined indexes in this dataset.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn list_indexes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIndexesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListIndexesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/ListIndexes",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "ListIndexes",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a custom index for a specific column.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn delete_indexes(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIndexesRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteIndexesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/DeleteIndexes",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "DeleteIndexes",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Search a previously created index.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn search_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchDatasetRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SearchDatasetResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/SearchDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "SearchDataset",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Perform Rerun-native queries on a dataset, returning the matching chunk IDs, as well
        /// as information that can be sent back to Rerun Cloud to fetch the actual chunks as part
        /// of `FetchChunks` request. In this 2-step query process, 1st step is getting information
        /// from the server about the chunks that contain relevant information. 2nd step is fetching
        /// those chunks (the actual data).
        ///
        /// These Rerun-native queries include:
        /// * Filtering by specific segment and chunk IDs.
        /// * Latest-at, range and dataframe queries.
        /// * Arbitrary Lance filters.
        ///
        /// To fetch the actual chunks themselves, see `FetchChunks`.
        ///
        /// Passing chunk IDs to this method effectively acts as a IF_EXIST filter.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn query_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryDatasetRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::QueryDatasetResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/QueryDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "QueryDataset",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Fetch specific chunks from Rerun Cloud. In a 2-step query process, result of 1st phase,
        /// that is, the result of `QueryDataset` should include all the necessary information to send
        /// the actual chunk requests, which is the 2nd step of the query process.
        ///
        /// See `FetchChunksRequest` for details on the fields that describe each individual chunk.
        pub async fn fetch_chunks(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchChunksRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::FetchChunksResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/FetchChunks",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "FetchChunks",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Register a foreign table as a new table entry in the catalog.
        pub async fn register_table(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterTableRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterTableResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/RegisterTable",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "RegisterTable",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_table_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTableSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTableSchemaResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/GetTableSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "GetTableSchema",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn scan_table(
            &mut self,
            request: impl tonic::IntoRequest<super::ScanTableRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ScanTableResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/ScanTable",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "ScanTable",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Write record batches to a table.
        ///
        /// This endpoint requires the standard dataset headers.
        ///
        /// TODO(#11645): endpoints with streaming input are not supported by `grpc-web`.
        /// A non-streaming shim will need to be added if/when the viewer uses this endpoint.
        pub async fn write_table(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::WriteTableRequest>,
        ) -> std::result::Result<tonic::Response<super::WriteTableResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/WriteTable",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "WriteTable",
            ));
            self.inner.client_streaming(req, path, codec).await
        }
        /// Query the status of submitted tasks
        pub async fn query_tasks(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryTasksRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryTasksResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/QueryTasks",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "QueryTasks",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Query the status of submitted tasks as soon as they are no longer pending
        pub async fn query_tasks_on_completion(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryTasksOnCompletionRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::QueryTasksOnCompletionResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/QueryTasksOnCompletion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "QueryTasksOnCompletion",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Rerun Manifests maintenance operations: scalar index creation, compaction, etc.
        ///
        /// This endpoint requires the standard dataset headers.
        pub async fn do_maintenance(
            &mut self,
            request: impl tonic::IntoRequest<super::DoMaintenanceRequest>,
        ) -> std::result::Result<tonic::Response<super::DoMaintenanceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/DoMaintenance",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "DoMaintenance",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Run global maintenance operations on the platform: this includes optimization
        /// of all datasets, garbage collection of unused data, and can include more in the future.
        pub async fn do_global_maintenance(
            &mut self,
            request: impl tonic::IntoRequest<super::DoGlobalMaintenanceRequest>,
        ) -> std::result::Result<tonic::Response<super::DoGlobalMaintenanceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/rerun.cloud.v1alpha1.RerunCloudService/DoGlobalMaintenance",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "rerun.cloud.v1alpha1.RerunCloudService",
                "DoGlobalMaintenance",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod rerun_cloud_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with RerunCloudServiceServer.
    #[async_trait]
    pub trait RerunCloudService: std::marker::Send + std::marker::Sync + 'static {
        async fn version(
            &self,
            request: tonic::Request<super::VersionRequest>,
        ) -> std::result::Result<tonic::Response<super::VersionResponse>, tonic::Status>;
        async fn find_entries(
            &self,
            request: tonic::Request<super::FindEntriesRequest>,
        ) -> std::result::Result<tonic::Response<super::FindEntriesResponse>, tonic::Status>;
        async fn delete_entry(
            &self,
            request: tonic::Request<super::DeleteEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteEntryResponse>, tonic::Status>;
        async fn update_entry(
            &self,
            request: tonic::Request<super::UpdateEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateEntryResponse>, tonic::Status>;
        async fn create_dataset_entry(
            &self,
            request: tonic::Request<super::CreateDatasetEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateDatasetEntryResponse>, tonic::Status>;
        async fn create_table_entry(
            &self,
            request: tonic::Request<super::CreateTableEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateTableEntryResponse>, tonic::Status>;
        /// Fetch metadata about a specific dataset.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn read_dataset_entry(
            &self,
            request: tonic::Request<super::ReadDatasetEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadDatasetEntryResponse>, tonic::Status>;
        async fn update_dataset_entry(
            &self,
            request: tonic::Request<super::UpdateDatasetEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateDatasetEntryResponse>, tonic::Status>;
        async fn read_table_entry(
            &self,
            request: tonic::Request<super::ReadTableEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadTableEntryResponse>, tonic::Status>;
        /// Register new segments with the Dataset.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn register_with_dataset(
            &self,
            request: tonic::Request<super::RegisterWithDatasetRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterWithDatasetResponse>, tonic::Status>;
        /// Server streaming response type for the UnregisterFromDataset method.
        type UnregisterFromDatasetStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::UnregisterFromDatasetResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// Unregisters segments and layers from the Dataset.
        ///
        /// Excluding IO errors, this will always succeed as long the target dataset exists.
        /// Corollary: unregistering data that doesn't exist is a no-op.
        ///
        /// This always returns a subset of the data from `ScanDatasetManifest`, and therefore the data will
        /// also follow the schema returned by `GetDatasetManifestSchema`.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn unregister_from_dataset(
            &self,
            request: tonic::Request<super::UnregisterFromDatasetRequest>,
        ) -> std::result::Result<tonic::Response<Self::UnregisterFromDatasetStream>, tonic::Status>;
        /// Write chunks to one or more segments.
        ///
        /// The segment ID for each individual chunk is extracted from their metadata (`rerun:segment_id`).
        ///
        /// This endpoint requires the standard dataset headers.
        async fn write_chunks(
            &self,
            request: tonic::Request<tonic::Streaming<super::WriteChunksRequest>>,
        ) -> std::result::Result<tonic::Response<super::WriteChunksResponse>, tonic::Status>;
        /// Returns the schema of the segment table.
        ///
        /// This is not to be confused with the schema of the dataset itself. For that, refer to `GetDatasetSchema`.
        ///
        /// To inspect the data of the segment table, which is guaranteed to match the schema returned by
        /// this endpoint, check out `ScanSegmentTable`.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn get_segment_table_schema(
            &self,
            request: tonic::Request<super::GetSegmentTableSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSegmentTableSchemaResponse>, tonic::Status>;
        /// Server streaming response type for the ScanSegmentTable method.
        type ScanSegmentTableStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ScanSegmentTableResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// Inspect the contents of the segment table.
        ///
        /// The data will follow the schema returned by `GetSegmentTableSchema`.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn scan_segment_table(
            &self,
            request: tonic::Request<super::ScanSegmentTableRequest>,
        ) -> std::result::Result<tonic::Response<Self::ScanSegmentTableStream>, tonic::Status>;
        /// Returns the schema of the dataset manifest.
        ///
        /// To inspect the data of the dataset manifest, which is guaranteed to match the schema returned by
        /// this endpoint, check out `ScanDatasetManifest`.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn get_dataset_manifest_schema(
            &self,
            request: tonic::Request<super::GetDatasetManifestSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDatasetManifestSchemaResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the ScanDatasetManifest method.
        type ScanDatasetManifestStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ScanDatasetManifestResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// Inspect the contents of the dataset manifest.
        ///
        /// The data will follow the schema returned by `GetDatasetManifestSchema`.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn scan_dataset_manifest(
            &self,
            request: tonic::Request<super::ScanDatasetManifestRequest>,
        ) -> std::result::Result<tonic::Response<Self::ScanDatasetManifestStream>, tonic::Status>;
        /// Returns the schema of the dataset.
        ///
        /// This is the union of all the schemas from all the underlying segments. It will contain all the indexes,
        /// entities and components present in the dataset.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn get_dataset_schema(
            &self,
            request: tonic::Request<super::GetDatasetSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::GetDatasetSchemaResponse>, tonic::Status>;
        /// Server streaming response type for the GetRrdManifest method.
        type GetRrdManifestStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::GetRrdManifestResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// Get the RRD Footer manifest.
        ///
        /// This includes details about what chunks there are, and what kind of data they contain.
        async fn get_rrd_manifest(
            &self,
            request: tonic::Request<super::GetRrdManifestRequest>,
        ) -> std::result::Result<tonic::Response<Self::GetRrdManifestStream>, tonic::Status>;
        /// Creates a custom index for a specific column (vector search, full-text search, etc).
        ///
        /// This endpoint requires the standard dataset headers.
        async fn create_index(
            &self,
            request: tonic::Request<super::CreateIndexRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateIndexResponse>, tonic::Status>;
        /// List all user-defined indexes in this dataset.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn list_indexes(
            &self,
            request: tonic::Request<super::ListIndexesRequest>,
        ) -> std::result::Result<tonic::Response<super::ListIndexesResponse>, tonic::Status>;
        /// Delete a custom index for a specific column.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn delete_indexes(
            &self,
            request: tonic::Request<super::DeleteIndexesRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteIndexesResponse>, tonic::Status>;
        /// Server streaming response type for the SearchDataset method.
        type SearchDatasetStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SearchDatasetResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// Search a previously created index.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn search_dataset(
            &self,
            request: tonic::Request<super::SearchDatasetRequest>,
        ) -> std::result::Result<tonic::Response<Self::SearchDatasetStream>, tonic::Status>;
        /// Server streaming response type for the QueryDataset method.
        type QueryDatasetStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::QueryDatasetResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// Perform Rerun-native queries on a dataset, returning the matching chunk IDs, as well
        /// as information that can be sent back to Rerun Cloud to fetch the actual chunks as part
        /// of `FetchChunks` request. In this 2-step query process, 1st step is getting information
        /// from the server about the chunks that contain relevant information. 2nd step is fetching
        /// those chunks (the actual data).
        ///
        /// These Rerun-native queries include:
        /// * Filtering by specific segment and chunk IDs.
        /// * Latest-at, range and dataframe queries.
        /// * Arbitrary Lance filters.
        ///
        /// To fetch the actual chunks themselves, see `FetchChunks`.
        ///
        /// Passing chunk IDs to this method effectively acts as a IF_EXIST filter.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn query_dataset(
            &self,
            request: tonic::Request<super::QueryDatasetRequest>,
        ) -> std::result::Result<tonic::Response<Self::QueryDatasetStream>, tonic::Status>;
        /// Server streaming response type for the FetchChunks method.
        type FetchChunksStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::FetchChunksResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// Fetch specific chunks from Rerun Cloud. In a 2-step query process, result of 1st phase,
        /// that is, the result of `QueryDataset` should include all the necessary information to send
        /// the actual chunk requests, which is the 2nd step of the query process.
        ///
        /// See `FetchChunksRequest` for details on the fields that describe each individual chunk.
        async fn fetch_chunks(
            &self,
            request: tonic::Request<super::FetchChunksRequest>,
        ) -> std::result::Result<tonic::Response<Self::FetchChunksStream>, tonic::Status>;
        /// Register a foreign table as a new table entry in the catalog.
        async fn register_table(
            &self,
            request: tonic::Request<super::RegisterTableRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterTableResponse>, tonic::Status>;
        async fn get_table_schema(
            &self,
            request: tonic::Request<super::GetTableSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTableSchemaResponse>, tonic::Status>;
        /// Server streaming response type for the ScanTable method.
        type ScanTableStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ScanTableResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn scan_table(
            &self,
            request: tonic::Request<super::ScanTableRequest>,
        ) -> std::result::Result<tonic::Response<Self::ScanTableStream>, tonic::Status>;
        /// Write record batches to a table.
        ///
        /// This endpoint requires the standard dataset headers.
        ///
        /// TODO(#11645): endpoints with streaming input are not supported by `grpc-web`.
        /// A non-streaming shim will need to be added if/when the viewer uses this endpoint.
        async fn write_table(
            &self,
            request: tonic::Request<tonic::Streaming<super::WriteTableRequest>>,
        ) -> std::result::Result<tonic::Response<super::WriteTableResponse>, tonic::Status>;
        /// Query the status of submitted tasks
        async fn query_tasks(
            &self,
            request: tonic::Request<super::QueryTasksRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryTasksResponse>, tonic::Status>;
        /// Server streaming response type for the QueryTasksOnCompletion method.
        type QueryTasksOnCompletionStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::QueryTasksOnCompletionResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// Query the status of submitted tasks as soon as they are no longer pending
        async fn query_tasks_on_completion(
            &self,
            request: tonic::Request<super::QueryTasksOnCompletionRequest>,
        ) -> std::result::Result<tonic::Response<Self::QueryTasksOnCompletionStream>, tonic::Status>;
        /// Rerun Manifests maintenance operations: scalar index creation, compaction, etc.
        ///
        /// This endpoint requires the standard dataset headers.
        async fn do_maintenance(
            &self,
            request: tonic::Request<super::DoMaintenanceRequest>,
        ) -> std::result::Result<tonic::Response<super::DoMaintenanceResponse>, tonic::Status>;
        /// Run global maintenance operations on the platform: this includes optimization
        /// of all datasets, garbage collection of unused data, and can include more in the future.
        async fn do_global_maintenance(
            &self,
            request: tonic::Request<super::DoGlobalMaintenanceRequest>,
        ) -> std::result::Result<tonic::Response<super::DoGlobalMaintenanceResponse>, tonic::Status>;
    }
    /// The Rerun Cloud public API.
    ///
    /// ## Headers
    ///
    /// Most endpoints in the Rerun Cloud service require specific gRPC headers to be set.
    ///
    /// The so-called "standard dataset headers" correspond to at least one of the following headers:
    /// * x-rerun-entry-id: ID of the entry of interest, e.g. `1860390B087BC65F602d68eb646c385c`.
    /// * x-rerun-entry-name-bin: Name of the entry of interest, e.g. `droid:sample2k`.
    ///
    /// Headers with a -bin suffix must be base64-encoded (HTTP only supports ASCII values, UTF8 strings must
    /// binary encoded).
    #[derive(Debug)]
    pub struct RerunCloudServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> RerunCloudServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for RerunCloudServiceServer<T>
    where
        T: RerunCloudService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/rerun.cloud.v1alpha1.RerunCloudService/Version" => {
                    #[allow(non_camel_case_types)]
                    struct VersionSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService> tonic::server::UnaryService<super::VersionRequest> for VersionSvc<T> {
                        type Response = super::VersionResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VersionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::version(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VersionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/FindEntries" => {
                    #[allow(non_camel_case_types)]
                    struct FindEntriesSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::FindEntriesRequest>
                        for FindEntriesSvc<T>
                    {
                        type Response = super::FindEntriesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindEntriesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::find_entries(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FindEntriesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/DeleteEntry" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteEntrySvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::DeleteEntryRequest>
                        for DeleteEntrySvc<T>
                    {
                        type Response = super::DeleteEntryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteEntryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::delete_entry(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteEntrySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/UpdateEntry" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateEntrySvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::UpdateEntryRequest>
                        for UpdateEntrySvc<T>
                    {
                        type Response = super::UpdateEntryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateEntryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::update_entry(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateEntrySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/CreateDatasetEntry" => {
                    #[allow(non_camel_case_types)]
                    struct CreateDatasetEntrySvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::CreateDatasetEntryRequest>
                        for CreateDatasetEntrySvc<T>
                    {
                        type Response = super::CreateDatasetEntryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateDatasetEntryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::create_dataset_entry(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateDatasetEntrySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/CreateTableEntry" => {
                    #[allow(non_camel_case_types)]
                    struct CreateTableEntrySvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::CreateTableEntryRequest>
                        for CreateTableEntrySvc<T>
                    {
                        type Response = super::CreateTableEntryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateTableEntryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::create_table_entry(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateTableEntrySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/ReadDatasetEntry" => {
                    #[allow(non_camel_case_types)]
                    struct ReadDatasetEntrySvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::ReadDatasetEntryRequest>
                        for ReadDatasetEntrySvc<T>
                    {
                        type Response = super::ReadDatasetEntryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadDatasetEntryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::read_dataset_entry(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadDatasetEntrySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/UpdateDatasetEntry" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateDatasetEntrySvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::UpdateDatasetEntryRequest>
                        for UpdateDatasetEntrySvc<T>
                    {
                        type Response = super::UpdateDatasetEntryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateDatasetEntryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::update_dataset_entry(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateDatasetEntrySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/ReadTableEntry" => {
                    #[allow(non_camel_case_types)]
                    struct ReadTableEntrySvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::ReadTableEntryRequest>
                        for ReadTableEntrySvc<T>
                    {
                        type Response = super::ReadTableEntryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadTableEntryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::read_table_entry(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadTableEntrySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/RegisterWithDataset" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterWithDatasetSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::RegisterWithDatasetRequest>
                        for RegisterWithDatasetSvc<T>
                    {
                        type Response = super::RegisterWithDatasetResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterWithDatasetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::register_with_dataset(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterWithDatasetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/UnregisterFromDataset" => {
                    #[allow(non_camel_case_types)]
                    struct UnregisterFromDatasetSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ServerStreamingService<super::UnregisterFromDatasetRequest>
                        for UnregisterFromDatasetSvc<T>
                    {
                        type Response = super::UnregisterFromDatasetResponse;
                        type ResponseStream = T::UnregisterFromDatasetStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnregisterFromDatasetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::unregister_from_dataset(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnregisterFromDatasetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/WriteChunks" => {
                    #[allow(non_camel_case_types)]
                    struct WriteChunksSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ClientStreamingService<super::WriteChunksRequest>
                        for WriteChunksSvc<T>
                    {
                        type Response = super::WriteChunksResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::WriteChunksRequest>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::write_chunks(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WriteChunksSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/GetSegmentTableSchema" => {
                    #[allow(non_camel_case_types)]
                    struct GetSegmentTableSchemaSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::GetSegmentTableSchemaRequest>
                        for GetSegmentTableSchemaSvc<T>
                    {
                        type Response = super::GetSegmentTableSchemaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSegmentTableSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::get_segment_table_schema(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSegmentTableSchemaSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/ScanSegmentTable" => {
                    #[allow(non_camel_case_types)]
                    struct ScanSegmentTableSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ServerStreamingService<super::ScanSegmentTableRequest>
                        for ScanSegmentTableSvc<T>
                    {
                        type Response = super::ScanSegmentTableResponse;
                        type ResponseStream = T::ScanSegmentTableStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ScanSegmentTableRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::scan_segment_table(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ScanSegmentTableSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/GetDatasetManifestSchema" => {
                    #[allow(non_camel_case_types)]
                    struct GetDatasetManifestSchemaSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::GetDatasetManifestSchemaRequest>
                        for GetDatasetManifestSchemaSvc<T>
                    {
                        type Response = super::GetDatasetManifestSchemaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetDatasetManifestSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::get_dataset_manifest_schema(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDatasetManifestSchemaSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/ScanDatasetManifest" => {
                    #[allow(non_camel_case_types)]
                    struct ScanDatasetManifestSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ServerStreamingService<super::ScanDatasetManifestRequest>
                        for ScanDatasetManifestSvc<T>
                    {
                        type Response = super::ScanDatasetManifestResponse;
                        type ResponseStream = T::ScanDatasetManifestStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ScanDatasetManifestRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::scan_dataset_manifest(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ScanDatasetManifestSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/GetDatasetSchema" => {
                    #[allow(non_camel_case_types)]
                    struct GetDatasetSchemaSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::GetDatasetSchemaRequest>
                        for GetDatasetSchemaSvc<T>
                    {
                        type Response = super::GetDatasetSchemaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetDatasetSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::get_dataset_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDatasetSchemaSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/GetRrdManifest" => {
                    #[allow(non_camel_case_types)]
                    struct GetRrdManifestSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ServerStreamingService<super::GetRrdManifestRequest>
                        for GetRrdManifestSvc<T>
                    {
                        type Response = super::GetRrdManifestResponse;
                        type ResponseStream = T::GetRrdManifestStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRrdManifestRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::get_rrd_manifest(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetRrdManifestSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/CreateIndex" => {
                    #[allow(non_camel_case_types)]
                    struct CreateIndexSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::CreateIndexRequest>
                        for CreateIndexSvc<T>
                    {
                        type Response = super::CreateIndexResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateIndexRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::create_index(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateIndexSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/ListIndexes" => {
                    #[allow(non_camel_case_types)]
                    struct ListIndexesSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::ListIndexesRequest>
                        for ListIndexesSvc<T>
                    {
                        type Response = super::ListIndexesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListIndexesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::list_indexes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListIndexesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/DeleteIndexes" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteIndexesSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::DeleteIndexesRequest>
                        for DeleteIndexesSvc<T>
                    {
                        type Response = super::DeleteIndexesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteIndexesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::delete_indexes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteIndexesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/SearchDataset" => {
                    #[allow(non_camel_case_types)]
                    struct SearchDatasetSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ServerStreamingService<super::SearchDatasetRequest>
                        for SearchDatasetSvc<T>
                    {
                        type Response = super::SearchDatasetResponse;
                        type ResponseStream = T::SearchDatasetStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SearchDatasetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::search_dataset(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SearchDatasetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/QueryDataset" => {
                    #[allow(non_camel_case_types)]
                    struct QueryDatasetSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ServerStreamingService<super::QueryDatasetRequest>
                        for QueryDatasetSvc<T>
                    {
                        type Response = super::QueryDatasetResponse;
                        type ResponseStream = T::QueryDatasetStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryDatasetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::query_dataset(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryDatasetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/FetchChunks" => {
                    #[allow(non_camel_case_types)]
                    struct FetchChunksSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ServerStreamingService<super::FetchChunksRequest>
                        for FetchChunksSvc<T>
                    {
                        type Response = super::FetchChunksResponse;
                        type ResponseStream = T::FetchChunksStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FetchChunksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::fetch_chunks(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FetchChunksSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/RegisterTable" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterTableSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::RegisterTableRequest>
                        for RegisterTableSvc<T>
                    {
                        type Response = super::RegisterTableResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterTableRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::register_table(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterTableSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/GetTableSchema" => {
                    #[allow(non_camel_case_types)]
                    struct GetTableSchemaSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::GetTableSchemaRequest>
                        for GetTableSchemaSvc<T>
                    {
                        type Response = super::GetTableSchemaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTableSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::get_table_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTableSchemaSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/ScanTable" => {
                    #[allow(non_camel_case_types)]
                    struct ScanTableSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ServerStreamingService<super::ScanTableRequest>
                        for ScanTableSvc<T>
                    {
                        type Response = super::ScanTableResponse;
                        type ResponseStream = T::ScanTableStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ScanTableRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::scan_table(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ScanTableSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/WriteTable" => {
                    #[allow(non_camel_case_types)]
                    struct WriteTableSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ClientStreamingService<super::WriteTableRequest>
                        for WriteTableSvc<T>
                    {
                        type Response = super::WriteTableResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::WriteTableRequest>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::write_table(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WriteTableSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/QueryTasks" => {
                    #[allow(non_camel_case_types)]
                    struct QueryTasksSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService> tonic::server::UnaryService<super::QueryTasksRequest>
                        for QueryTasksSvc<T>
                    {
                        type Response = super::QueryTasksResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryTasksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::query_tasks(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryTasksSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/QueryTasksOnCompletion" => {
                    #[allow(non_camel_case_types)]
                    struct QueryTasksOnCompletionSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::ServerStreamingService<super::QueryTasksOnCompletionRequest>
                        for QueryTasksOnCompletionSvc<T>
                    {
                        type Response = super::QueryTasksOnCompletionResponse;
                        type ResponseStream = T::QueryTasksOnCompletionStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryTasksOnCompletionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::query_tasks_on_completion(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryTasksOnCompletionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/DoMaintenance" => {
                    #[allow(non_camel_case_types)]
                    struct DoMaintenanceSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::DoMaintenanceRequest>
                        for DoMaintenanceSvc<T>
                    {
                        type Response = super::DoMaintenanceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DoMaintenanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::do_maintenance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DoMaintenanceSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rerun.cloud.v1alpha1.RerunCloudService/DoGlobalMaintenance" => {
                    #[allow(non_camel_case_types)]
                    struct DoGlobalMaintenanceSvc<T: RerunCloudService>(pub Arc<T>);
                    impl<T: RerunCloudService>
                        tonic::server::UnaryService<super::DoGlobalMaintenanceRequest>
                        for DoGlobalMaintenanceSvc<T>
                    {
                        type Response = super::DoGlobalMaintenanceResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DoGlobalMaintenanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RerunCloudService>::do_global_maintenance(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DoGlobalMaintenanceSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(tonic::body::Body::default());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for RerunCloudServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "rerun.cloud.v1alpha1.RerunCloudService";
    impl<T> tonic::server::NamedService for RerunCloudServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
