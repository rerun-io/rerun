// This file is @generated by prost-build.
/// There are 3 different `LogMsg`-related types that you will very often encounter: `re_log_types::LogMsg`,
/// `re_protos::log_msg::v1alpha1::LogMsg` and `re_protos::log_msg::v1alpha1::log_msg::Msg`.
///
/// Mixing them up is a common source of pain and confusion, so let's go over what each does:
/// * `re_log_types::LogMsg` is the application-level type that we use all across the viewer
///    codebase. It can be obtained by calling `to_application()` on one of the transport-level
///    `LogMsg` types which, among many other things, will perform Chunk/Sorbet-level migrations.
///    `re_log_types::LogMsg` isn't used in Redap, where everything is done at the transport-level, always.
/// * `re_protos::log_msg::v1alpha1::LogMsg` is the transport-level definition of `LogMsg`. It is an
///    artifact of how `oneof` works in Protobuf: all it does is carry a `re_protos::log_msg::v1alpha1::log_msg::Msg`.
///    For that reason, it is never directly used, except by the legacy SDK comms protocol.
/// * Finally, `re_protos::log_msg::v1alpha1::log_msg::Msg` is the real transport-level type that we
///    care about. It is used all over the place when encoding and decoding RRD streams.
///
/// TODO(#8631): Remove `LogMsg`
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LogMsg {
    #[prost(oneof = "log_msg::Msg", tags = "1, 2, 3")]
    pub msg: ::core::option::Option<log_msg::Msg>,
}
/// Nested message and enum types in `LogMsg`.
pub mod log_msg {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Msg {
        /// A message that contains a new store info.
        #[prost(message, tag = "1")]
        SetStoreInfo(super::SetStoreInfo),
        /// A message that contains an Arrow-IPC encoded message.
        #[prost(message, tag = "2")]
        ArrowMsg(super::ArrowMsg),
        /// A message that contains a blueprint activation command.
        #[prost(message, tag = "3")]
        BlueprintActivationCommand(super::BlueprintActivationCommand),
    }
}
impl ::prost::Name for LogMsg {
    const NAME: &'static str = "LogMsg";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.LogMsg".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.LogMsg".into()
    }
}
/// Corresponds to `LogMsg::SetStoreInfo`. Used to identify a recording.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetStoreInfo {
    /// A time-based UID that is used to determine how a `StoreInfo` fits in the global ordering of events.
    #[prost(message, optional, tag = "1")]
    pub row_id: ::core::option::Option<super::super::common::v1alpha1::Tuid>,
    /// The new store info.
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<StoreInfo>,
}
impl ::prost::Name for SetStoreInfo {
    const NAME: &'static str = "SetStoreInfo";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.SetStoreInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.SetStoreInfo".into()
    }
}
/// Corresponds to `LogMsg::ArrowMsg`. Used to transmit actual data.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ArrowMsg {
    /// The ID of the store that this message is for.
    #[prost(message, optional, tag = "1")]
    pub store_id: ::core::option::Option<super::super::common::v1alpha1::StoreId>,
    /// If the payload is a chunk, this is its ID. Otherwise empty.
    #[prost(message, optional, tag = "6")]
    pub chunk_id: ::core::option::Option<super::super::common::v1alpha1::Tuid>,
    /// Compression algorithm used.
    #[prost(enumeration = "super::super::common::v1alpha1::Compression", tag = "2")]
    pub compression: i32,
    #[prost(uint64, tag = "3")]
    pub uncompressed_size: u64,
    /// Encoding of the payload.
    #[prost(enumeration = "Encoding", tag = "4")]
    pub encoding: i32,
    /// Arrow-IPC encoded schema and chunk, compressed according to the `compression` field.
    #[prost(bytes = "bytes", tag = "5")]
    pub payload: ::prost::bytes::Bytes,
    /// If true, this is guaranteed to be a chunk containing only static data.
    #[prost(bool, optional, tag = "7")]
    pub is_static: ::core::option::Option<bool>,
}
impl ::prost::Name for ArrowMsg {
    const NAME: &'static str = "ArrowMsg";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.ArrowMsg".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.ArrowMsg".into()
    }
}
/// Corresponds to `LogMsg::BlueprintActivationCommand`.
///
/// Used for activating a blueprint once it has been fully transmitted,
/// because showing a blueprint before it is fully transmitted can lead to
/// a confusing user experience, or inconsistent results due to heuristics.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlueprintActivationCommand {
    /// The ID of the blueprint to activate.
    #[prost(message, optional, tag = "1")]
    pub blueprint_id: ::core::option::Option<super::super::common::v1alpha1::StoreId>,
    /// Whether to make the blueprint active immediately.
    #[prost(bool, tag = "2")]
    pub make_active: bool,
    /// Whether to make the blueprint the default.
    #[prost(bool, tag = "3")]
    pub make_default: bool,
}
impl ::prost::Name for BlueprintActivationCommand {
    const NAME: &'static str = "BlueprintActivationCommand";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.BlueprintActivationCommand".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.BlueprintActivationCommand".into()
    }
}
/// Information about a recording or blueprint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StoreInfo {
    /// User-chosen name of the application doing the logging.
    ///
    /// This is deprecated and kept for backward compatibility.
    /// TODO(#10730): turn that into `reserved` statement when removing backward compatibility
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub application_id: ::core::option::Option<super::super::common::v1alpha1::ApplicationId>,
    /// Unique ID of the recording.
    #[prost(message, optional, tag = "2")]
    pub store_id: ::core::option::Option<super::super::common::v1alpha1::StoreId>,
    /// Where the recording came from.
    #[prost(message, optional, tag = "5")]
    pub store_source: ::core::option::Option<StoreSource>,
    /// Version of the store crate.
    #[prost(message, optional, tag = "6")]
    pub store_version: ::core::option::Option<StoreVersion>,
}
impl ::prost::Name for StoreInfo {
    const NAME: &'static str = "StoreInfo";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.StoreInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.StoreInfo".into()
    }
}
/// The source of a recording or blueprint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StoreSource {
    /// Determines what is encoded in `extra`.
    #[prost(enumeration = "StoreSourceKind", tag = "1")]
    pub kind: i32,
    /// Store source payload. See `StoreSourceKind` for what exactly is encoded here.
    #[prost(message, optional, tag = "2")]
    pub extra: ::core::option::Option<StoreSourceExtra>,
}
impl ::prost::Name for StoreSource {
    const NAME: &'static str = "StoreSource";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.StoreSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.StoreSource".into()
    }
}
/// A newtype for `StoreSource` payload.
///
/// This exists to that we can implement conversions on the newtype for convenience.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StoreSourceExtra {
    #[prost(bytes = "bytes", tag = "1")]
    pub payload: ::prost::bytes::Bytes,
}
impl ::prost::Name for StoreSourceExtra {
    const NAME: &'static str = "StoreSourceExtra";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.StoreSourceExtra".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.StoreSourceExtra".into()
    }
}
/// Version of the Python SDK that created the recording.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PythonVersion {
    #[prost(int32, tag = "1")]
    pub major: i32,
    #[prost(int32, tag = "2")]
    pub minor: i32,
    #[prost(int32, tag = "3")]
    pub patch: i32,
    #[prost(string, tag = "4")]
    pub suffix: ::prost::alloc::string::String,
}
impl ::prost::Name for PythonVersion {
    const NAME: &'static str = "PythonVersion";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.PythonVersion".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.PythonVersion".into()
    }
}
/// Information about the Rust SDK that created the recording.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CrateInfo {
    /// Version of the Rust compiler used to compile the SDK.
    #[prost(string, tag = "1")]
    pub rustc_version: ::prost::alloc::string::String,
    /// Version of LLVM used by the Rust compiler.
    #[prost(string, tag = "2")]
    pub llvm_version: ::prost::alloc::string::String,
}
impl ::prost::Name for CrateInfo {
    const NAME: &'static str = "CrateInfo";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.CrateInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.CrateInfo".into()
    }
}
/// A recording which came from a file.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FileSource {
    #[prost(enumeration = "FileSourceKind", tag = "1")]
    pub kind: i32,
}
impl ::prost::Name for FileSource {
    const NAME: &'static str = "FileSource";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.FileSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.FileSource".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StoreVersion {
    /// Crate version encoded using our custom scheme.
    ///
    /// See `CrateVersion` in `re_build_info`.
    #[prost(int32, tag = "1")]
    pub crate_version_bits: i32,
}
impl ::prost::Name for StoreVersion {
    const NAME: &'static str = "StoreVersion";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.StoreVersion".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.StoreVersion".into()
    }
}
/// This is the payload that is carried in messages of type `::End` in RRD streams.
///
/// It keeps track of various useful information about the associated recording.
///
/// During normal operations, there can only be a single `::End` message in an RRD stream, and
/// therefore a single `RrdFooter`.
/// It is possible to break that invariant by concatenating streams using external tools,
/// e.g. by doing something like `cat *.rrd > all_my_recordings.rrd`.
/// Passing that stream back through Rerun tools, e.g. `cat *.rrd | rerun rrd merge > all_my_recordings.rrd`,
/// would once again guarantee that only one `::End` message is present though.
/// I.e. that invariant holds as long as one stays within our ecosystem of tools.
///
/// This is a transport-level type, the associated application-level type can be found
/// in `re_log_encoding::RrdFooter`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RrdFooter {
    /// All the `RrdManifest`s that were found in this RRD stream.
    ///
    /// Each `RrdManifest` corresponds to one, and exactly one, recording.
    ///
    /// The order is unspecified.
    #[prost(message, repeated, tag = "1")]
    pub manifests: ::prost::alloc::vec::Vec<RrdManifest>,
}
impl ::prost::Name for RrdFooter {
    const NAME: &'static str = "RrdFooter";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.RrdFooter".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.RrdFooter".into()
    }
}
/// This is the payload found in `RrdFooter`s.
///
/// Each `RrdManifest` corresponds to one, and exactly one, RRD stream (i.e. recording).
/// This restriction exists to make working with multiple RRD streams much simpler: due to the way
/// the Rerun data model works, filtering rows of data from a manifest can have hard-to-predict
/// second order effects on the schema of the stream as a whole.
/// By keeping manifests for different recordings separate, we remove the need to filter per
/// recording ID, greatly simplifying the process.
///
/// This is a transport-level type, the associated application-level type can be found
/// in `re_log_encoding::RrdManifest`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RrdManifest {
    /// The recording ID that was used to identify the original recording.
    ///
    /// This is extracted from the `SetStoreInfo` message of the associated RRD stream.
    #[prost(message, optional, tag = "1")]
    pub store_id: ::core::option::Option<super::super::common::v1alpha1::StoreId>,
    /// The Sorbet schema of the associated RRD stream.
    ///
    /// ⚠️ This is the Sorbet schema of the recording being indexed by this manifest, *not* the
    /// schema of `Self::manifest`.
    #[prost(message, optional, tag = "2")]
    pub sorbet_schema: ::core::option::Option<super::super::common::v1alpha1::Schema>,
    /// The SHA256 hash of the Sorbet schema of the associated RRD stream.
    ///
    /// This is always computed by sorting the fields of the schema by name first.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub sorbet_schema_sha256: ::core::option::Option<::prost::bytes::Bytes>,
    /// The complete manifest for the associated RRD stream.
    ///
    /// Each row in this dataframe describes a unique chunk (ID, offset, size, timeline & component stats, etc).
    /// This can be used to compute relevancy queries (latest-at, range, dataframe), without needing to load
    /// any of the actual data in memory.
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<super::super::common::v1alpha1::DataframePart>,
}
impl ::prost::Name for RrdManifest {
    const NAME: &'static str = "RrdManifest";
    const PACKAGE: &'static str = "rerun.log_msg.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.log_msg.v1alpha1.RrdManifest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.log_msg.v1alpha1.RrdManifest".into()
    }
}
/// The encoding of the message payload.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Encoding {
    /// We don't know what encoding the payload is in.
    Unspecified = 0,
    /// The payload is encoded as Arrow-IPC.
    ArrowIpc = 1,
}
impl Encoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENCODING_UNSPECIFIED",
            Self::ArrowIpc => "ENCODING_ARROW_IPC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
            "ENCODING_ARROW_IPC" => Some(Self::ArrowIpc),
            _ => None,
        }
    }
}
/// What kind of source a recording comes from.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StoreSourceKind {
    /// We don't know anything about the source of this recording.
    ///
    /// `extra` is unused.
    Unspecified = 0,
    /// The recording came from the C++ SDK.
    ///
    /// `extra` is unused.
    CSdk = 1,
    /// The recording came from the Python SDK.
    ///
    /// `extra` is `PythonVersion`.
    PythonSdk = 2,
    /// The recording came from the Rust SDK.
    ///
    /// `extra` is `CrateInfo`.
    RustSdk = 3,
    /// The recording came from a file.
    ///
    /// `extra` is `FileSource`.
    File = 4,
    /// The recording came from some action in the viewer.
    ///
    /// `extra` is unused.
    Viewer = 5,
    /// The recording came from some other source.
    ///
    /// `extra` is a string.
    Other = 6,
}
impl StoreSourceKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STORE_SOURCE_KIND_UNSPECIFIED",
            Self::CSdk => "STORE_SOURCE_KIND_C_SDK",
            Self::PythonSdk => "STORE_SOURCE_KIND_PYTHON_SDK",
            Self::RustSdk => "STORE_SOURCE_KIND_RUST_SDK",
            Self::File => "STORE_SOURCE_KIND_FILE",
            Self::Viewer => "STORE_SOURCE_KIND_VIEWER",
            Self::Other => "STORE_SOURCE_KIND_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORE_SOURCE_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "STORE_SOURCE_KIND_C_SDK" => Some(Self::CSdk),
            "STORE_SOURCE_KIND_PYTHON_SDK" => Some(Self::PythonSdk),
            "STORE_SOURCE_KIND_RUST_SDK" => Some(Self::RustSdk),
            "STORE_SOURCE_KIND_FILE" => Some(Self::File),
            "STORE_SOURCE_KIND_VIEWER" => Some(Self::Viewer),
            "STORE_SOURCE_KIND_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
/// Determines where the file came from.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FileSourceKind {
    /// We don't know where the file came from.
    Unspecified = 0,
    /// The file came from the command line.
    Cli = 1,
    /// The file was served over HTTP.
    Uri = 2,
    /// The file was dragged into the viewer.
    DragAndDrop = 3,
    /// The file was opened using a file dialog.
    FileDialog = 4,
    /// The recording was produced using a data loader, such as when logging a mesh file.
    Sdk = 5,
}
impl FileSourceKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FILE_SOURCE_KIND_UNSPECIFIED",
            Self::Cli => "FILE_SOURCE_KIND_CLI",
            Self::Uri => "FILE_SOURCE_KIND_URI",
            Self::DragAndDrop => "FILE_SOURCE_KIND_DRAG_AND_DROP",
            Self::FileDialog => "FILE_SOURCE_KIND_FILE_DIALOG",
            Self::Sdk => "FILE_SOURCE_KIND_SDK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FILE_SOURCE_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "FILE_SOURCE_KIND_CLI" => Some(Self::Cli),
            "FILE_SOURCE_KIND_URI" => Some(Self::Uri),
            "FILE_SOURCE_KIND_DRAG_AND_DROP" => Some(Self::DragAndDrop),
            "FILE_SOURCE_KIND_FILE_DIALOG" => Some(Self::FileDialog),
            "FILE_SOURCE_KIND_SDK" => Some(Self::Sdk),
            _ => None,
        }
    }
}
