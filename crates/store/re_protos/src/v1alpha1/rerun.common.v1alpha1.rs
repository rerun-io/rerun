// This file is @generated by prost-build.
/// RerunChunk is arrow IPC encoded RecordBatch that has
/// rerun-specific semantic constraints and can be directly
/// converted to a Rerun Chunk (`re_chunk::Chunk`)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RerunChunk {
    /// encoder version used to encode the data
    #[prost(enumeration = "EncoderVersion", tag = "1")]
    pub encoder_version: i32,
    /// Data payload is Arrow IPC encoded RecordBatch
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub payload: ::core::option::Option<::prost::bytes::Bytes>,
}
impl ::prost::Name for RerunChunk {
    const NAME: &'static str = "RerunChunk";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.RerunChunk".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.RerunChunk".into()
    }
}
/// uniquely identifies a table
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TableId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
impl ::prost::Name for TableId {
    const NAME: &'static str = "TableId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.TableId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.TableId".into()
    }
}
/// A recording can have multiple timelines, each is identified by a name, for example `log_tick`, `log_time`, etc.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Timeline {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for Timeline {
    const NAME: &'static str = "Timeline";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.Timeline".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.Timeline".into()
    }
}
/// A time range between start and end time points. Each 64 bit number can represent different time point data
/// depending on the timeline it is associated with. Time range is inclusive for both start and end time points.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TimeRange {
    #[prost(int64, tag = "1")]
    pub start: i64,
    #[prost(int64, tag = "2")]
    pub end: i64,
}
impl ::prost::Name for TimeRange {
    const NAME: &'static str = "TimeRange";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.TimeRange".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.TimeRange".into()
    }
}
/// arrow IPC serialized schema
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Schema {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub arrow_schema: ::core::option::Option<::prost::bytes::Bytes>,
}
impl ::prost::Name for Schema {
    const NAME: &'static str = "Schema";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.Schema".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.Schema".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexColumnSelector {
    /// TODO(zehiko) we need to add support for other types of index selectors
    #[prost(message, optional, tag = "1")]
    pub timeline: ::core::option::Option<Timeline>,
}
impl ::prost::Name for IndexColumnSelector {
    const NAME: &'static str = "IndexColumnSelector";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.IndexColumnSelector".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.IndexColumnSelector".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndexRange {
    /// TODO(zehiko) support for other ranges for other index selectors
    #[prost(message, optional, tag = "1")]
    pub time_range: ::core::option::Option<TimeRange>,
}
impl ::prost::Name for IndexRange {
    const NAME: &'static str = "IndexRange";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.IndexRange".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.IndexRange".into()
    }
}
/// The unique identifier of an entity, e.g. `camera/3/points`
/// See <<https://www.rerun.io/docs/concepts/entity-path>> for more on entity paths.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EntityPath {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
impl ::prost::Name for EntityPath {
    const NAME: &'static str = "EntityPath";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.EntityPath".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.EntityPath".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApplicationId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
impl ::prost::Name for ApplicationId {
    const NAME: &'static str = "ApplicationId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.ApplicationId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.ApplicationId".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StoreId {
    /// The kind of the store.
    #[prost(enumeration = "StoreKind", tag = "1")]
    pub kind: i32,
    /// The recording id of the store. For remote stores, this is the segment id. For blueprint store, this is an
    /// arbitrary uuid.
    #[prost(string, tag = "2")]
    pub recording_id: ::prost::alloc::string::String,
    /// User-chosen name of the application doing the logging. For remote stores, this is the dataset entry id.
    #[prost(message, optional, tag = "3")]
    pub application_id: ::core::option::Option<ApplicationId>,
}
impl ::prost::Name for StoreId {
    const NAME: &'static str = "StoreId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.StoreId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.StoreId".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Tuid {
    /// Approximate nanoseconds since epoch.
    #[prost(fixed64, optional, tag = "1")]
    pub time_ns: ::core::option::Option<u64>,
    /// Initialized to something random on each thread, then incremented for each
    /// new `Tuid` being allocated.
    #[prost(fixed64, optional, tag = "2")]
    pub inc: ::core::option::Option<u64>,
}
impl ::prost::Name for Tuid {
    const NAME: &'static str = "Tuid";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.Tuid".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.Tuid".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EntryId {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Tuid>,
}
impl ::prost::Name for EntryId {
    const NAME: &'static str = "EntryId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.EntryId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.EntryId".into()
    }
}
/// Entry point for all ManifestRegistryService APIs
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatasetHandle {
    /// Unique entry identifier (for debug purposes)
    #[prost(message, optional, tag = "1")]
    pub entry_id: ::core::option::Option<EntryId>,
    /// The kind of dataset this handle refers to.
    #[prost(enumeration = "StoreKind", tag = "3")]
    pub store_kind: i32,
    /// Path to Dataset backing storage (e.g. s3://bucket/file or file:///path/to/file)
    #[prost(string, optional, tag = "2")]
    pub dataset_url: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for DatasetHandle {
    const NAME: &'static str = "DatasetHandle";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.DatasetHandle".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.DatasetHandle".into()
    }
}
/// DataframePart is arrow IPC encoded RecordBatch
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DataframePart {
    /// encoder version used to encode the data
    #[prost(enumeration = "EncoderVersion", tag = "1")]
    pub encoder_version: i32,
    /// Data payload is Arrow IPC encoded RecordBatch
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub payload: ::core::option::Option<::prost::bytes::Bytes>,
    /// Compression used.
    ///
    /// This was introduced late in `DataframePart`'s lifetime, and therefore might be unspecified
    /// in many real world recordings out there.
    /// Unspecified is synonymous with uncompressed in this case.
    #[prost(enumeration = "Compression", tag = "3")]
    pub compression: i32,
    /// How large is the uncompressed data?
    ///
    /// The value is undefined if `self.compression == Off`.
    ///
    /// This was introduced late in `DataframePart`'s lifetime, and therefore might be unspecified
    /// in many real world recordings out there (which is fine, because they are all implicitly
    /// using `Compression::Off`).
    #[prost(uint64, tag = "4")]
    pub uncompressed_size: u64,
}
impl ::prost::Name for DataframePart {
    const NAME: &'static str = "DataframePart";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.DataframePart".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.DataframePart".into()
    }
}
/// Generic parameters that will influence the behavior of the Lance scanner.
///
/// TODO(zehiko, cmc): This should be available for every endpoint that queries data in
/// one way or another.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanParameters {
    /// List of columns to project. If empty, all columns will be projected.
    #[prost(string, repeated, tag = "1")]
    pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "IfMissingBehavior", tag = "2")]
    pub on_missing_columns: i32,
    /// An arbitrary filter expression that will be passed to the Lance scanner as-is.
    ///
    /// ```text
    /// scanner.filter(filter)
    /// ```
    #[prost(string, optional, tag = "3")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    /// An arbitrary offset that will be passed to the Lance scanner as-is.
    ///
    /// ```text
    /// scanner.limit(_, limit_offset)
    /// ```
    #[prost(int64, optional, tag = "4")]
    pub limit_offset: ::core::option::Option<i64>,
    /// An arbitrary limit that will be passed to the Lance scanner as-is.
    ///
    /// ```text
    /// scanner.limit(limit_len, _)
    /// ```
    #[prost(int64, optional, tag = "5")]
    pub limit_len: ::core::option::Option<i64>,
    /// An arbitrary order clause that will be passed to the Lance scanner as-is.
    ///
    /// ```text
    /// scanner.order_by(â€¦)
    /// ```
    #[prost(message, repeated, tag = "6")]
    pub order_by: ::prost::alloc::vec::Vec<ScanParametersOrderClause>,
    /// If set, the output of `scanner.explain_plan` will be dumped to the server's log.
    #[prost(bool, tag = "7")]
    pub explain_plan: bool,
    /// If set, the final `scanner.filter` will be dumped to the server's log.
    #[prost(bool, tag = "8")]
    pub explain_filter: bool,
}
impl ::prost::Name for ScanParameters {
    const NAME: &'static str = "ScanParameters";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.ScanParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.ScanParameters".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScanParametersOrderClause {
    #[prost(bool, tag = "1")]
    pub descending: bool,
    #[prost(bool, tag = "2")]
    pub nulls_last: bool,
    #[prost(string, optional, tag = "3")]
    pub column_name: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ScanParametersOrderClause {
    const NAME: &'static str = "ScanParametersOrderClause";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.ScanParametersOrderClause".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.ScanParametersOrderClause".into()
    }
}
/// Unique identifier for a segment. Can be user defined
/// which means it can be of any type. For simplicity we start
/// with a string, but we will probably revisit this.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SegmentId {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for SegmentId {
    const NAME: &'static str = "SegmentId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.SegmentId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.SegmentId".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ComponentDescriptor {
    /// Optional name of the `Archetype` associated with this data.
    #[prost(string, optional, tag = "4")]
    pub archetype: ::core::option::Option<::prost::alloc::string::String>,
    /// Identifier of the field within `Archetype` associated with this data.
    #[prost(string, optional, tag = "5")]
    pub component: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional semantic name associated with this data.
    #[prost(string, optional, tag = "6")]
    pub component_type: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ComponentDescriptor {
    const NAME: &'static str = "ComponentDescriptor";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.ComponentDescriptor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.ComponentDescriptor".into()
    }
}
/// Unique identifier of a task submitted in the redap
/// tasks subsystem
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TaskId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
impl ::prost::Name for TaskId {
    const NAME: &'static str = "TaskId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.TaskId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.TaskId".into()
    }
}
/// Mirrors `re_build_info::BuildInfo`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuildInfo {
    /// `CARGO_PKG_NAME`.
    #[prost(string, optional, tag = "1")]
    pub crate_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Space-separated names of all features enabled for this crate.
    #[prost(string, optional, tag = "2")]
    pub features: ::core::option::Option<::prost::alloc::string::String>,
    /// Crate version, parsed from `CARGO_PKG_VERSION`, ignoring any `+metadata` suffix.
    #[prost(message, optional, tag = "3")]
    pub version: ::core::option::Option<SemanticVersion>,
    /// The raw version string of the Rust compiler used, or an empty string.
    #[prost(string, optional, tag = "4")]
    pub rustc_version: ::core::option::Option<::prost::alloc::string::String>,
    /// The raw version string of the LLVM toolchain used, or an empty string.
    #[prost(string, optional, tag = "5")]
    pub llvm_version: ::core::option::Option<::prost::alloc::string::String>,
    /// Git commit hash, or empty string.
    #[prost(string, optional, tag = "6")]
    pub git_hash: ::core::option::Option<::prost::alloc::string::String>,
    /// Current git branch, or empty string.
    #[prost(string, optional, tag = "7")]
    pub git_branch: ::core::option::Option<::prost::alloc::string::String>,
    /// Target architecture and OS
    ///
    /// Example: `xaarch64-apple-darwin`
    #[prost(string, optional, tag = "8")]
    pub target_triple: ::core::option::Option<::prost::alloc::string::String>,
    /// ISO 8601 / RFC 3339 build time.
    ///
    /// Example: `"2023-02-23T19:33:26Z"`
    ///
    /// Empty if unknown.
    #[prost(string, optional, tag = "9")]
    pub build_time: ::core::option::Option<::prost::alloc::string::String>,
    /// / True if this is a debug build.
    #[prost(bool, optional, tag = "10")]
    pub is_debug_build: ::core::option::Option<bool>,
}
impl ::prost::Name for BuildInfo {
    const NAME: &'static str = "BuildInfo";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.BuildInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.BuildInfo".into()
    }
}
/// Mirrors `re_build_info::CrateVersion`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SemanticVersion {
    #[prost(fixed32, optional, tag = "1")]
    pub major: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "2")]
    pub minor: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "3")]
    pub patch: ::core::option::Option<u32>,
    #[prost(oneof = "semantic_version::Meta", tags = "4, 5, 6")]
    pub meta: ::core::option::Option<semantic_version::Meta>,
}
/// Nested message and enum types in `SemanticVersion`.
pub mod semantic_version {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Meta {
        #[prost(fixed32, tag = "4")]
        Rc(u32),
        #[prost(fixed32, tag = "5")]
        Alpha(u32),
        #[prost(message, tag = "6")]
        DevAlpha(super::DevAlpha),
    }
}
impl ::prost::Name for SemanticVersion {
    const NAME: &'static str = "SemanticVersion";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.SemanticVersion".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.SemanticVersion".into()
    }
}
/// Mirrors `re_build_info::DevAlpha`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DevAlpha {
    #[prost(fixed32, optional, tag = "1")]
    pub alpha: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub commit: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for DevAlpha {
    const NAME: &'static str = "DevAlpha";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.DevAlpha".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.DevAlpha".into()
    }
}
/// The type of compression used on the payload.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Compression {
    Unspecified = 0,
    /// No compression.
    None = 1,
    /// LZ4 block compression.
    Lz4 = 2,
}
impl Compression {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMPRESSION_UNSPECIFIED",
            Self::None => "COMPRESSION_NONE",
            Self::Lz4 => "COMPRESSION_LZ4",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPRESSION_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPRESSION_NONE" => Some(Self::None),
            "COMPRESSION_LZ4" => Some(Self::Lz4),
            _ => None,
        }
    }
}
/// supported encoder versions for encoding data
/// See `RerunData` and `RerunChunkData` for its usage
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EncoderVersion {
    Unspecified = 0,
    V0 = 1,
}
impl EncoderVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENCODER_VERSION_UNSPECIFIED",
            Self::V0 => "ENCODER_VERSION_V0",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODER_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "ENCODER_VERSION_V0" => Some(Self::V0),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StoreKind {
    Unspecified = 0,
    Recording = 1,
    Blueprint = 2,
}
impl StoreKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STORE_KIND_UNSPECIFIED",
            Self::Recording => "STORE_KIND_RECORDING",
            Self::Blueprint => "STORE_KIND_BLUEPRINT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORE_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "STORE_KIND_RECORDING" => Some(Self::Recording),
            "STORE_KIND_BLUEPRINT" => Some(Self::Blueprint),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IfMissingBehavior {
    Unspecified = 0,
    Skip = 1,
    Error = 2,
}
impl IfMissingBehavior {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "IF_MISSING_BEHAVIOR_UNSPECIFIED",
            Self::Skip => "IF_MISSING_BEHAVIOR_SKIP",
            Self::Error => "IF_MISSING_BEHAVIOR_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IF_MISSING_BEHAVIOR_UNSPECIFIED" => Some(Self::Unspecified),
            "IF_MISSING_BEHAVIOR_SKIP" => Some(Self::Skip),
            "IF_MISSING_BEHAVIOR_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Specify how the relevant creation call behaves
/// in case of previously created (duplicate) items
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IfDuplicateBehavior {
    Unspecified = 0,
    /// Overwrite the existing item
    Overwrite = 1,
    /// Skip if the item already exists
    Skip = 2,
    /// Return an error if the item already exists
    Error = 3,
}
impl IfDuplicateBehavior {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "IF_DUPLICATE_BEHAVIOR_UNSPECIFIED",
            Self::Overwrite => "IF_DUPLICATE_BEHAVIOR_OVERWRITE",
            Self::Skip => "IF_DUPLICATE_BEHAVIOR_SKIP",
            Self::Error => "IF_DUPLICATE_BEHAVIOR_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IF_DUPLICATE_BEHAVIOR_UNSPECIFIED" => Some(Self::Unspecified),
            "IF_DUPLICATE_BEHAVIOR_OVERWRITE" => Some(Self::Overwrite),
            "IF_DUPLICATE_BEHAVIOR_SKIP" => Some(Self::Skip),
            "IF_DUPLICATE_BEHAVIOR_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
