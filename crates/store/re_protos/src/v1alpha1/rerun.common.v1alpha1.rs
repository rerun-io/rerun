// This file is @generated by prost-build.
/// RerunChunk is arrow IPC encoded RecordBatch that has
/// rerun-specific semantic constraints and can be directly
/// converted to a Rerun Chunk (`re_chunk::Chunk`)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RerunChunk {
    /// encoder version used to encode the data
    #[prost(enumeration = "EncoderVersion", tag = "1")]
    pub encoder_version: i32,
    /// Data payload is Arrow IPC encoded RecordBatch
    /// TODO(zehiko) make this optional (#9285)
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for RerunChunk {
    const NAME: &'static str = "RerunChunk";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.RerunChunk".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.RerunChunk".into()
    }
}
/// uniquely identifies a table
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
impl ::prost::Name for TableId {
    const NAME: &'static str = "TableId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.TableId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.TableId".into()
    }
}
/// A recording can have multiple timelines, each is identified by a name, for example `log_tick`, `log_time`, etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Timeline {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for Timeline {
    const NAME: &'static str = "Timeline";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.Timeline".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.Timeline".into()
    }
}
/// A time range between start and end time points. Each 64 bit number can represent different time point data
/// depending on the timeline it is associated with. Time range is inclusive for both start and end time points.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeRange {
    #[prost(int64, tag = "1")]
    pub start: i64,
    #[prost(int64, tag = "2")]
    pub end: i64,
}
impl ::prost::Name for TimeRange {
    const NAME: &'static str = "TimeRange";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.TimeRange".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.TimeRange".into()
    }
}
/// arrow IPC serialized schema
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub arrow_schema: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
impl ::prost::Name for Schema {
    const NAME: &'static str = "Schema";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.Schema".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.Schema".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexColumnSelector {
    /// TODO(zehiko) we need to add support for other types of index selectors
    #[prost(message, optional, tag = "1")]
    pub timeline: ::core::option::Option<Timeline>,
}
impl ::prost::Name for IndexColumnSelector {
    const NAME: &'static str = "IndexColumnSelector";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.IndexColumnSelector".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.IndexColumnSelector".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexRange {
    /// TODO(zehiko) support for other ranges for other index selectors
    #[prost(message, optional, tag = "1")]
    pub time_range: ::core::option::Option<TimeRange>,
}
impl ::prost::Name for IndexRange {
    const NAME: &'static str = "IndexRange";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.IndexRange".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.IndexRange".into()
    }
}
/// The unique identifier of an entity, e.g. `camera/3/points`
/// See <<https://www.rerun.io/docs/concepts/entity-path>> for more on entity paths.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityPath {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
impl ::prost::Name for EntityPath {
    const NAME: &'static str = "EntityPath";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.EntityPath".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.EntityPath".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
impl ::prost::Name for ApplicationId {
    const NAME: &'static str = "ApplicationId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.ApplicationId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.ApplicationId".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreId {
    #[prost(enumeration = "StoreKind", tag = "1")]
    pub kind: i32,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
impl ::prost::Name for StoreId {
    const NAME: &'static str = "StoreId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.StoreId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.StoreId".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Tuid {
    /// Approximate nanoseconds since epoch.
    #[prost(fixed64, optional, tag = "1")]
    pub time_ns: ::core::option::Option<u64>,
    /// Initialized to something random on each thread, then incremented for each
    /// new `Tuid` being allocated.
    #[prost(fixed64, optional, tag = "2")]
    pub inc: ::core::option::Option<u64>,
}
impl ::prost::Name for Tuid {
    const NAME: &'static str = "Tuid";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.Tuid".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.Tuid".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EntryId {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Tuid>,
}
impl ::prost::Name for EntryId {
    const NAME: &'static str = "EntryId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.EntryId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.EntryId".into()
    }
}
/// Entry point for all ManifestRegistryService APIs
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatasetHandle {
    /// Unique entry identifier (for debug purposes)
    #[prost(message, optional, tag = "1")]
    pub entry_id: ::core::option::Option<EntryId>,
    /// The kind of dateset this handle refers to.
    #[prost(enumeration = "StoreKind", tag = "3")]
    pub store_kind: i32,
    /// Path to Dataset backing storage (e.g. s3://bucket/file or file:///path/to/file)
    #[prost(string, optional, tag = "2")]
    pub dataset_url: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for DatasetHandle {
    const NAME: &'static str = "DatasetHandle";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.DatasetHandle".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.DatasetHandle".into()
    }
}
/// DataframePart is arrow IPC encoded RecordBatch
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataframePart {
    /// encoder version used to encode the data
    #[prost(enumeration = "EncoderVersion", tag = "1")]
    pub encoder_version: i32,
    /// Data payload is Arrow IPC encoded RecordBatch
    #[prost(bytes = "vec", optional, tag = "2")]
    pub payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
impl ::prost::Name for DataframePart {
    const NAME: &'static str = "DataframePart";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.DataframePart".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.DataframePart".into()
    }
}
/// Generic parameters that will influence the behavior of the Lance scanner.
///
/// TODO(zehiko, cmc): This should be available for every endpoint that queries data in
/// one way or another.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanParameters {
    /// List of columns to project. If empty, all columns will be projected.
    #[prost(string, repeated, tag = "1")]
    pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "IfMissingBehavior", tag = "2")]
    pub on_missing_columns: i32,
    /// An arbitrary filter expression that will be passed to the Lance scanner as-is.
    ///
    /// ```text
    /// scanner.filter(filter)
    /// ```
    #[prost(string, optional, tag = "3")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    /// An arbitrary offset that will be passed to the Lance scanner as-is.
    ///
    /// ```text
    /// scanner.limit(_, limit_offset)
    /// ```
    #[prost(int64, optional, tag = "4")]
    pub limit_offset: ::core::option::Option<i64>,
    /// An arbitrary limit that will be passed to the Lance scanner as-is.
    ///
    /// ```text
    /// scanner.limit(limit_len, _)
    /// ```
    #[prost(int64, optional, tag = "5")]
    pub limit_len: ::core::option::Option<i64>,
    /// An arbitrary order clause that will be passed to the Lance scanner as-is.
    ///
    /// ```text
    /// scanner.order_by(â€¦)
    /// ```
    #[prost(message, optional, tag = "6")]
    pub order_by: ::core::option::Option<ScanParametersOrderClause>,
    /// If set, the output of `scanner.explain_plan` will be dumped to the server's log.
    #[prost(bool, tag = "7")]
    pub explain_plan: bool,
    /// If set, the final `scanner.filter` will be dumped to the server's log.
    #[prost(bool, tag = "8")]
    pub explain_filter: bool,
}
impl ::prost::Name for ScanParameters {
    const NAME: &'static str = "ScanParameters";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.ScanParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.ScanParameters".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanParametersOrderClause {
    #[prost(bool, tag = "1")]
    pub descending: bool,
    #[prost(bool, tag = "2")]
    pub nulls_last: bool,
    #[prost(string, optional, tag = "3")]
    pub column_name: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ScanParametersOrderClause {
    const NAME: &'static str = "ScanParametersOrderClause";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.ScanParametersOrderClause".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.ScanParametersOrderClause".into()
    }
}
/// Unique identifier for a partition. Can be user defined
/// which means it can be of any type. For simplicity we start
/// with a string, but we will probably revisit this.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionId {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for PartitionId {
    const NAME: &'static str = "PartitionId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.PartitionId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.PartitionId".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComponentDescriptor {
    /// Optional name of the `Archetype` associated with this data.
    #[prost(string, optional, tag = "1")]
    pub archetype_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional name of the field within `Archetype` associated with this data.
    #[prost(string, optional, tag = "2")]
    pub archetype_field_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Semantic name associated with this data.
    #[prost(string, optional, tag = "3")]
    pub component_name: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ComponentDescriptor {
    const NAME: &'static str = "ComponentDescriptor";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.ComponentDescriptor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.ComponentDescriptor".into()
    }
}
/// Unique identifier of a task submitted in the redap
/// tasks subsystem
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
impl ::prost::Name for TaskId {
    const NAME: &'static str = "TaskId";
    const PACKAGE: &'static str = "rerun.common.v1alpha1";
    fn full_name() -> ::prost::alloc::string::String {
        "rerun.common.v1alpha1.TaskId".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/rerun.common.v1alpha1.TaskId".into()
    }
}
/// supported encoder versions for encoding data
/// See `RerunData` and `RerunChunkData` for its usage
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EncoderVersion {
    Unspecified = 0,
    V0 = 1,
}
impl EncoderVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENCODER_VERSION_UNSPECIFIED",
            Self::V0 => "ENCODER_VERSION_V0",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODER_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "ENCODER_VERSION_V0" => Some(Self::V0),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StoreKind {
    Unspecified = 0,
    Recording = 1,
    Blueprint = 2,
}
impl StoreKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STORE_KIND_UNSPECIFIED",
            Self::Recording => "STORE_KIND_RECORDING",
            Self::Blueprint => "STORE_KIND_BLUEPRINT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORE_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "STORE_KIND_RECORDING" => Some(Self::Recording),
            "STORE_KIND_BLUEPRINT" => Some(Self::Blueprint),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IfMissingBehavior {
    Unspecified = 0,
    Skip = 1,
    Error = 2,
}
impl IfMissingBehavior {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "IF_MISSING_BEHAVIOR_UNSPECIFIED",
            Self::Skip => "IF_MISSING_BEHAVIOR_SKIP",
            Self::Error => "IF_MISSING_BEHAVIOR_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IF_MISSING_BEHAVIOR_UNSPECIFIED" => Some(Self::Unspecified),
            "IF_MISSING_BEHAVIOR_SKIP" => Some(Self::Skip),
            "IF_MISSING_BEHAVIOR_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Specify how the relevant creation call behaves
/// in case of previously created (duplicate) items
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IfDuplicateBehavior {
    Unspecified = 0,
    /// Overwrite the existing item
    Overwrite = 1,
    /// Skip if the item already exists
    Skip = 2,
    /// Return an error if the item already exists
    Error = 3,
}
impl IfDuplicateBehavior {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "IF_DUPLICATE_BEHAVIOR_UNSPECIFIED",
            Self::Overwrite => "IF_DUPLICATE_BEHAVIOR_OVERWRITE",
            Self::Skip => "IF_DUPLICATE_BEHAVIOR_SKIP",
            Self::Error => "IF_DUPLICATE_BEHAVIOR_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IF_DUPLICATE_BEHAVIOR_UNSPECIFIED" => Some(Self::Unspecified),
            "IF_DUPLICATE_BEHAVIOR_OVERWRITE" => Some(Self::Overwrite),
            "IF_DUPLICATE_BEHAVIOR_SKIP" => Some(Self::Skip),
            "IF_DUPLICATE_BEHAVIOR_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
