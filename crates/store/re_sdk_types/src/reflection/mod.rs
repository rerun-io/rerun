// DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/rust/reflection.rs

#![allow(clippy::allow_attributes)]
#![allow(clippy::empty_line_after_doc_comments)]
#![allow(clippy::too_many_lines)]
#![allow(clippy::wildcard_imports)]
#![allow(unused_imports)]

use crate::blueprint::components::*;
use crate::components::*;
use re_types_core::components::*;
use re_types_core::{
    ArchetypeName, Component, ComponentBatch as _, ComponentType, Loggable as _,
    SerializationError,
    reflection::{
        ArchetypeFieldReflection, ArchetypeReflection, ArchetypeReflectionMap, ComponentReflection,
        ComponentReflectionMap, Reflection, generate_component_identifier_reflection,
    },
};

/// Generates reflection about all known components.
///
/// Call only once and reuse the results.

pub fn generate_reflection() -> Result<Reflection, SerializationError> {
    re_tracing::profile_function!();
    let archetypes = generate_archetype_reflection();
    Ok(Reflection {
        components: generate_component_reflection()?,
        component_identifiers: generate_component_identifier_reflection(&archetypes),
        archetypes,
    })
}

/// Generates reflection about all known components.
///
/// Call only once and reuse the results.

fn generate_component_reflection() -> Result<ComponentReflectionMap, SerializationError> {
    re_tracing::profile_function!();
    let array = [
        (
            <AbsoluteTimeRange as Component>::name(),
            ComponentReflection {
                docstring_md: "A reference to a range of time.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: AbsoluteTimeRange::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: AbsoluteTimeRange::verify_arrow_array,
            },
        ),
        (
            <ActiveTab as Component>::name(),
            ComponentReflection {
                docstring_md: "The active tab in a tabbed container.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ActiveTab::default().to_arrow()?),
                datatype: ActiveTab::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ActiveTab::verify_arrow_array,
            },
        ),
        (
            <AngularSpeed as Component>::name(),
            ComponentReflection {
                docstring_md: "Angular speed, used for rotation speed for example.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(AngularSpeed::default().to_arrow()?),
                datatype: AngularSpeed::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: AngularSpeed::verify_arrow_array,
            },
        ),
        (
            <ApplyLatestAt as Component>::name(),
            ComponentReflection {
                docstring_md: "Whether empty cells in a dataframe should be filled with a latest-at query.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ApplyLatestAt::default().to_arrow()?),
                datatype: ApplyLatestAt::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ApplyLatestAt::verify_arrow_array,
            },
        ),
        (
            <AutoLayout as Component>::name(),
            ComponentReflection {
                docstring_md: "Whether the viewport layout is determined automatically.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(AutoLayout::default().to_arrow()?),
                datatype: AutoLayout::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: AutoLayout::verify_arrow_array,
            },
        ),
        (
            <AutoViews as Component>::name(),
            ComponentReflection {
                docstring_md: "Whether or not views should be created automatically.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(AutoViews::default().to_arrow()?),
                datatype: AutoViews::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: AutoViews::verify_arrow_array,
            },
        ),
        (
            <BackgroundKind as Component>::name(),
            ComponentReflection {
                docstring_md: "The type of the background in a view.",
                deprecation_summary: None,
                custom_placeholder: Some(BackgroundKind::default().to_arrow()?),
                datatype: BackgroundKind::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: BackgroundKind::verify_arrow_array,
            },
        ),
        (
            <ColumnShare as Component>::name(),
            ComponentReflection {
                docstring_md: "The layout share of a column in the container.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ColumnShare::default().to_arrow()?),
                datatype: ColumnShare::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ColumnShare::verify_arrow_array,
            },
        ),
        (
            <ComponentColumnSelector as Component>::name(),
            ComponentReflection {
                docstring_md: "Describe a component column to be selected in the dataframe view.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ComponentColumnSelector::default().to_arrow()?),
                datatype: ComponentColumnSelector::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ComponentColumnSelector::verify_arrow_array,
            },
        ),
        (
            <ContainerKind as Component>::name(),
            ComponentReflection {
                docstring_md: "The kind of a blueprint container (tabs, grid, …).",
                deprecation_summary: None,
                custom_placeholder: Some(ContainerKind::default().to_arrow()?),
                datatype: ContainerKind::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: ContainerKind::verify_arrow_array,
            },
        ),
        (
            <Corner2D as Component>::name(),
            ComponentReflection {
                docstring_md: "One of four 2D corners, typically used to align objects.",
                deprecation_summary: None,
                custom_placeholder: Some(Corner2D::default().to_arrow()?),
                datatype: Corner2D::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: Corner2D::verify_arrow_array,
            },
        ),
        (
            <Enabled as Component>::name(),
            ComponentReflection {
                docstring_md: "Whether a procedure is enabled.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(Enabled::default().to_arrow()?),
                datatype: Enabled::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Enabled::verify_arrow_array,
            },
        ),
        (
            <Eye3DKind as Component>::name(),
            ComponentReflection {
                docstring_md: "The kind of the 3D eye to view a scene in a [`views.Spatial3DView`](https://rerun.io/docs/reference/types/views/spatial3d_view).\n\nThis is used to specify how the controls of the view react to user input (such as mouse gestures).",
                deprecation_summary: None,
                custom_placeholder: Some(Eye3DKind::default().to_arrow()?),
                datatype: Eye3DKind::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: Eye3DKind::verify_arrow_array,
            },
        ),
        (
            <FilterByRange as Component>::name(),
            ComponentReflection {
                docstring_md: "Configuration for a filter-by-range feature of the dataframe view.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(FilterByRange::default().to_arrow()?),
                datatype: FilterByRange::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: FilterByRange::verify_arrow_array,
            },
        ),
        (
            <FilterIsNotNull as Component>::name(),
            ComponentReflection {
                docstring_md: "Configuration for the filter is not null feature of the dataframe view.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(FilterIsNotNull::default().to_arrow()?),
                datatype: FilterIsNotNull::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: FilterIsNotNull::verify_arrow_array,
            },
        ),
        (
            <ForceDistance as Component>::name(),
            ComponentReflection {
                docstring_md: "The target distance between two nodes.\n\nThis is helpful to scale the layout, for example if long labels are involved.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ForceDistance::default().to_arrow()?),
                datatype: ForceDistance::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ForceDistance::verify_arrow_array,
            },
        ),
        (
            <ForceIterations as Component>::name(),
            ComponentReflection {
                docstring_md: "Specifies how often this force should be applied per iteration.\n\nIncreasing this parameter can lead to better results at the cost of longer computation time.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ForceIterations::default().to_arrow()?),
                datatype: ForceIterations::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ForceIterations::verify_arrow_array,
            },
        ),
        (
            <ForceStrength as Component>::name(),
            ComponentReflection {
                docstring_md: "The strength of a given force.\n\nAllows to assign different weights to the individual forces, prioritizing one over the other.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ForceStrength::default().to_arrow()?),
                datatype: ForceStrength::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ForceStrength::verify_arrow_array,
            },
        ),
        (
            <Fps as Component>::name(),
            ComponentReflection {
                docstring_md: "Frames per second for a sequence timeline.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: Fps::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Fps::verify_arrow_array,
            },
        ),
        (
            <GridColumns as Component>::name(),
            ComponentReflection {
                docstring_md: "How many columns a grid container should have.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(GridColumns::default().to_arrow()?),
                datatype: GridColumns::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: GridColumns::verify_arrow_array,
            },
        ),
        (
            <GridSpacing as Component>::name(),
            ComponentReflection {
                docstring_md: "Space between grid lines of one line to the next in scene units.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(GridSpacing::default().to_arrow()?),
                datatype: GridSpacing::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: GridSpacing::verify_arrow_array,
            },
        ),
        (
            <IncludedContent as Component>::name(),
            ComponentReflection {
                docstring_md: "All the contents in the container.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(IncludedContent::default().to_arrow()?),
                datatype: IncludedContent::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: IncludedContent::verify_arrow_array,
            },
        ),
        (
            <LinkAxis as Component>::name(),
            ComponentReflection {
                docstring_md: "How should the horizontal/X/time axis be linked across multiple plots",
                deprecation_summary: None,
                custom_placeholder: Some(LinkAxis::default().to_arrow()?),
                datatype: LinkAxis::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: LinkAxis::verify_arrow_array,
            },
        ),
        (
            <LockRangeDuringZoom as Component>::name(),
            ComponentReflection {
                docstring_md: "Indicate whether the range should be locked when zooming in on the data.\n\nDefault is `false`, i.e. zoom will change the visualized range.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(LockRangeDuringZoom::default().to_arrow()?),
                datatype: LockRangeDuringZoom::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: LockRangeDuringZoom::verify_arrow_array,
            },
        ),
        (
            <LoopMode as Component>::name(),
            ComponentReflection {
                docstring_md: "If playing, whether and how the playback time should loop.",
                deprecation_summary: None,
                custom_placeholder: Some(LoopMode::default().to_arrow()?),
                datatype: LoopMode::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: LoopMode::verify_arrow_array,
            },
        ),
        (
            <MapProvider as Component>::name(),
            ComponentReflection {
                docstring_md: "Name of the map provider to be used in Map views.",
                deprecation_summary: None,
                custom_placeholder: Some(MapProvider::default().to_arrow()?),
                datatype: MapProvider::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: MapProvider::verify_arrow_array,
            },
        ),
        (
            <NearClipPlane as Component>::name(),
            ComponentReflection {
                docstring_md: "Distance to the near clip plane used for `Spatial2DView`.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(NearClipPlane::default().to_arrow()?),
                datatype: NearClipPlane::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: NearClipPlane::verify_arrow_array,
            },
        ),
        (
            <PanelState as Component>::name(),
            ComponentReflection {
                docstring_md: "Tri-state for panel controls.",
                deprecation_summary: None,
                custom_placeholder: Some(PanelState::default().to_arrow()?),
                datatype: PanelState::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: PanelState::verify_arrow_array,
            },
        ),
        (
            <PlayState as Component>::name(),
            ComponentReflection {
                docstring_md: "The current play state.",
                deprecation_summary: None,
                custom_placeholder: Some(PlayState::default().to_arrow()?),
                datatype: PlayState::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: PlayState::verify_arrow_array,
            },
        ),
        (
            <PlaybackSpeed as Component>::name(),
            ComponentReflection {
                docstring_md: "A playback speed which determines how fast time progresses.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: PlaybackSpeed::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: PlaybackSpeed::verify_arrow_array,
            },
        ),
        (
            <QueryExpression as Component>::name(),
            ComponentReflection {
                docstring_md: "An individual query expression used to filter a set of [`datatypes.EntityPath`](https://rerun.io/docs/reference/types/datatypes/entity_path)s.\n\nEach expression is either an inclusion or an exclusion expression.\nInclusions start with an optional `+` and exclusions must start with a `-`.\n\nMultiple expressions are combined together as part of archetypes.ViewContents.\n\nThe `/**` suffix matches the whole subtree, i.e. self and any child, recursively\n(`/world/**` matches both `/world` and `/world/car/driver`).\nOther uses of `*` are not (yet) supported.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(QueryExpression::default().to_arrow()?),
                datatype: QueryExpression::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: QueryExpression::verify_arrow_array,
            },
        ),
        (
            <RootContainer as Component>::name(),
            ComponentReflection {
                docstring_md: "The container that sits at the root of a viewport.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(RootContainer::default().to_arrow()?),
                datatype: RootContainer::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: RootContainer::verify_arrow_array,
            },
        ),
        (
            <RowShare as Component>::name(),
            ComponentReflection {
                docstring_md: "The layout share of a row in the container.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(RowShare::default().to_arrow()?),
                datatype: RowShare::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: RowShare::verify_arrow_array,
            },
        ),
        (
            <SelectedColumns as Component>::name(),
            ComponentReflection {
                docstring_md: "Describe a component column to be selected in the dataframe view.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(SelectedColumns::default().to_arrow()?),
                datatype: SelectedColumns::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: SelectedColumns::verify_arrow_array,
            },
        ),
        (
            <TensorDimensionIndexSlider as Component>::name(),
            ComponentReflection {
                docstring_md: "Show a slider for the index of some dimension of a slider.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(TensorDimensionIndexSlider::default().to_arrow()?),
                datatype: TensorDimensionIndexSlider::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TensorDimensionIndexSlider::verify_arrow_array,
            },
        ),
        (
            <TextLogColumn as Component>::name(),
            ComponentReflection {
                docstring_md: "A text log column\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(TextLogColumn::default().to_arrow()?),
                datatype: TextLogColumn::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TextLogColumn::verify_arrow_array,
            },
        ),
        (
            <TimeInt as Component>::name(),
            ComponentReflection {
                docstring_md: "A reference to a time.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: TimeInt::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TimeInt::verify_arrow_array,
            },
        ),
        (
            <TimeRange as Component>::name(),
            ComponentReflection {
                docstring_md: "A time range on an unspecified timeline using either relative or absolute boundaries.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: TimeRange::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TimeRange::verify_arrow_array,
            },
        ),
        (
            <TimelineColumn as Component>::name(),
            ComponentReflection {
                docstring_md: "A timeline column in a text log table.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(TimelineColumn::default().to_arrow()?),
                datatype: TimelineColumn::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TimelineColumn::verify_arrow_array,
            },
        ),
        (
            <TimelineName as Component>::name(),
            ComponentReflection {
                docstring_md: "A timeline identified by its name.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(TimelineName::default().to_arrow()?),
                datatype: TimelineName::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TimelineName::verify_arrow_array,
            },
        ),
        (
            <ViewClass as Component>::name(),
            ComponentReflection {
                docstring_md: "The class identifier of view, e.g. `\"2D\"`, `\"TextLog\"`, ….\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ViewClass::default().to_arrow()?),
                datatype: ViewClass::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ViewClass::verify_arrow_array,
            },
        ),
        (
            <ViewFit as Component>::name(),
            ComponentReflection {
                docstring_md: "Determines whether an image or texture should be scaled to fit the viewport.",
                deprecation_summary: None,
                custom_placeholder: Some(ViewFit::default().to_arrow()?),
                datatype: ViewFit::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: ViewFit::verify_arrow_array,
            },
        ),
        (
            <ViewMaximized as Component>::name(),
            ComponentReflection {
                docstring_md: "Whether a view is maximized.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ViewMaximized::default().to_arrow()?),
                datatype: ViewMaximized::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ViewMaximized::verify_arrow_array,
            },
        ),
        (
            <ViewOrigin as Component>::name(),
            ComponentReflection {
                docstring_md: "The origin of a view.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ViewOrigin::default().to_arrow()?),
                datatype: ViewOrigin::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ViewOrigin::verify_arrow_array,
            },
        ),
        (
            <ViewerRecommendationHash as Component>::name(),
            ComponentReflection {
                docstring_md: "Hash of a viewer recommendation.\n\nThe formation of this hash is considered an internal implementation detail of the viewer.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ViewerRecommendationHash::default().to_arrow()?),
                datatype: ViewerRecommendationHash::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ViewerRecommendationHash::verify_arrow_array,
            },
        ),
        (
            <VisibleTimeRange as Component>::name(),
            ComponentReflection {
                docstring_md: "The range of values on a given timeline that will be included in a view's query.\n\nRefer to `VisibleTimeRanges` archetype for more information.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(VisibleTimeRange::default().to_arrow()?),
                datatype: VisibleTimeRange::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: VisibleTimeRange::verify_arrow_array,
            },
        ),
        (
            <VisualBounds2D as Component>::name(),
            ComponentReflection {
                docstring_md: "Visual bounds in 2D space used for `Spatial2DView`.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(VisualBounds2D::default().to_arrow()?),
                datatype: VisualBounds2D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: VisualBounds2D::verify_arrow_array,
            },
        ),
        (
            <VisualizerComponentMapping as Component>::name(),
            ComponentReflection {
                docstring_md: "Associates components of an entity to components of a visualizer.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: VisualizerComponentMapping::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: VisualizerComponentMapping::verify_arrow_array,
            },
        ),
        (
            <VisualizerInstructionId as Component>::name(),
            ComponentReflection {
                docstring_md: "ID for a visualizer instruction.\n\nIDs are only guaranteed to be unique in the scope of a view.\nFor details see archetypes.ActiveVisualizers.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(VisualizerInstructionId::default().to_arrow()?),
                datatype: VisualizerInstructionId::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: VisualizerInstructionId::verify_arrow_array,
            },
        ),
        (
            <VisualizerType as Component>::name(),
            ComponentReflection {
                docstring_md: "The type of the visualizer.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(VisualizerType::default().to_arrow()?),
                datatype: VisualizerType::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: VisualizerType::verify_arrow_array,
            },
        ),
        (
            <ZoomLevel as Component>::name(),
            ComponentReflection {
                docstring_md: "A zoom level determines how much of the world is visible on a map.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ZoomLevel::default().to_arrow()?),
                datatype: ZoomLevel::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ZoomLevel::verify_arrow_array,
            },
        ),
        (
            <AggregationPolicy as Component>::name(),
            ComponentReflection {
                docstring_md: "Policy for aggregation of multiple scalar plot values.\n\nThis is used for lines in plots when the X axis distance of individual points goes below a single pixel,\ni.e. a single pixel covers more than one tick worth of data. It can greatly improve performance\n(and readability) in such situations as it prevents overdraw.",
                deprecation_summary: None,
                custom_placeholder: Some(AggregationPolicy::default().to_arrow()?),
                datatype: AggregationPolicy::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: AggregationPolicy::verify_arrow_array,
            },
        ),
        (
            <AlbedoFactor as Component>::name(),
            ComponentReflection {
                docstring_md: "A color multiplier, usually applied to a whole entity, e.g. a mesh.",
                deprecation_summary: None,
                custom_placeholder: Some(AlbedoFactor::default().to_arrow()?),
                datatype: AlbedoFactor::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: AlbedoFactor::verify_arrow_array,
            },
        ),
        (
            <AnnotationContext as Component>::name(),
            ComponentReflection {
                docstring_md: "The annotation context provides additional information on how to display entities.\n\nEntities can use [`datatypes.ClassId`](https://rerun.io/docs/reference/types/datatypes/class_id)s and [`datatypes.KeypointId`](https://rerun.io/docs/reference/types/datatypes/keypoint_id)s to provide annotations, and\nthe labels and colors will be looked up in the appropriate\nannotation context. We use the *first* annotation context we find in the\npath-hierarchy when searching up through the ancestors of a given entity\npath.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(AnnotationContext::default().to_arrow()?),
                datatype: AnnotationContext::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: AnnotationContext::verify_arrow_array,
            },
        ),
        (
            <AxisLength as Component>::name(),
            ComponentReflection {
                docstring_md: "The length of an axis in local units of the space.",
                deprecation_summary: None,
                custom_placeholder: Some(AxisLength::default().to_arrow()?),
                datatype: AxisLength::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: AxisLength::verify_arrow_array,
            },
        ),
        (
            <Blob as Component>::name(),
            ComponentReflection {
                docstring_md: "A binary blob of data.",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: Blob::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Blob::verify_arrow_array,
            },
        ),
        (
            <ChannelId as Component>::name(),
            ComponentReflection {
                docstring_md: "A 16-bit ID representing an MCAP channel.\n\nUsed to identify specific channels within an MCAP file.",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: ChannelId::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ChannelId::verify_arrow_array,
            },
        ),
        (
            <ChannelMessageCounts as Component>::name(),
            ComponentReflection {
                docstring_md: "A mapping of channel IDs to their respective message counts.\n\nUsed in MCAP statistics to track how many messages were recorded per channel.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ChannelMessageCounts::default().to_arrow()?),
                datatype: ChannelMessageCounts::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ChannelMessageCounts::verify_arrow_array,
            },
        ),
        (
            <ClassId as Component>::name(),
            ComponentReflection {
                docstring_md: "A 16-bit ID representing a type of semantic class.",
                deprecation_summary: None,
                custom_placeholder: Some(ClassId::default().to_arrow()?),
                datatype: ClassId::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ClassId::verify_arrow_array,
            },
        ),
        (
            <ClearIsRecursive as Component>::name(),
            ComponentReflection {
                docstring_md: "Configures how a clear operation should behave - recursive or not.",
                deprecation_summary: None,
                custom_placeholder: Some(ClearIsRecursive::default().to_arrow()?),
                datatype: ClearIsRecursive::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ClearIsRecursive::verify_arrow_array,
            },
        ),
        (
            <Color as Component>::name(),
            ComponentReflection {
                docstring_md: "An RGBA color with unmultiplied/separate alpha, in sRGB gamma space with linear alpha.\n\nThe color is stored as a 32-bit integer, where the most significant\nbyte is `R` and the least significant byte is `A`.",
                deprecation_summary: None,
                custom_placeholder: Some(Color::default().to_arrow()?),
                datatype: Color::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Color::verify_arrow_array,
            },
        ),
        (
            <Colormap as Component>::name(),
            ComponentReflection {
                docstring_md: "Colormap for mapping scalar values within a given range to a color.\n\nThis provides a number of popular pre-defined colormaps.\nIn the future, the Rerun Viewer will allow users to define their own colormaps,\nbut currently the Viewer is limited to the types defined here.",
                deprecation_summary: None,
                custom_placeholder: Some(Colormap::default().to_arrow()?),
                datatype: Colormap::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: Colormap::verify_arrow_array,
            },
        ),
        (
            <Count as Component>::name(),
            ComponentReflection {
                docstring_md: "A generic count value.\n\nUsed for counting various entities like messages, schemas, channels, etc.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: Count::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Count::verify_arrow_array,
            },
        ),
        (
            <DepthMeter as Component>::name(),
            ComponentReflection {
                docstring_md: "The world->depth map scaling factor.\n\nThis measures how many depth map units are in a world unit.\nFor instance, if a depth map uses millimeters and the world uses meters,\nthis value would be `1000`.\n\nNote that the only effect on 2D views is the physical depth values shown when hovering the image.\nIn 3D views on the other hand, this affects where the points of the point cloud are placed.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(DepthMeter::default().to_arrow()?),
                datatype: DepthMeter::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: DepthMeter::verify_arrow_array,
            },
        ),
        (
            <DrawOrder as Component>::name(),
            ComponentReflection {
                docstring_md: "Draw order of 2D elements. Higher values are drawn on top of lower values.\n\nAn entity can have only a single draw order component.\nWithin an entity draw order is governed by the order of the components.\n\nDraw order for entities with the same draw order is generally undefined.",
                deprecation_summary: None,
                custom_placeholder: Some(DrawOrder::default().to_arrow()?),
                datatype: DrawOrder::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: DrawOrder::verify_arrow_array,
            },
        ),
        (
            <EntityPath as Component>::name(),
            ComponentReflection {
                docstring_md: "A path to an entity, usually to reference some data that is part of the target entity.",
                deprecation_summary: None,
                custom_placeholder: Some(EntityPath::default().to_arrow()?),
                datatype: EntityPath::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: EntityPath::verify_arrow_array,
            },
        ),
        (
            <FillMode as Component>::name(),
            ComponentReflection {
                docstring_md: "How a geometric shape is drawn and colored.",
                deprecation_summary: None,
                custom_placeholder: Some(FillMode::default().to_arrow()?),
                datatype: FillMode::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: FillMode::verify_arrow_array,
            },
        ),
        (
            <FillRatio as Component>::name(),
            ComponentReflection {
                docstring_md: "How much a primitive fills out the available space.\n\nUsed for instance to scale the points of the point cloud created from [`archetypes.DepthImage`](https://rerun.io/docs/reference/types/archetypes/depth_image) projection in 3D views.\nValid range is from 0 to max float although typically values above 1.0 are not useful.\n\nDefaults to 1.0.",
                deprecation_summary: None,
                custom_placeholder: Some(FillRatio::default().to_arrow()?),
                datatype: FillRatio::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: FillRatio::verify_arrow_array,
            },
        ),
        (
            <GammaCorrection as Component>::name(),
            ComponentReflection {
                docstring_md: "A gamma correction value to be used with a scalar value or color.\n\nUsed to adjust the gamma of a color or scalar value between 0 and 1 before rendering.\n`new_value = old_value ^ gamma`\n\nMust be a positive number.\nDefaults to 1.0 unless otherwise specified.",
                deprecation_summary: None,
                custom_placeholder: Some(GammaCorrection::default().to_arrow()?),
                datatype: GammaCorrection::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: GammaCorrection::verify_arrow_array,
            },
        ),
        (
            <GeoLineString as Component>::name(),
            ComponentReflection {
                docstring_md: "A geospatial line string expressed in [EPSG:4326](https://epsg.io/4326) latitude and longitude (North/East-positive degrees).",
                deprecation_summary: None,
                custom_placeholder: Some(GeoLineString::default().to_arrow()?),
                datatype: GeoLineString::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: GeoLineString::verify_arrow_array,
            },
        ),
        (
            <GraphEdge as Component>::name(),
            ComponentReflection {
                docstring_md: "An edge in a graph connecting two nodes.",
                deprecation_summary: None,
                custom_placeholder: Some(GraphEdge::default().to_arrow()?),
                datatype: GraphEdge::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: GraphEdge::verify_arrow_array,
            },
        ),
        (
            <GraphNode as Component>::name(),
            ComponentReflection {
                docstring_md: "A string-based ID representing a node in a graph.",
                deprecation_summary: None,
                custom_placeholder: Some(GraphNode::default().to_arrow()?),
                datatype: GraphNode::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: GraphNode::verify_arrow_array,
            },
        ),
        (
            <GraphType as Component>::name(),
            ComponentReflection {
                docstring_md: "Specifies if a graph has directed or undirected edges.",
                deprecation_summary: None,
                custom_placeholder: Some(GraphType::default().to_arrow()?),
                datatype: GraphType::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: GraphType::verify_arrow_array,
            },
        ),
        (
            <HalfSize2D as Component>::name(),
            ComponentReflection {
                docstring_md: "Half-size (radius) of a 2D box.\n\nMeasured in its local coordinate system.\n\nThe box extends both in negative and positive direction along each axis.\nNegative sizes indicate that the box is flipped along the respective axis, but this has no effect on how it is displayed.",
                deprecation_summary: None,
                custom_placeholder: Some(HalfSize2D::default().to_arrow()?),
                datatype: HalfSize2D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: HalfSize2D::verify_arrow_array,
            },
        ),
        (
            <HalfSize3D as Component>::name(),
            ComponentReflection {
                docstring_md: "Half-size (radius) of a 3D box.\n\nMeasured in its local coordinate system.\n\nThe box extends both in negative and positive direction along each axis.\nNegative sizes indicate that the box is flipped along the respective axis, but this has no effect on how it is displayed.",
                deprecation_summary: None,
                custom_placeholder: Some(HalfSize3D::default().to_arrow()?),
                datatype: HalfSize3D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: HalfSize3D::verify_arrow_array,
            },
        ),
        (
            <ImageBuffer as Component>::name(),
            ComponentReflection {
                docstring_md: "A buffer that is known to store image data.\n\nTo interpret the contents of this buffer, see, [`components.ImageFormat`](https://rerun.io/docs/reference/types/components/image_format).",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: ImageBuffer::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ImageBuffer::verify_arrow_array,
            },
        ),
        (
            <ImageFormat as Component>::name(),
            ComponentReflection {
                docstring_md: "The metadata describing the contents of a [`components.ImageBuffer`](https://rerun.io/docs/reference/types/components/image_buffer).",
                deprecation_summary: None,
                custom_placeholder: Some(ImageFormat::default().to_arrow()?),
                datatype: ImageFormat::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ImageFormat::verify_arrow_array,
            },
        ),
        (
            <ImagePlaneDistance as Component>::name(),
            ComponentReflection {
                docstring_md: "The distance from the camera origin to the image plane when the projection is shown in a 3D viewer.\n\nThis is only used for visualization purposes, and does not affect the projection itself.",
                deprecation_summary: None,
                custom_placeholder: Some(ImagePlaneDistance::default().to_arrow()?),
                datatype: ImagePlaneDistance::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ImagePlaneDistance::verify_arrow_array,
            },
        ),
        (
            <Interactive as Component>::name(),
            ComponentReflection {
                docstring_md: "Whether the entity can be interacted with.\n\nNon interactive components are still visible, but mouse interactions in the view are disabled.",
                deprecation_summary: None,
                custom_placeholder: Some(Interactive::default().to_arrow()?),
                datatype: Interactive::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Interactive::verify_arrow_array,
            },
        ),
        (
            <KeyValuePairs as Component>::name(),
            ComponentReflection {
                docstring_md: "A map of string keys to string values.\n\nThis component can be used to attach arbitrary metadata or annotations to entities.\nEach key-value pair is stored as a UTF-8 string mapping.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(KeyValuePairs::default().to_arrow()?),
                datatype: KeyValuePairs::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: KeyValuePairs::verify_arrow_array,
            },
        ),
        (
            <KeypointId as Component>::name(),
            ComponentReflection {
                docstring_md: "A 16-bit ID representing a type of semantic keypoint within a class.",
                deprecation_summary: None,
                custom_placeholder: Some(KeypointId::default().to_arrow()?),
                datatype: KeypointId::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: KeypointId::verify_arrow_array,
            },
        ),
        (
            <LatLon as Component>::name(),
            ComponentReflection {
                docstring_md: "A geospatial position expressed in [EPSG:4326](https://epsg.io/4326) latitude and longitude (North/East-positive degrees).",
                deprecation_summary: None,
                custom_placeholder: Some(LatLon::default().to_arrow()?),
                datatype: LatLon::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: LatLon::verify_arrow_array,
            },
        ),
        (
            <Length as Component>::name(),
            ComponentReflection {
                docstring_md: "Length, or one-dimensional size.\n\nMeasured in its local coordinate system; consult the archetype in use to determine which\naxis or part of the entity this is the length of.",
                deprecation_summary: None,
                custom_placeholder: Some(Length::default().to_arrow()?),
                datatype: Length::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Length::verify_arrow_array,
            },
        ),
        (
            <LineStrip2D as Component>::name(),
            ComponentReflection {
                docstring_md: "A line strip in 2D space.\n\nA line strip is a list of points connected by line segments. It can be used to draw\napproximations of smooth curves.\n\nThe points will be connected in order, like so:\n```text\n       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n```",
                deprecation_summary: None,
                custom_placeholder: Some(LineStrip2D::default().to_arrow()?),
                datatype: LineStrip2D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: LineStrip2D::verify_arrow_array,
            },
        ),
        (
            <LineStrip3D as Component>::name(),
            ComponentReflection {
                docstring_md: "A line strip in 3D space.\n\nA line strip is a list of points connected by line segments. It can be used to draw\napproximations of smooth curves.\n\nThe points will be connected in order, like so:\n```text\n       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n```",
                deprecation_summary: None,
                custom_placeholder: Some(LineStrip3D::default().to_arrow()?),
                datatype: LineStrip3D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: LineStrip3D::verify_arrow_array,
            },
        ),
        (
            <LinearSpeed as Component>::name(),
            ComponentReflection {
                docstring_md: "Linear speed, used for translation speed for example.",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: LinearSpeed::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: LinearSpeed::verify_arrow_array,
            },
        ),
        (
            <MagnificationFilter as Component>::name(),
            ComponentReflection {
                docstring_md: "Filter used when magnifying an image/texture such that a single pixel/texel is displayed as multiple pixels on screen.",
                deprecation_summary: None,
                custom_placeholder: Some(MagnificationFilter::default().to_arrow()?),
                datatype: MagnificationFilter::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: MagnificationFilter::verify_arrow_array,
            },
        ),
        (
            <MarkerShape as Component>::name(),
            ComponentReflection {
                docstring_md: "The visual appearance of a point in e.g. a 2D plot.",
                deprecation_summary: None,
                custom_placeholder: Some(MarkerShape::default().to_arrow()?),
                datatype: MarkerShape::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: MarkerShape::verify_arrow_array,
            },
        ),
        (
            <MarkerSize as Component>::name(),
            ComponentReflection {
                docstring_md: "Radius of a marker of a point in e.g. a 2D plot, measured in UI points.",
                deprecation_summary: None,
                custom_placeholder: Some(MarkerSize::default().to_arrow()?),
                datatype: MarkerSize::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: MarkerSize::verify_arrow_array,
            },
        ),
        (
            <MediaType as Component>::name(),
            ComponentReflection {
                docstring_md: "A standardized media type (RFC2046, formerly known as MIME types), encoded as a string.\n\nThe complete reference of officially registered media types is maintained by the IANA and can be\nconsulted at <https://www.iana.org/assignments/media-types/media-types.xhtml>.",
                deprecation_summary: None,
                custom_placeholder: Some(MediaType::default().to_arrow()?),
                datatype: MediaType::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: MediaType::verify_arrow_array,
            },
        ),
        (
            <Name as Component>::name(),
            ComponentReflection {
                docstring_md: "A display name, typically for an entity or a item like a plot series.",
                deprecation_summary: None,
                custom_placeholder: Some(Name::default().to_arrow()?),
                datatype: Name::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Name::verify_arrow_array,
            },
        ),
        (
            <Opacity as Component>::name(),
            ComponentReflection {
                docstring_md: "Degree of transparency ranging from 0.0 (fully transparent) to 1.0 (fully opaque).\n\nThe final opacity value may be a result of multiplication with alpha values as specified by other color sources.\nUnless otherwise specified, the default value is 1.",
                deprecation_summary: None,
                custom_placeholder: Some(Opacity::default().to_arrow()?),
                datatype: Opacity::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Opacity::verify_arrow_array,
            },
        ),
        (
            <PinholeProjection as Component>::name(),
            ComponentReflection {
                docstring_md: "Camera projection, from image coordinates to view coordinates.\n\nChild from parent.\nImage coordinates from camera view coordinates.\n\nExample:\n```text\n1496.1     0.0  980.5\n   0.0  1496.1  744.5\n   0.0     0.0    1.0\n```",
                deprecation_summary: None,
                custom_placeholder: Some(PinholeProjection::default().to_arrow()?),
                datatype: PinholeProjection::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: PinholeProjection::verify_arrow_array,
            },
        ),
        (
            <Plane3D as Component>::name(),
            ComponentReflection {
                docstring_md: "An infinite 3D plane represented by a unit normal vector and a distance.\n\nAny point P on the plane fulfills the equation `dot(xyz, P) - d = 0`,\nwhere `xyz` is the plane's normal and `d` the distance of the plane from the origin.\nThis representation is also known as the Hesse normal form.\n\nNote: although the normal will be passed through to the\ndatastore as provided, when used in the Viewer, planes will always be normalized.\nI.e. the plane with xyz = (2, 0, 0), d = 1 is equivalent to xyz = (1, 0, 0), d = 0.5",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: Plane3D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Plane3D::verify_arrow_array,
            },
        ),
        (
            <Position2D as Component>::name(),
            ComponentReflection {
                docstring_md: "A position in 2D space.",
                deprecation_summary: None,
                custom_placeholder: Some(Position2D::default().to_arrow()?),
                datatype: Position2D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Position2D::verify_arrow_array,
            },
        ),
        (
            <Position3D as Component>::name(),
            ComponentReflection {
                docstring_md: "A position in 3D space.",
                deprecation_summary: None,
                custom_placeholder: Some(Position3D::default().to_arrow()?),
                datatype: Position3D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Position3D::verify_arrow_array,
            },
        ),
        (
            <Radius as Component>::name(),
            ComponentReflection {
                docstring_md: "The radius of something, e.g. a point.\n\nInternally, positive values indicate scene units, whereas negative values\nare interpreted as UI points.\n\nUI points are independent of zooming in Views, but are sensitive to the application UI scaling.\nat 100% UI scaling, UI points are equal to pixels\nThe Viewer's UI scaling defaults to the OS scaling which typically is 100% for full HD screens and 200% for 4k screens.",
                deprecation_summary: None,
                custom_placeholder: Some(Radius::default().to_arrow()?),
                datatype: Radius::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Radius::verify_arrow_array,
            },
        ),
        (
            <Range1D as Component>::name(),
            ComponentReflection {
                docstring_md: "A 1D range, specifying a lower and upper bound.",
                deprecation_summary: None,
                custom_placeholder: Some(Range1D::default().to_arrow()?),
                datatype: Range1D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Range1D::verify_arrow_array,
            },
        ),
        (
            <Resolution as Component>::name(),
            ComponentReflection {
                docstring_md: "Pixel resolution width & height, e.g. of a camera sensor.\n\nTypically in integer units, but for some use cases floating point may be used.",
                deprecation_summary: None,
                custom_placeholder: Some(Resolution::default().to_arrow()?),
                datatype: Resolution::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Resolution::verify_arrow_array,
            },
        ),
        (
            <RotationAxisAngle as Component>::name(),
            ComponentReflection {
                docstring_md: "3D rotation represented by a rotation around a given axis.\n\nIf normalization of the rotation axis fails the rotation is treated as an invalid transform, unless the\nangle is zero in which case it is treated as an identity.",
                deprecation_summary: None,
                custom_placeholder: Some(RotationAxisAngle::default().to_arrow()?),
                datatype: RotationAxisAngle::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: RotationAxisAngle::verify_arrow_array,
            },
        ),
        (
            <RotationQuat as Component>::name(),
            ComponentReflection {
                docstring_md: "A 3D rotation expressed as a quaternion.\n\nNote: although the x,y,z,w components of the quaternion will be passed through to the\ndatastore as provided, when used in the Viewer, quaternions will always be normalized.\nIf normalization fails the rotation is treated as an invalid transform.",
                deprecation_summary: None,
                custom_placeholder: Some(RotationQuat::default().to_arrow()?),
                datatype: RotationQuat::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: RotationQuat::verify_arrow_array,
            },
        ),
        (
            <Scalar as Component>::name(),
            ComponentReflection {
                docstring_md: "A scalar value, encoded as a 64-bit floating point.\n\nUsed for time series plots.",
                deprecation_summary: None,
                custom_placeholder: Some(Scalar::default().to_arrow()?),
                datatype: Scalar::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Scalar::verify_arrow_array,
            },
        ),
        (
            <Scale3D as Component>::name(),
            ComponentReflection {
                docstring_md: "A 3D scale factor.\n\nA scale of 1.0 means no scaling.\nA scale of 2.0 means doubling the size.\nEach component scales along the corresponding axis.",
                deprecation_summary: None,
                custom_placeholder: Some(Scale3D::default().to_arrow()?),
                datatype: Scale3D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Scale3D::verify_arrow_array,
            },
        ),
        (
            <SchemaId as Component>::name(),
            ComponentReflection {
                docstring_md: "A 16-bit unique identifier for a schema within the MCAP file.",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: SchemaId::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: SchemaId::verify_arrow_array,
            },
        ),
        (
            <SeriesVisible as Component>::name(),
            ComponentReflection {
                docstring_md: "Like [`components.Visible`](https://rerun.io/docs/reference/types/components/visible), but for time series.\n\nTODO(#10632): This is a temporary workaround. Right now we can't use [`components.Visible`](https://rerun.io/docs/reference/types/components/visible) since it would conflict with the entity-wide visibility state.",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: SeriesVisible::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: SeriesVisible::verify_arrow_array,
            },
        ),
        (
            <ShowLabels as Component>::name(),
            ComponentReflection {
                docstring_md: "Whether the entity's [`components.Text`](https://rerun.io/docs/reference/types/components/text) label is shown.\n\nThe main purpose of this component existing separately from the labels themselves\nis to be overridden when desired, to allow hiding and showing from the viewer and\nblueprints.",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: ShowLabels::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ShowLabels::verify_arrow_array,
            },
        ),
        (
            <StrokeWidth as Component>::name(),
            ComponentReflection {
                docstring_md: "The width of a stroke specified in UI points.",
                deprecation_summary: None,
                custom_placeholder: Some(StrokeWidth::default().to_arrow()?),
                datatype: StrokeWidth::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: StrokeWidth::verify_arrow_array,
            },
        ),
        (
            <TensorData as Component>::name(),
            ComponentReflection {
                docstring_md: "An N-dimensional array of numbers.\n\nThe number of dimensions and their respective lengths is specified by the `shape` field.\nThe dimensions are ordered from outermost to innermost. For example, in the common case of\na 2D RGB Image, the shape would be `[height, width, channel]`.\n\nThese dimensions are combined with an index to look up values from the `buffer` field,\nwhich stores a contiguous array of typed values.",
                deprecation_summary: None,
                custom_placeholder: Some(TensorData::default().to_arrow()?),
                datatype: TensorData::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TensorData::verify_arrow_array,
            },
        ),
        (
            <TensorDimensionIndexSelection as Component>::name(),
            ComponentReflection {
                docstring_md: "Specifies a concrete index on a tensor dimension.",
                deprecation_summary: None,
                custom_placeholder: Some(TensorDimensionIndexSelection::default().to_arrow()?),
                datatype: TensorDimensionIndexSelection::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TensorDimensionIndexSelection::verify_arrow_array,
            },
        ),
        (
            <TensorHeightDimension as Component>::name(),
            ComponentReflection {
                docstring_md: "Specifies which dimension to use for height.",
                deprecation_summary: None,
                custom_placeholder: Some(TensorHeightDimension::default().to_arrow()?),
                datatype: TensorHeightDimension::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TensorHeightDimension::verify_arrow_array,
            },
        ),
        (
            <TensorWidthDimension as Component>::name(),
            ComponentReflection {
                docstring_md: "Specifies which dimension to use for width.",
                deprecation_summary: None,
                custom_placeholder: Some(TensorWidthDimension::default().to_arrow()?),
                datatype: TensorWidthDimension::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TensorWidthDimension::verify_arrow_array,
            },
        ),
        (
            <Texcoord2D as Component>::name(),
            ComponentReflection {
                docstring_md: "A 2D texture UV coordinate.\n\nTexture coordinates specify a position on a 2D texture.\nA range from 0-1 covers the entire texture in the respective dimension.\nUnless configured otherwise, the texture repeats outside of this range.\nRerun uses top-left as the origin for UV coordinates.\n\n  0     U     1\n0 + --------- →\n  |           .\nV |           .\n  |           .\n1 ↓ . . . . . .\n\nThis is the same convention as in Vulkan/Metal/DX12/WebGPU, but (!) unlike OpenGL,\nwhich places the origin at the bottom-left.",
                deprecation_summary: None,
                custom_placeholder: Some(Texcoord2D::default().to_arrow()?),
                datatype: Texcoord2D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Texcoord2D::verify_arrow_array,
            },
        ),
        (
            <Text as Component>::name(),
            ComponentReflection {
                docstring_md: "A string of text, e.g. for labels and text documents.",
                deprecation_summary: None,
                custom_placeholder: Some(Text::default().to_arrow()?),
                datatype: Text::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Text::verify_arrow_array,
            },
        ),
        (
            <TextLogLevel as Component>::name(),
            ComponentReflection {
                docstring_md: "The severity level of a text log message.\n\nRecommended to be one of:\n* `\"CRITICAL\"`\n* `\"ERROR\"`\n* `\"WARN\"`\n* `\"INFO\"`\n* `\"DEBUG\"`\n* `\"TRACE\"`",
                deprecation_summary: None,
                custom_placeholder: Some(TextLogLevel::default().to_arrow()?),
                datatype: TextLogLevel::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TextLogLevel::verify_arrow_array,
            },
        ),
        (
            <Timestamp as Component>::name(),
            ComponentReflection {
                docstring_md: "When the recording started.\n\nShould be an absolute time, i.e. relative to Unix Epoch.",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: Timestamp::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Timestamp::verify_arrow_array,
            },
        ),
        (
            <TransformFrameId as Component>::name(),
            ComponentReflection {
                docstring_md: "A string identifier for a transform frame.\n\nTransform frames may be derived from entity paths to refer to Rerun's implicit\nentity path driven hierarchy which is defined via [`archetypes.Transform3D`](https://rerun.io/docs/reference/types/archetypes/transform3d), [`archetypes.Pinhole`](https://rerun.io/docs/reference/types/archetypes/pinhole) etc..\nThese implicit transform frames look like `tf#path/to/entity`.\n\nNote that any [`archetypes.Transform3D`](https://rerun.io/docs/reference/types/archetypes/transform3d)s logged with both `parent_frame` and `child_frame` set\ndescribes a relationship between these parent and child transform frames, **not** the transform frame\nthat the entity path may be using (defined by an [`archetypes.CoordinateFrame`](https://rerun.io/docs/reference/types/archetypes/coordinate_frame)).",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: TransformFrameId::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TransformFrameId::verify_arrow_array,
            },
        ),
        (
            <TransformMat3x3 as Component>::name(),
            ComponentReflection {
                docstring_md: "A 3x3 transformation matrix Matrix.\n\n3x3 matrixes are able to represent any affine transformation in 3D space,\ni.e. rotation, scaling, shearing, reflection etc.\n\nMatrices in Rerun are stored as flat list of coefficients in column-major order:\n```text\n            column 0       column 1       column 2\n       -------------------------------------------------\nrow 0 | flat_columns[0] flat_columns[3] flat_columns[6]\nrow 1 | flat_columns[1] flat_columns[4] flat_columns[7]\nrow 2 | flat_columns[2] flat_columns[5] flat_columns[8]\n```",
                deprecation_summary: None,
                custom_placeholder: Some(TransformMat3x3::default().to_arrow()?),
                datatype: TransformMat3x3::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TransformMat3x3::verify_arrow_array,
            },
        ),
        (
            <TransformRelation as Component>::name(),
            ComponentReflection {
                docstring_md: "Specifies relation a spatial transform describes.",
                deprecation_summary: None,
                custom_placeholder: Some(TransformRelation::default().to_arrow()?),
                datatype: TransformRelation::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: TransformRelation::verify_arrow_array,
            },
        ),
        (
            <Translation3D as Component>::name(),
            ComponentReflection {
                docstring_md: "A translation vector in 3D space.",
                deprecation_summary: None,
                custom_placeholder: Some(Translation3D::default().to_arrow()?),
                datatype: Translation3D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Translation3D::verify_arrow_array,
            },
        ),
        (
            <TriangleIndices as Component>::name(),
            ComponentReflection {
                docstring_md: "The three indices of a triangle in a triangle mesh.",
                deprecation_summary: None,
                custom_placeholder: Some(TriangleIndices::default().to_arrow()?),
                datatype: TriangleIndices::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: TriangleIndices::verify_arrow_array,
            },
        ),
        (
            <ValueRange as Component>::name(),
            ComponentReflection {
                docstring_md: "Range of expected or valid values, specifying a lower and upper bound.\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ValueRange::default().to_arrow()?),
                datatype: ValueRange::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ValueRange::verify_arrow_array,
            },
        ),
        (
            <Vector2D as Component>::name(),
            ComponentReflection {
                docstring_md: "A vector in 2D space.",
                deprecation_summary: None,
                custom_placeholder: Some(Vector2D::default().to_arrow()?),
                datatype: Vector2D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Vector2D::verify_arrow_array,
            },
        ),
        (
            <Vector3D as Component>::name(),
            ComponentReflection {
                docstring_md: "A vector in 3D space.",
                deprecation_summary: None,
                custom_placeholder: Some(Vector3D::default().to_arrow()?),
                datatype: Vector3D::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Vector3D::verify_arrow_array,
            },
        ),
        (
            <VideoCodec as Component>::name(),
            ComponentReflection {
                docstring_md: "The codec used to encode video stored in [`components.VideoSample`](https://rerun.io/docs/reference/types/components/video_sample).\n\nSupport of these codecs by the Rerun Viewer is platform dependent.\nFor more details see check the [video reference](https://rerun.io/docs/reference/video).\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: VideoCodec::arrow_datatype(),
                is_enum: true,
                verify_arrow_array: VideoCodec::verify_arrow_array,
            },
        ),
        (
            <VideoSample as Component>::name(),
            ComponentReflection {
                docstring_md: "Video sample data (also known as \"video chunk\").\n\nEach video sample must contain enough data for exactly one video frame\n(this restriction may be relaxed in the future for some codecs).\n\nKeyframes may require additional data, for details see [`components.VideoCodec`](https://rerun.io/docs/reference/types/components/video_codec).",
                deprecation_summary: None,
                custom_placeholder: None,
                datatype: VideoSample::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: VideoSample::verify_arrow_array,
            },
        ),
        (
            <VideoTimestamp as Component>::name(),
            ComponentReflection {
                docstring_md: "Timestamp inside a [`archetypes.AssetVideo`](https://rerun.io/docs/reference/types/archetypes/asset_video).",
                deprecation_summary: None,
                custom_placeholder: Some(VideoTimestamp::default().to_arrow()?),
                datatype: VideoTimestamp::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: VideoTimestamp::verify_arrow_array,
            },
        ),
        (
            <ViewCoordinates as Component>::name(),
            ComponentReflection {
                docstring_md: "How we interpret the coordinate system of an entity/space.\n\nFor instance: What is \"up\"? What does the Z axis mean?\n\nThe three coordinates are always ordered as [x, y, z].\n\nFor example [Right, Down, Forward] means that the X axis points to the right, the Y axis points\ndown, and the Z axis points forward.\n\n⚠ [Rerun does not yet support left-handed coordinate systems](https://github.com/rerun-io/rerun/issues/5032).\n\nThe following constants are used to represent the different directions:\n * Up = 1\n * Down = 2\n * Right = 3\n * Left = 4\n * Forward = 5\n * Back = 6\n\n⚠\u{fe0f} **This type is _unstable_ and may change significantly in a way that the data won't be backwards compatible.**",
                deprecation_summary: None,
                custom_placeholder: Some(ViewCoordinates::default().to_arrow()?),
                datatype: ViewCoordinates::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: ViewCoordinates::verify_arrow_array,
            },
        ),
        (
            <Visible as Component>::name(),
            ComponentReflection {
                docstring_md: "Whether the container, view, entity or instance is currently visible.",
                deprecation_summary: None,
                custom_placeholder: Some(Visible::default().to_arrow()?),
                datatype: Visible::arrow_datatype(),
                is_enum: false,
                verify_arrow_array: Visible::verify_arrow_array,
            },
        ),
    ];
    Ok(ComponentReflectionMap::from_iter(array))
}

/// Generates reflection about all known archetypes.
///
/// Call only once and reuse the results.

fn generate_archetype_reflection() -> ArchetypeReflectionMap {
    re_tracing::profile_function!();
    let array = [
        (
            ArchetypeName::new("rerun.archetypes.AnnotationContext"),
            ArchetypeReflection {
                display_name: "Annotation context",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![ArchetypeFieldReflection {
                    name: "context",
                    display_name: "Context",
                    component_type: "rerun.components.AnnotationContext".into(),
                    docstring_md: "List of class descriptions, mapping class indices to class names, colors etc.",
                    is_required: true,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Arrows2D"),
            ArchetypeReflection {
                display_name: "Arrows 2D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "vectors",
                        display_name: "Vectors",
                        component_type: "rerun.components.Vector2D".into(),
                        docstring_md: "All the vectors for each arrow in the batch.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "origins",
                        display_name: "Origins",
                        component_type: "rerun.components.Position2D".into(),
                        docstring_md: "All the origin (base) positions for each arrow in the batch.\n\nIf no origins are set, (0, 0) is used as the origin for each arrow.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the arrows.\n\nThe shaft is rendered as a line with `radius = 0.5 * radius`.\nThe tip is rendered with `height = 2.0 * radius` and `radius = 1.0 * radius`.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the points.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the arrows.\n\nIf there's a single label present, it will be placed at the center of the entity.\nOtherwise, each instance will have its own label.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "An optional floating point value that specifies the 2D drawing order.\n\nObjects with higher values are drawn on top of those with lower values.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional class Ids for the points.\n\nThe [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Arrows3D"),
            ArchetypeReflection {
                display_name: "Arrows 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "vectors",
                        display_name: "Vectors",
                        component_type: "rerun.components.Vector3D".into(),
                        docstring_md: "All the vectors for each arrow in the batch.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "origins",
                        display_name: "Origins",
                        component_type: "rerun.components.Position3D".into(),
                        docstring_md: "All the origin (base) positions for each arrow in the batch.\n\nIf no origins are set, (0, 0, 0) is used as the origin for each arrow.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the arrows.\n\nThe shaft is rendered as a line with `radius = 0.5 * radius`.\nThe tip is rendered with `height = 2.0 * radius` and `radius = 1.0 * radius`.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the points.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the arrows.\n\nIf there's a single label present, it will be placed at the center of the entity.\nOtherwise, each instance will have its own label.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional class Ids for the points.\n\nThe [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Asset3D"),
            ArchetypeReflection {
                display_name: "Asset 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "blob",
                        display_name: "Blob",
                        component_type: "rerun.components.Blob".into(),
                        docstring_md: "The asset's bytes.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "media_type",
                        display_name: "Media type",
                        component_type: "rerun.components.MediaType".into(),
                        docstring_md: "The Media Type of the asset.\n\nSupported values:\n* `model/gltf-binary`\n* `model/gltf+json`\n* `model/obj` (.mtl material files are not supported yet, references are silently ignored)\n* `model/stl`\n\nIf omitted, the viewer will try to guess from the data blob.\nIf it cannot guess, it won't be able to render the asset.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "albedo_factor",
                        display_name: "Albedo factor",
                        component_type: "rerun.components.AlbedoFactor".into(),
                        docstring_md: "A color multiplier applied to the whole asset.\n\nFor mesh who already have `albedo_factor` in materials,\nit will be overwritten by actual `albedo_factor` of [`archetypes.Asset3D`](https://rerun.io/docs/reference/types/archetypes/asset3d) (if specified).",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.AssetVideo"),
            ArchetypeReflection {
                display_name: "Asset video",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "blob",
                        display_name: "Blob",
                        component_type: "rerun.components.Blob".into(),
                        docstring_md: "The asset's bytes.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "media_type",
                        display_name: "Media type",
                        component_type: "rerun.components.MediaType".into(),
                        docstring_md: "The Media Type of the asset.\n\nSupported values:\n* `video/mp4`\n\nIf omitted, the viewer will try to guess from the data blob.\nIf it cannot guess, it won't be able to render the asset.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.BarChart"),
            ArchetypeReflection {
                display_name: "Bar chart",
                deprecation_summary: None,
                scope: None,
                view_types: &["BarChartView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "values",
                        display_name: "Values",
                        component_type: "rerun.components.TensorData".into(),
                        docstring_md: "The values. Should always be a 1-dimensional tensor (i.e. a vector).",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "color",
                        display_name: "Color",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "The color of the bar chart",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "abscissa",
                        display_name: "Abscissa",
                        component_type: "rerun.components.TensorData".into(),
                        docstring_md: "The abscissa corresponding to each value. Should be a 1-dimensional tensor (i.e. a vector) in same length as values.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "widths",
                        display_name: "Widths",
                        component_type: "rerun.components.Length".into(),
                        docstring_md: "The width of the bins, defined in x-axis units and defaults to 1. Should be a 1-dimensional tensor (i.e. a vector) in same length as values.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Boxes2D"),
            ArchetypeReflection {
                display_name: "Boxes 2D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "half_sizes",
                        display_name: "Half sizes",
                        component_type: "rerun.components.HalfSize2D".into(),
                        docstring_md: "All half-extents that make up the batch of boxes.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "centers",
                        display_name: "Centers",
                        component_type: "rerun.components.Position2D".into(),
                        docstring_md: "Optional center positions of the boxes.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the boxes.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the lines that make up the boxes.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the boxes.\n\nIf there's a single label present, it will be placed at the center of the entity.\nOtherwise, each instance will have its own label.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "An optional floating point value that specifies the 2D drawing order.\n\nObjects with higher values are drawn on top of those with lower values.\nDefaults to `10.0`.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id)s for the boxes.\n\nThe [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Boxes3D"),
            ArchetypeReflection {
                display_name: "Boxes 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "half_sizes",
                        display_name: "Half sizes",
                        component_type: "rerun.components.HalfSize3D".into(),
                        docstring_md: "All half-extents that make up the batch of boxes.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "centers",
                        display_name: "Centers",
                        component_type: "rerun.components.Translation3D".into(),
                        docstring_md: "Optional center positions of the boxes.\n\nIf not specified, the centers will be at (0, 0, 0).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "rotation_axis_angles",
                        display_name: "Rotation axis angles",
                        component_type: "rerun.components.RotationAxisAngle".into(),
                        docstring_md: "Rotations via axis + angle.\n\nIf no rotation is specified, the axes of the boxes align with the axes of the local coordinate system.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "quaternions",
                        display_name: "Quaternions",
                        component_type: "rerun.components.RotationQuat".into(),
                        docstring_md: "Rotations via quaternion.\n\nIf no rotation is specified, the axes of the boxes align with the axes of the local coordinate system.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the boxes.\n\nAlpha channel is used for transparency for solid fill-mode.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the lines that make up the boxes.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "fill_mode",
                        display_name: "Fill mode",
                        component_type: "rerun.components.FillMode".into(),
                        docstring_md: "Optionally choose whether the boxes are drawn with lines or solid.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the boxes.\n\nIf there's a single label present, it will be placed at the center of the entity.\nOtherwise, each instance will have its own label.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id)s for the boxes.\n\nThe [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Capsules3D"),
            ArchetypeReflection {
                display_name: "Capsules 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "lengths",
                        display_name: "Lengths",
                        component_type: "rerun.components.Length".into(),
                        docstring_md: "Lengths of the capsules, defined as the distance between the centers of the endcaps.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Radii of the capsules.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "translations",
                        display_name: "Translations",
                        component_type: "rerun.components.Translation3D".into(),
                        docstring_md: "Optional translations of the capsules.\n\nIf not specified, one end of each capsule will be at (0, 0, 0).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "rotation_axis_angles",
                        display_name: "Rotation axis angles",
                        component_type: "rerun.components.RotationAxisAngle".into(),
                        docstring_md: "Rotations via axis + angle.\n\nIf no rotation is specified, the capsules align with the +Z axis of the local coordinate system.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "quaternions",
                        display_name: "Quaternions",
                        component_type: "rerun.components.RotationQuat".into(),
                        docstring_md: "Rotations via quaternion.\n\nIf no rotation is specified, the capsules align with the +Z axis of the local coordinate system.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the capsules.\n\nAlpha channel is used for transparency for solid fill-mode.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "line_radii",
                        display_name: "Line radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the lines used when the cylinder is rendered as a wireframe.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "fill_mode",
                        display_name: "Fill mode",
                        component_type: "rerun.components.FillMode".into(),
                        docstring_md: "Optionally choose whether the cylinders are drawn with lines or solid.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the capsules, which will be located at their centers.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional class ID for the ellipsoids.\n\nThe class ID provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Clear"),
            ArchetypeReflection {
                display_name: "Clear",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView", "TimeSeriesView"],
                fields: vec![ArchetypeFieldReflection {
                    name: "is_recursive",
                    display_name: "Is recursive",
                    component_type: "rerun.components.ClearIsRecursive".into(),
                    docstring_md: "",
                    is_required: true,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.CoordinateFrame"),
            ArchetypeReflection {
                display_name: "Coordinate frame",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![ArchetypeFieldReflection {
                    name: "frame",
                    display_name: "Frame",
                    component_type: "rerun.components.TransformFrameId".into(),
                    docstring_md: "The coordinate frame to use for the current entity.",
                    is_required: true,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Cylinders3D"),
            ArchetypeReflection {
                display_name: "Cylinders 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "lengths",
                        display_name: "Lengths",
                        component_type: "rerun.components.Length".into(),
                        docstring_md: "The total axial length of the cylinder, measured as the straight-line distance between the centers of its two endcaps.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Radii of the cylinders.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "centers",
                        display_name: "Centers",
                        component_type: "rerun.components.Translation3D".into(),
                        docstring_md: "Optional centers of the cylinders.\n\nIf not specified, each cylinder will be centered at (0, 0, 0).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "rotation_axis_angles",
                        display_name: "Rotation axis angles",
                        component_type: "rerun.components.RotationAxisAngle".into(),
                        docstring_md: "Rotations via axis + angle.\n\nIf no rotation is specified, the cylinders align with the +Z axis of the local coordinate system.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "quaternions",
                        display_name: "Quaternions",
                        component_type: "rerun.components.RotationQuat".into(),
                        docstring_md: "Rotations via quaternion.\n\nIf no rotation is specified, the cylinders align with the +Z axis of the local coordinate system.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the cylinders.\n\nAlpha channel is used for transparency for solid fill-mode.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "line_radii",
                        display_name: "Line radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the lines used when the cylinder is rendered as a wireframe.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "fill_mode",
                        display_name: "Fill mode",
                        component_type: "rerun.components.FillMode".into(),
                        docstring_md: "Optionally choose whether the cylinders are drawn with lines or solid.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the cylinders, which will be located at their centers.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional class ID for the ellipsoids.\n\nThe class ID provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.DepthImage"),
            ArchetypeReflection {
                display_name: "Depth image",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "buffer",
                        display_name: "Buffer",
                        component_type: "rerun.components.ImageBuffer".into(),
                        docstring_md: "The raw depth image data.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "format",
                        display_name: "Format",
                        component_type: "rerun.components.ImageFormat".into(),
                        docstring_md: "The format of the image.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "meter",
                        display_name: "Meter",
                        component_type: "rerun.components.DepthMeter".into(),
                        docstring_md: "An optional floating point value that specifies how long a meter is in the native depth units.\n\nFor instance: with uint16, perhaps meter=1000 which would mean you have millimeter precision\nand a range of up to ~65 meters (2^16 / 1000).\n\nIf omitted, the Viewer defaults to `1.0` for floating-point depth formats and `1000.0` for integer formats (millimeters).\n\nNote that the only effect on 2D views is the physical depth values shown when hovering the image.\nIn 3D views on the other hand, this affects where the points of the point cloud are placed.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colormap",
                        display_name: "Colormap",
                        component_type: "rerun.components.Colormap".into(),
                        docstring_md: "Colormap to use for rendering the depth image.\n\nIf not set, the depth image will be rendered using the Turbo colormap.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "depth_range",
                        display_name: "Depth range",
                        component_type: "rerun.components.ValueRange".into(),
                        docstring_md: "The expected range of depth values.\n\nThis is typically the expected range of valid values.\nEverything outside of the range is clamped to the range for the purpose of colormpaping.\nNote that point clouds generated from this image will still display all points, regardless of this range.\n\nIf not specified, the range will be automatically estimated from the data.\nNote that the Viewer may try to guess a wider range than the minimum/maximum of values\nin the contents of the depth image.\nE.g. if all values are positive, some bigger than 1.0 and all smaller than 255.0,\nthe Viewer will guess that the data likely came from an 8bit image, thus assuming a range of 0-255.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "point_fill_ratio",
                        display_name: "Point fill ratio",
                        component_type: "rerun.components.FillRatio".into(),
                        docstring_md: "Scale the radii of the points in the point cloud generated from this image.\n\nA fill ratio of 1.0 (the default) means that each point is as big as to touch the center of its neighbor\nif it is at the same depth, leaving no gaps.\nA fill ratio of 0.5 means that each point touches the edge of its neighbor if it has the same depth.\n\nTODO(#6744): This applies only to 3D views!",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "An optional floating point value that specifies the 2D drawing order, used only if the depth image is shown as a 2D image.\n\nObjects with higher values are drawn on top of those with lower values.\nDefaults to `-20.0`.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Ellipsoids3D"),
            ArchetypeReflection {
                display_name: "Ellipsoids 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "half_sizes",
                        display_name: "Half sizes",
                        component_type: "rerun.components.HalfSize3D".into(),
                        docstring_md: "For each ellipsoid, half of its size on its three axes.\n\nIf all components are equal, then it is a sphere with that radius.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "centers",
                        display_name: "Centers",
                        component_type: "rerun.components.Translation3D".into(),
                        docstring_md: "Optional center positions of the ellipsoids.\n\nIf not specified, the centers will be at (0, 0, 0).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "rotation_axis_angles",
                        display_name: "Rotation axis angles",
                        component_type: "rerun.components.RotationAxisAngle".into(),
                        docstring_md: "Rotations via axis + angle.\n\nIf no rotation is specified, the axes of the ellipsoid align with the axes of the local coordinate system.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "quaternions",
                        display_name: "Quaternions",
                        component_type: "rerun.components.RotationQuat".into(),
                        docstring_md: "Rotations via quaternion.\n\nIf no rotation is specified, the axes of the ellipsoid align with the axes of the local coordinate system.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the ellipsoids.\n\nAlpha channel is used for transparency for solid fill-mode.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "line_radii",
                        display_name: "Line radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the lines used when the ellipsoid is rendered as a wireframe.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "fill_mode",
                        display_name: "Fill mode",
                        component_type: "rerun.components.FillMode".into(),
                        docstring_md: "Optionally choose whether the ellipsoids are drawn with lines or solid.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the ellipsoids.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional class ID for the ellipsoids.\n\nThe class ID provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.EncodedDepthImage"),
            ArchetypeReflection {
                display_name: "Encoded depth image",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "blob",
                        display_name: "Blob",
                        component_type: "rerun.components.Blob".into(),
                        docstring_md: "The encoded depth payload.\n\nSupported are:\n* single channel PNG\n* RVL with ROS2 metadata (for details see <https://github.com/ros-perception/image_transport_plugins/tree/jazzy>)",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "media_type",
                        display_name: "Media type",
                        component_type: "rerun.components.MediaType".into(),
                        docstring_md: "Media type of the blob, e.g.:\n\n * `application/rvl` (RVL-compressed 16-bit)\n * `image/png`",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "meter",
                        display_name: "Meter",
                        component_type: "rerun.components.DepthMeter".into(),
                        docstring_md: "Conversion from native units to meters (e.g. `0.001` for millimeters).\n\nIf omitted, the Viewer defaults to `1.0` for floating-point depth formats and `1000.0` for integer formats (millimeters).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colormap",
                        display_name: "Colormap",
                        component_type: "rerun.components.Colormap".into(),
                        docstring_md: "Optional colormap for visualization of decoded depth.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "depth_range",
                        display_name: "Depth range",
                        component_type: "rerun.components.ValueRange".into(),
                        docstring_md: "Optional visualization range for depth values.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "point_fill_ratio",
                        display_name: "Point fill ratio",
                        component_type: "rerun.components.FillRatio".into(),
                        docstring_md: "Optional point fill ratio for point-cloud projection.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "Optional 2D draw order.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.EncodedImage"),
            ArchetypeReflection {
                display_name: "Encoded image",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "blob",
                        display_name: "Blob",
                        component_type: "rerun.components.Blob".into(),
                        docstring_md: "The encoded content of some image file, e.g. a PNG or JPEG.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "media_type",
                        display_name: "Media type",
                        component_type: "rerun.components.MediaType".into(),
                        docstring_md: "The Media Type of the asset.\n\nSupported values:\n* `image/jpeg`\n* `image/png`\n\nIf omitted, the viewer will try to guess from the data blob.\nIf it cannot guess, it won't be able to render the asset.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "opacity",
                        display_name: "Opacity",
                        component_type: "rerun.components.Opacity".into(),
                        docstring_md: "Opacity of the image, useful for layering several media.\n\nDefaults to 1.0 (fully opaque).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "An optional floating point value that specifies the 2D drawing order.\n\nObjects with higher values are drawn on top of those with lower values.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.GeoLineStrings"),
            ArchetypeReflection {
                display_name: "Geo line strings",
                deprecation_summary: None,
                scope: None,
                view_types: &["MapView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "line_strings",
                        display_name: "Line strings",
                        component_type: "rerun.components.GeoLineString".into(),
                        docstring_md: "The line strings, expressed in [EPSG:4326](https://epsg.io/4326) coordinates (North/East-positive degrees).",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the line strings.\n\n*Note*: scene units radiii are interpreted as meters. Currently, the display scale only considers the latitude of\nthe first vertex of each line string (see [this issue](https://github.com/rerun-io/rerun/issues/8013)).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the line strings.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.GeoPoints"),
            ArchetypeReflection {
                display_name: "Geo points",
                deprecation_summary: None,
                scope: None,
                view_types: &["MapView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "positions",
                        display_name: "Positions",
                        component_type: "rerun.components.LatLon".into(),
                        docstring_md: "The [EPSG:4326](https://epsg.io/4326) coordinates for the points (North/East-positive degrees).",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the points, effectively turning them into circles.\n\n*Note*: scene units radiii are interpreted as meters.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the points.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional class Ids for the points.\n\nThe [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) provides colors if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.GraphEdges"),
            ArchetypeReflection {
                display_name: "Graph edges",
                deprecation_summary: None,
                scope: None,
                view_types: &["GraphView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "edges",
                        display_name: "Edges",
                        component_type: "rerun.components.GraphEdge".into(),
                        docstring_md: "A list of node tuples.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "graph_type",
                        display_name: "Graph type",
                        component_type: "rerun.components.GraphType".into(),
                        docstring_md: "Specifies if the graph is directed or undirected.\n\nIf no [`components.GraphType`](https://rerun.io/docs/reference/types/components/graph_type) is provided, the graph is assumed to be undirected.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.GraphNodes"),
            ArchetypeReflection {
                display_name: "Graph nodes",
                deprecation_summary: None,
                scope: None,
                view_types: &["GraphView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "node_ids",
                        display_name: "Node ids",
                        component_type: "rerun.components.GraphNode".into(),
                        docstring_md: "A list of node IDs.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "positions",
                        display_name: "Positions",
                        component_type: "rerun.components.Position2D".into(),
                        docstring_md: "Optional center positions of the nodes.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the boxes.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the node.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for nodes.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Image"),
            ArchetypeReflection {
                display_name: "Image",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "buffer",
                        display_name: "Buffer",
                        component_type: "rerun.components.ImageBuffer".into(),
                        docstring_md: "The raw image data.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "format",
                        display_name: "Format",
                        component_type: "rerun.components.ImageFormat".into(),
                        docstring_md: "The format of the image.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "opacity",
                        display_name: "Opacity",
                        component_type: "rerun.components.Opacity".into(),
                        docstring_md: "Opacity of the image, useful for layering several media.\n\nDefaults to 1.0 (fully opaque).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "An optional floating point value that specifies the 2D drawing order.\n\nObjects with higher values are drawn on top of those with lower values.\nDefaults to `-10.0`.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.InstancePoses3D"),
            ArchetypeReflection {
                display_name: "Instance poses 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "translations",
                        display_name: "Translations",
                        component_type: "rerun.components.Translation3D".into(),
                        docstring_md: "Translation vectors.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "rotation_axis_angles",
                        display_name: "Rotation axis angles",
                        component_type: "rerun.components.RotationAxisAngle".into(),
                        docstring_md: "Rotations via axis + angle.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "quaternions",
                        display_name: "Quaternions",
                        component_type: "rerun.components.RotationQuat".into(),
                        docstring_md: "Rotations via quaternion.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "scales",
                        display_name: "Scales",
                        component_type: "rerun.components.Scale3D".into(),
                        docstring_md: "Scaling factors.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "mat3x3",
                        display_name: "Mat 3x 3",
                        component_type: "rerun.components.TransformMat3x3".into(),
                        docstring_md: "3x3 transformation matrices.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.LineStrips2D"),
            ArchetypeReflection {
                display_name: "Line strips 2D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "strips",
                        display_name: "Strips",
                        component_type: "rerun.components.LineStrip2D".into(),
                        docstring_md: "All the actual 2D line strips that make up the batch.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the line strips.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the line strips.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the line strips.\n\nIf there's a single label present, it will be placed at the center of the entity.\nOtherwise, each instance will have its own label.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "An optional floating point value that specifies the 2D drawing order of each line strip.\n\nObjects with higher values are drawn on top of those with lower values.\nDefaults to `20.0`.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id)s for the lines.\n\nThe [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.LineStrips3D"),
            ArchetypeReflection {
                display_name: "Line strips 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "strips",
                        display_name: "Strips",
                        component_type: "rerun.components.LineStrip3D".into(),
                        docstring_md: "All the actual 3D line strips that make up the batch.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the line strips.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the line strips.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the line strips.\n\nIf there's a single label present, it will be placed at the center of the entity.\nOtherwise, each instance will have its own label.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id)s for the lines.\n\nThe [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.McapChannel"),
            ArchetypeReflection {
                display_name: "Mcap channel",
                deprecation_summary: None,
                scope: None,
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "id",
                        display_name: "Id",
                        component_type: "rerun.components.ChannelId".into(),
                        docstring_md: "Unique identifier for this channel within the MCAP file.\n\nChannel IDs must be unique within a single MCAP file and are used to associate\nmessages with their corresponding channel definition.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "topic",
                        display_name: "Topic",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "The topic name that this channel publishes to.\n\nTopics are hierarchical paths from the original robotics system (e.g., \"/sensors/camera/image\")\nthat categorize and organize different data streams.\nTopics are separate from Rerun's entity paths, but they often can be mapped to them.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "message_encoding",
                        display_name: "Message encoding",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "The encoding format used for messages in this channel.\n\nCommon encodings include:\n* `ros1` - ROS1 message format\n* `cdr` - Common Data Representation (CDR) message format, used by ROS2\n* `protobuf` - Protocol Buffers\n* `json` - JSON encoding",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "metadata",
                        display_name: "Metadata",
                        component_type: "rerun.components.KeyValuePairs".into(),
                        docstring_md: "Additional metadata for this channel stored as key-value pairs.\n\nThis can include channel-specific configuration, description, units, coordinate frames,\nor any other contextual information that helps interpret the data in this channel.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.McapMessage"),
            ArchetypeReflection {
                display_name: "Mcap message",
                deprecation_summary: None,
                scope: None,
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "data",
                    display_name: "Data",
                    component_type: "rerun.components.Blob".into(),
                    docstring_md: "The raw message payload as a binary blob.\n\nThis contains the actual message data encoded according to the format specified\nby the associated channel's `message_encoding` field. The structure and interpretation\nof this binary data depends on the encoding format (e.g., ros1, cdr, protobuf)\nand the message schema defined for the channel.",
                    is_required: true,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.McapSchema"),
            ArchetypeReflection {
                display_name: "Mcap schema",
                deprecation_summary: None,
                scope: None,
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "id",
                        display_name: "Id",
                        component_type: "rerun.components.SchemaId".into(),
                        docstring_md: "Unique identifier for this schema within the MCAP file.\n\nSchema IDs must be unique within an MCAP file and are referenced by channels\nto specify their message structure. A single schema can be shared across multiple channels.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "name",
                        display_name: "Name",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Human-readable name identifying this schema.\n\nSchema names typically describe the message type or data structure\n(e.g., `\"geometry_msgs/msg/Twist\"`, `\"sensor_msgs/msg/Image\"`, `\"MyCustomMessage\"`).",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "encoding",
                        display_name: "Encoding",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "The schema definition format used to describe the message structure.\n\nCommon schema encodings include:\n* `protobuf` - [Protocol Buffers](https://mcap.dev/spec/registry#protobuf-1) schema definition\n* `ros1msg` - [ROS1](https://mcap.dev/spec/registry#ros1msg) message definition format\n* `ros2msg` - [ROS2](https://mcap.dev/spec/registry#ros2msg) message definition format\n* `jsonschema` - [JSON Schema](https://mcap.dev/spec/registry#jsonschema) specification\n* `flatbuffer` - [FlatBuffers](https://mcap.dev/spec/registry#flatbuffer) schema definition",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "data",
                        display_name: "Data",
                        component_type: "rerun.components.Blob".into(),
                        docstring_md: "The schema definition content as binary data.\n\nThis contains the actual schema specification in the format indicated by the\n`encoding` field. For text-based schemas (like ROS message definitions or JSON Schema),\nthis is typically UTF-8 encoded text. For binary schema formats, this contains\nthe serialized schema data.",
                        is_required: true,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.McapStatistics"),
            ArchetypeReflection {
                display_name: "Mcap statistics",
                deprecation_summary: None,
                scope: None,
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "message_count",
                        display_name: "Message count",
                        component_type: "rerun.components.Count".into(),
                        docstring_md: "Total number of data messages contained in the MCAP recording.\n\nThis count includes all timestamped data messages but excludes metadata records,\nschema definitions, and other non-message records.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "schema_count",
                        display_name: "Schema count",
                        component_type: "rerun.components.Count".into(),
                        docstring_md: "Number of unique schema definitions in the recording.\n\nEach schema defines the structure for one or more message types used by channels.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "channel_count",
                        display_name: "Channel count",
                        component_type: "rerun.components.Count".into(),
                        docstring_md: "Number of channels defined in the recording.\n\nEach channel represents a unique topic and encoding combination for publishing messages.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "attachment_count",
                        display_name: "Attachment count",
                        component_type: "rerun.components.Count".into(),
                        docstring_md: "Number of file attachments embedded in the recording.\n\nAttachments can include calibration files, configuration data, or other auxiliary files.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "metadata_count",
                        display_name: "Metadata count",
                        component_type: "rerun.components.Count".into(),
                        docstring_md: "Number of metadata records providing additional context about the recording.\n\nMetadata records contain key-value pairs with information about the recording environment,\nsystem configuration, or other contextual data.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "chunk_count",
                        display_name: "Chunk count",
                        component_type: "rerun.components.Count".into(),
                        docstring_md: "Number of data chunks used to organize messages in the file.\n\nChunks group related messages together for efficient storage and indexed access.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "message_start_time",
                        display_name: "Message start time",
                        component_type: "rerun.components.Timestamp".into(),
                        docstring_md: "Timestamp of the earliest message in the recording.\n\nThis marks the beginning of the recorded data timeline.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "message_end_time",
                        display_name: "Message end time",
                        component_type: "rerun.components.Timestamp".into(),
                        docstring_md: "Timestamp of the latest message in the recording.\n\nTogether with `message_start_time`, this defines the total duration of the recording.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "channel_message_counts",
                        display_name: "Channel message counts",
                        component_type: "rerun.components.ChannelMessageCounts".into(),
                        docstring_md: "Detailed breakdown of message counts per channel.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Mesh3D"),
            ArchetypeReflection {
                display_name: "Mesh 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "vertex_positions",
                        display_name: "Vertex positions",
                        component_type: "rerun.components.Position3D".into(),
                        docstring_md: "The positions of each vertex.\n\nIf no `triangle_indices` are specified, then each triplet of positions is interpreted as a triangle.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "triangle_indices",
                        display_name: "Triangle indices",
                        component_type: "rerun.components.TriangleIndices".into(),
                        docstring_md: "Optional indices for the triangles that make up the mesh.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "vertex_normals",
                        display_name: "Vertex normals",
                        component_type: "rerun.components.Vector3D".into(),
                        docstring_md: "An optional normal for each vertex.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "vertex_colors",
                        display_name: "Vertex colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "An optional color for each vertex.\n\nThe alpha channel is ignored.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "vertex_texcoords",
                        display_name: "Vertex texcoords",
                        component_type: "rerun.components.Texcoord2D".into(),
                        docstring_md: "An optional uv texture coordinate for each vertex.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "albedo_factor",
                        display_name: "Albedo factor",
                        component_type: "rerun.components.AlbedoFactor".into(),
                        docstring_md: "A color multiplier applied to the whole mesh.\n\nAlpha channel governs the overall mesh transparency.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "albedo_texture_buffer",
                        display_name: "Albedo texture buffer",
                        component_type: "rerun.components.ImageBuffer".into(),
                        docstring_md: "Optional albedo texture.\n\nUsed with the [`components.Texcoord2D`](https://rerun.io/docs/reference/types/components/texcoord2d) of the mesh.\n\nCurrently supports only sRGB(A) textures, ignoring alpha.\n(meaning that the tensor must have 3 or 4 channels and use the `u8` format)\n\nThe alpha channel is ignored.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "albedo_texture_format",
                        display_name: "Albedo texture format",
                        component_type: "rerun.components.ImageFormat".into(),
                        docstring_md: "The format of the `albedo_texture_buffer`, if any.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional class Ids for the vertices.\n\nThe [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Pinhole"),
            ArchetypeReflection {
                display_name: "Pinhole",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "image_from_camera",
                        display_name: "Image from camera",
                        component_type: "rerun.components.PinholeProjection".into(),
                        docstring_md: "Camera projection, from image coordinates to view coordinates.\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "resolution",
                        display_name: "Resolution",
                        component_type: "rerun.components.Resolution".into(),
                        docstring_md: "Pixel resolution (usually integers) of child image space. Width and height.\n\nExample:\n```text\n[1920.0, 1440.0]\n```\n\n`image_from_camera` project onto the space spanned by `(0,0)` and `resolution - 1`.\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "camera_xyz",
                        display_name: "Camera xyz",
                        component_type: "rerun.components.ViewCoordinates".into(),
                        docstring_md: "Sets the view coordinates for the camera.\n\nAll common values are available as constants on the [`components.ViewCoordinates`](https://rerun.io/docs/reference/types/components/view_coordinates) class.\n\nThe default is `ViewCoordinates::RDF`, i.e. X=Right, Y=Down, Z=Forward, and this is also the recommended setting.\nThis means that the camera frustum will point along the positive Z axis of the parent space,\nand the cameras \"up\" direction will be along the negative Y axis of the parent space.\n\nThe camera frustum will point whichever axis is set to `F` (or the opposite of `B`).\nWhen logging a depth image under this entity, this is the direction the point cloud will be projected.\nWith `RDF`, the default forward is +Z.\n\nThe frustum's \"up\" direction will be whichever axis is set to `U` (or the opposite of `D`).\nThis will match the negative Y direction of pixel space (all images are assumed to have xyz=RDF).\nWith `RDF`, the default is up is -Y.\n\nThe frustum's \"right\" direction will be whichever axis is set to `R` (or the opposite of `L`).\nThis will match the positive X direction of pixel space (all images are assumed to have xyz=RDF).\nWith `RDF`, the default right is +x.\n\nOther common formats are `RUB` (X=Right, Y=Up, Z=Back) and `FLU` (X=Forward, Y=Left, Z=Up).\n\nNOTE: setting this to something else than `RDF` (the default) will change the orientation of the camera frustum,\nand make the pinhole matrix not match up with the coordinate system of the pinhole entity.\n\nThe pinhole matrix (the `image_from_camera` argument) always project along the third (Z) axis,\nbut will be re-oriented to project along the forward axis of the `camera_xyz` argument.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "child_frame",
                        display_name: "Child frame",
                        component_type: "rerun.components.TransformFrameId".into(),
                        docstring_md: "The child frame this transform transforms from.\n\nThe entity at which the transform relationship of any given child frame is specified mustn't change over time, but is allowed to be different for static time.\nE.g. if you specified the child frame `\"robot_arm\"` on an entity named `\"my_transforms\"`, you may not log transforms\nwith the child frame `\"robot_arm\"` on any other entity than `\"my_transforms\"` unless one of them was logged with static time.\n\nIf not specified, this is set to the implicit transform frame of the current entity path.\nThis means that if a [`archetypes.Transform3D`](https://rerun.io/docs/reference/types/archetypes/transform3d) is set on an entity called `/my/entity/path` then this will default to `tf#/my/entity/path`.\n\nTo set the frame an entity is part of see [`archetypes.CoordinateFrame`](https://rerun.io/docs/reference/types/archetypes/coordinate_frame).\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "parent_frame",
                        display_name: "Parent frame",
                        component_type: "rerun.components.TransformFrameId".into(),
                        docstring_md: "The parent frame this transform transforms into.\n\nIf not specified, this is set to the implicit transform frame of the current entity path's parent.\nThis means that if a [`archetypes.Transform3D`](https://rerun.io/docs/reference/types/archetypes/transform3d) is set on an entity called `/my/entity/path` then this will default to `tf#/my/entity`.\n\nTo set the frame an entity is part of see [`archetypes.CoordinateFrame`](https://rerun.io/docs/reference/types/archetypes/coordinate_frame).\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "image_plane_distance",
                        display_name: "Image plane distance",
                        component_type: "rerun.components.ImagePlaneDistance".into(),
                        docstring_md: "The distance from the camera origin to the image plane when the projection is shown in a 3D viewer.\n\nThis is only used for visualization purposes, and does not affect the projection itself.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "color",
                        display_name: "Color",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Color of the camera wireframe.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "line_width",
                        display_name: "Line width",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Width of the camera wireframe lines.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Points2D"),
            ArchetypeReflection {
                display_name: "Points 2D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "positions",
                        display_name: "Positions",
                        component_type: "rerun.components.Position2D".into(),
                        docstring_md: "All the 2D positions at which the point cloud shows points.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the points, effectively turning them into circles.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the points.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the points.\n\nIf there's a single label present, it will be placed at the center of the entity.\nOtherwise, each instance will have its own label.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "An optional floating point value that specifies the 2D drawing order.\n\nObjects with higher values are drawn on top of those with lower values.\nDefaults to `30.0`.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional class Ids for the points.\n\nThe [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "keypoint_ids",
                        display_name: "Keypoint ids",
                        component_type: "rerun.components.KeypointId".into(),
                        docstring_md: "Optional keypoint IDs for the points, identifying them within a class.\n\nIf keypoint IDs are passed in but no [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id)s were specified, the [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) will\ndefault to 0.\nThis is useful to identify points within a single classification (which is identified\nwith `class_id`).\nE.g. the classification might be 'Person' and the keypoints refer to joints on a\ndetected skeleton.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Points3D"),
            ArchetypeReflection {
                display_name: "Points 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "positions",
                        display_name: "Positions",
                        component_type: "rerun.components.Position3D".into(),
                        docstring_md: "All the 3D positions at which the point cloud shows points.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "radii",
                        display_name: "Radii",
                        component_type: "rerun.components.Radius".into(),
                        docstring_md: "Optional radii for the points, effectively turning them into circles.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional colors for the points.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "labels",
                        display_name: "Labels",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Optional text labels for the points.\n\nIf there's a single label present, it will be placed at the center of the entity.\nOtherwise, each instance will have its own label.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_labels",
                        display_name: "Show labels",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether the text labels should be shown.\n\nIf not set, labels will automatically appear when there is exactly one label for this entity\nor the number of instances on this entity is under a certain threshold.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "class_ids",
                        display_name: "Class ids",
                        component_type: "rerun.components.ClassId".into(),
                        docstring_md: "Optional class Ids for the points.\n\nThe [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) provides colors and labels if not specified explicitly.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "keypoint_ids",
                        display_name: "Keypoint ids",
                        component_type: "rerun.components.KeypointId".into(),
                        docstring_md: "Optional keypoint IDs for the points, identifying them within a class.\n\nIf keypoint IDs are passed in but no [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id)s were specified, the [`components.ClassId`](https://rerun.io/docs/reference/types/components/class_id) will\ndefault to 0.\nThis is useful to identify points within a single classification (which is identified\nwith `class_id`).\nE.g. the classification might be 'Person' and the keypoints refer to joints on a\ndetected skeleton.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.RecordingInfo"),
            ArchetypeReflection {
                display_name: "Recording info",
                deprecation_summary: None,
                scope: None,
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "start_time",
                        display_name: "Start time",
                        component_type: "rerun.components.Timestamp".into(),
                        docstring_md: "When the recording started.\n\nShould be an absolute time, i.e. relative to Unix Epoch.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "name",
                        display_name: "Name",
                        component_type: "rerun.components.Name".into(),
                        docstring_md: "A user-chosen name for the recording.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Scalars"),
            ArchetypeReflection {
                display_name: "Scalars",
                deprecation_summary: None,
                scope: None,
                view_types: &["TimeSeriesView"],
                fields: vec![ArchetypeFieldReflection {
                    name: "scalars",
                    display_name: "Scalars",
                    component_type: "rerun.components.Scalar".into(),
                    docstring_md: "The scalar values to log.",
                    is_required: true,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.SegmentationImage"),
            ArchetypeReflection {
                display_name: "Segmentation image",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "buffer",
                        display_name: "Buffer",
                        component_type: "rerun.components.ImageBuffer".into(),
                        docstring_md: "The raw image data.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "format",
                        display_name: "Format",
                        component_type: "rerun.components.ImageFormat".into(),
                        docstring_md: "The format of the image.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "opacity",
                        display_name: "Opacity",
                        component_type: "rerun.components.Opacity".into(),
                        docstring_md: "Opacity of the image, useful for layering the segmentation image on top of another image.\n\nDefaults to 0.5 if there's any other images in the scene, otherwise 1.0.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "An optional floating point value that specifies the 2D drawing order.\n\nObjects with higher values are drawn on top of those with lower values.\nDefaults to `0.0`.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.SeriesLines"),
            ArchetypeReflection {
                display_name: "Series lines",
                deprecation_summary: None,
                scope: None,
                view_types: &["TimeSeriesView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Color for the corresponding series.\n\nMay change over time, but can cause discontinuities in the line.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "widths",
                        display_name: "Widths",
                        component_type: "rerun.components.StrokeWidth".into(),
                        docstring_md: "Stroke width for the corresponding series.\n\nMay change over time, but can cause discontinuities in the line.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "names",
                        display_name: "Names",
                        component_type: "rerun.components.Name".into(),
                        docstring_md: "Display name of the series.\n\nUsed in the legend. Expected to be unchanging over time.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "visible_series",
                        display_name: "Visible series",
                        component_type: "rerun.components.SeriesVisible".into(),
                        docstring_md: "Which lines are visible.\n\nIf not set, all line series on this entity are visible.\nUnlike with the regular visibility property of the entire entity, any series that is hidden\nvia this property will still be visible in the legend.\n\nMay change over time, but can cause discontinuities in the line.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "aggregation_policy",
                        display_name: "Aggregation policy",
                        component_type: "rerun.components.AggregationPolicy".into(),
                        docstring_md: "Configures the zoom-dependent scalar aggregation.\n\nThis is done only if steps on the X axis go below a single pixel,\ni.e. a single pixel covers more than one tick worth of data. It can greatly improve performance\n(and readability) in such situations as it prevents overdraw.\n\nExpected to be unchanging over time.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.SeriesPoints"),
            ArchetypeReflection {
                display_name: "Series points",
                deprecation_summary: None,
                scope: None,
                view_types: &["TimeSeriesView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "colors",
                        display_name: "Colors",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Color for the corresponding series.\n\nMay change over time, but can cause discontinuities in the line.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "markers",
                        display_name: "Markers",
                        component_type: "rerun.components.MarkerShape".into(),
                        docstring_md: "What shape to use to represent the point\n\nMay change over time.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "names",
                        display_name: "Names",
                        component_type: "rerun.components.Name".into(),
                        docstring_md: "Display name of the series.\n\nUsed in the legend. Expected to be unchanging over time.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "visible_series",
                        display_name: "Visible series",
                        component_type: "rerun.components.SeriesVisible".into(),
                        docstring_md: "Which lines are visible.\n\nIf not set, all line series on this entity are visible.\nUnlike with the regular visibility property of the entire entity, any series that is hidden\nvia this property will still be visible in the legend.\n\nMay change over time.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "marker_sizes",
                        display_name: "Marker sizes",
                        component_type: "rerun.components.MarkerSize".into(),
                        docstring_md: "Sizes of the markers.\n\nMay change over time.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Tensor"),
            ArchetypeReflection {
                display_name: "Tensor",
                deprecation_summary: None,
                scope: None,
                view_types: &["TensorView", "BarChartView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "data",
                        display_name: "Data",
                        component_type: "rerun.components.TensorData".into(),
                        docstring_md: "The tensor data",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "value_range",
                        display_name: "Value range",
                        component_type: "rerun.components.ValueRange".into(),
                        docstring_md: "The expected range of values.\n\nThis is typically the expected range of valid values.\nEverything outside of the range is clamped to the range for the purpose of colormpaping.\nAny colormap applied for display, will map this range.\n\nIf not specified, the range will be automatically estimated from the data.\nNote that the Viewer may try to guess a wider range than the minimum/maximum of values\nin the contents of the tensor.\nE.g. if all values are positive, some bigger than 1.0 and all smaller than 255.0,\nthe Viewer will guess that the data likely came from an 8bit image, thus assuming a range of 0-255.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.TextDocument"),
            ArchetypeReflection {
                display_name: "Text document",
                deprecation_summary: None,
                scope: None,
                view_types: &["TextDocumentView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "text",
                        display_name: "Text",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "Contents of the text document.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "media_type",
                        display_name: "Media type",
                        component_type: "rerun.components.MediaType".into(),
                        docstring_md: "The Media Type of the text.\n\nFor instance:\n* `text/plain`\n* `text/markdown`\n\nIf omitted, `text/plain` is assumed.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.TextLog"),
            ArchetypeReflection {
                display_name: "Text log",
                deprecation_summary: None,
                scope: None,
                view_types: &["TextLogView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "text",
                        display_name: "Text",
                        component_type: "rerun.components.Text".into(),
                        docstring_md: "The body of the message.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "level",
                        display_name: "Level",
                        component_type: "rerun.components.TextLogLevel".into(),
                        docstring_md: "The verbosity level of the message.\n\nThis can be used to filter the log messages in the Rerun Viewer.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "color",
                        display_name: "Color",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Optional color to use for the log line in the Rerun Viewer.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.Transform3D"),
            ArchetypeReflection {
                display_name: "Transform 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView", "Spatial2DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "translation",
                        display_name: "Translation",
                        component_type: "rerun.components.Translation3D".into(),
                        docstring_md: "Translation vector.\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "rotation_axis_angle",
                        display_name: "Rotation axis angle",
                        component_type: "rerun.components.RotationAxisAngle".into(),
                        docstring_md: "Rotation via axis + angle.\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "quaternion",
                        display_name: "Quaternion",
                        component_type: "rerun.components.RotationQuat".into(),
                        docstring_md: "Rotation via quaternion.\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "scale",
                        display_name: "Scale",
                        component_type: "rerun.components.Scale3D".into(),
                        docstring_md: "Scaling factor.\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "mat3x3",
                        display_name: "Mat 3x 3",
                        component_type: "rerun.components.TransformMat3x3".into(),
                        docstring_md: "3x3 transformation matrix.\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "relation",
                        display_name: "Relation",
                        component_type: "rerun.components.TransformRelation".into(),
                        docstring_md: "Specifies the relation this transform establishes between this entity and its parent.\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "child_frame",
                        display_name: "Child frame",
                        component_type: "rerun.components.TransformFrameId".into(),
                        docstring_md: "The child frame this transform transforms from.\n\nThe entity at which the transform relationship of any given child frame is specified mustn't change over time, but is allowed to be different for static time.\nE.g. if you specified the child frame `\"robot_arm\"` on an entity named `\"my_transforms\"`, you may not log transforms\nwith the child frame `\"robot_arm\"` on any other entity than `\"my_transforms\"` unless one of them was logged with static time.\n\nIf not specified, this is set to the implicit transform frame of the current entity path.\nThis means that if a [`archetypes.Transform3D`](https://rerun.io/docs/reference/types/archetypes/transform3d) is set on an entity called `/my/entity/path` then this will default to `tf#/my/entity/path`.\n\nTo set the frame an entity is part of see [`archetypes.CoordinateFrame`](https://rerun.io/docs/reference/types/archetypes/coordinate_frame).\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "parent_frame",
                        display_name: "Parent frame",
                        component_type: "rerun.components.TransformFrameId".into(),
                        docstring_md: "The parent frame this transform transforms into.\n\nIf not specified, this is set to the implicit transform frame of the current entity path's parent.\nThis means that if a [`archetypes.Transform3D`](https://rerun.io/docs/reference/types/archetypes/transform3d) is set on an entity called `/my/entity/path` then this will default to `tf#/my/entity`.\n\nTo set the frame an entity is part of see [`archetypes.CoordinateFrame`](https://rerun.io/docs/reference/types/archetypes/coordinate_frame).\n\nAny update to this field will reset all other transform properties that aren't changed in the same log call or `send_columns` row.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.TransformAxes3D"),
            ArchetypeReflection {
                display_name: "Transform axes 3D",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "axis_length",
                        display_name: "Axis length",
                        component_type: "rerun.components.AxisLength".into(),
                        docstring_md: "Visual length of the 3 axes.\n\nThe length is interpreted in the local coordinate system of the transform.\nIf the transform is scaled, the axes will be scaled accordingly.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "show_frame",
                        display_name: "Show frame",
                        component_type: "rerun.components.ShowLabels".into(),
                        docstring_md: "Whether to show a text label with the corresponding frame.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.VideoFrameReference"),
            ArchetypeReflection {
                display_name: "Video frame reference",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "timestamp",
                        display_name: "Timestamp",
                        component_type: "rerun.components.VideoTimestamp".into(),
                        docstring_md: "References the closest video frame to this timestamp.\n\nNote that this uses the closest video frame instead of the latest at this timestamp\nin order to be more forgiving of rounding errors for inprecise timestamp types.\n\nTimestamps are relative to the start of the video, i.e. a timestamp of 0 always corresponds to the first frame.\nThis is oftentimes equivalent to presentation timestamps (known as PTS), but in the presence of B-frames\n(bidirectionally predicted frames) there may be an offset on the first presentation timestamp in the video.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "video_reference",
                        display_name: "Video reference",
                        component_type: "rerun.components.EntityPath".into(),
                        docstring_md: "Optional reference to an entity with a [`archetypes.AssetVideo`](https://rerun.io/docs/reference/types/archetypes/asset_video).\n\nIf none is specified, the video is assumed to be at the same entity.\nNote that blueprint overrides on the referenced video will be ignored regardless,\nas this is always interpreted as a reference to the data store.\n\nFor a series of video frame references, it is recommended to specify this path only once\nat the beginning of the series and then rely on latest-at query semantics to\nkeep the video reference active.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "opacity",
                        display_name: "Opacity",
                        component_type: "rerun.components.Opacity".into(),
                        docstring_md: "Opacity of the video, useful for layering several media.\n\nDefaults to 1.0 (fully opaque).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "An optional floating point value that specifies the 2D drawing order.\n\nObjects with higher values are drawn on top of those with lower values.\nDefaults to `-15.0`.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.VideoStream"),
            ArchetypeReflection {
                display_name: "Video stream",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial2DView", "Spatial3DView"],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "codec",
                        display_name: "Codec",
                        component_type: "rerun.components.VideoCodec".into(),
                        docstring_md: "The codec used to encode the video chunks.\n\nThis property is expected to be constant over time and is ideally logged statically once per stream.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "sample",
                        display_name: "Sample",
                        component_type: "rerun.components.VideoSample".into(),
                        docstring_md: "Video sample data (also known as \"video chunk\").\n\nThe current timestamp is used as presentation timestamp (PTS) for all data in this sample.\nThere is currently no way to log differing decoding timestamps, meaning\nthat there is no support for B-frames.\nSee <https://github.com/rerun-io/rerun/issues/10090> for more details.\n\nRerun chunks containing frames (i.e. bundles of sample data) may arrive out of order,\nbut may cause the video playback in the Viewer to reset.\nIt is recommended to have all chunks for a video stream to be ordered temporally order.\n\nLogging separate videos on the same entity is allowed iff they share the exact same\ncodec parameters & resolution.\n\nThe samples are expected to be encoded using the `codec` field.\nEach video sample must contain enough data for exactly one video frame\n(this restriction may be relaxed in the future for some codecs).\n\nUnless your stream consists entirely of key-frames (in which case you should consider [`archetypes.EncodedImage`](https://rerun.io/docs/reference/types/archetypes/encoded_image))\nnever log this component as static data as this means that you loose all information of\nprevious samples which may be required to decode an image.\n\nSee [`components.VideoCodec`](https://rerun.io/docs/reference/types/components/video_codec) for codec specific requirements.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "opacity",
                        display_name: "Opacity",
                        component_type: "rerun.components.Opacity".into(),
                        docstring_md: "Opacity of the video stream, useful for layering several media.\n\nDefaults to 1.0 (fully opaque).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "draw_order",
                        display_name: "Draw order",
                        component_type: "rerun.components.DrawOrder".into(),
                        docstring_md: "An optional floating point value that specifies the 2D drawing order.\n\nObjects with higher values are drawn on top of those with lower values.\nDefaults to `-15.0`.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.archetypes.ViewCoordinates"),
            ArchetypeReflection {
                display_name: "View coordinates",
                deprecation_summary: None,
                scope: None,
                view_types: &["Spatial3DView"],
                fields: vec![ArchetypeFieldReflection {
                    name: "xyz",
                    display_name: "Xyz",
                    component_type: "rerun.components.ViewCoordinates".into(),
                    docstring_md: "The directions of the [x, y, z] axes.",
                    is_required: true,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ActiveVisualizers"),
            ArchetypeReflection {
                display_name: "Active visualizers",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "instruction_ids",
                    display_name: "Instruction ids",
                    component_type: "rerun.blueprint.components.VisualizerInstructionId".into(),
                    docstring_md: "Id's of the visualizers that should be active.",
                    is_required: true,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.Background"),
            ArchetypeReflection {
                display_name: "Background",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "kind",
                        display_name: "Kind",
                        component_type: "rerun.blueprint.components.BackgroundKind".into(),
                        docstring_md: "The type of the background.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "color",
                        display_name: "Color",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Color used for the solid background type.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ContainerBlueprint"),
            ArchetypeReflection {
                display_name: "Container blueprint",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "container_kind",
                        display_name: "Container kind",
                        component_type: "rerun.blueprint.components.ContainerKind".into(),
                        docstring_md: "The class of the view.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "display_name",
                        display_name: "Display name",
                        component_type: "rerun.components.Name".into(),
                        docstring_md: "The name of the container.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "contents",
                        display_name: "Contents",
                        component_type: "rerun.blueprint.components.IncludedContent".into(),
                        docstring_md: "`ContainerId`s or `ViewId`s that are children of this container.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "col_shares",
                        display_name: "Col shares",
                        component_type: "rerun.blueprint.components.ColumnShare".into(),
                        docstring_md: "The layout shares of each column in the container.\n\nFor components.ContainerKind containers, the length of this list should always match the number of contents.\n\nIgnored for components.ContainerKind containers.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "row_shares",
                        display_name: "Row shares",
                        component_type: "rerun.blueprint.components.RowShare".into(),
                        docstring_md: "The layout shares of each row of the container.\n\nFor components.ContainerKind containers, the length of this list should always match the number of contents.\n\nIgnored for components.ContainerKind containers.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "active_tab",
                        display_name: "Active tab",
                        component_type: "rerun.blueprint.components.ActiveTab".into(),
                        docstring_md: "Which tab is active.\n\nOnly applies to `Tabs` containers.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "visible",
                        display_name: "Visible",
                        component_type: "rerun.components.Visible".into(),
                        docstring_md: "Whether this container is visible.\n\nDefaults to true if not specified.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "grid_columns",
                        display_name: "Grid columns",
                        component_type: "rerun.blueprint.components.GridColumns".into(),
                        docstring_md: "How many columns this grid should have.\n\nIf unset, the grid layout will be auto.\n\nIgnored for components.ContainerKind/components.ContainerKind containers.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.DataframeQuery"),
            ArchetypeReflection {
                display_name: "Dataframe query",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "timeline",
                        display_name: "Timeline",
                        component_type: "rerun.blueprint.components.TimelineName".into(),
                        docstring_md: "The timeline for this query.\n\nIf unset, the timeline currently active on the time panel is used.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "filter_by_range",
                        display_name: "Filter by range",
                        component_type: "rerun.blueprint.components.FilterByRange".into(),
                        docstring_md: "If provided, only rows whose timestamp is within this range will be shown.\n\nNote: will be unset as soon as `timeline` is changed.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "filter_is_not_null",
                        display_name: "Filter is not null",
                        component_type: "rerun.blueprint.components.FilterIsNotNull".into(),
                        docstring_md: "If provided, only show rows which contains a logged event for the specified component.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "apply_latest_at",
                        display_name: "Apply latest at",
                        component_type: "rerun.blueprint.components.ApplyLatestAt".into(),
                        docstring_md: "Should empty cells be filled with latest-at queries?",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "select",
                        display_name: "Select",
                        component_type: "rerun.blueprint.components.SelectedColumns".into(),
                        docstring_md: "Selected columns. If unset, all columns are selected.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.EntityBehavior"),
            ArchetypeReflection {
                display_name: "Entity behavior",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "interactive",
                        display_name: "Interactive",
                        component_type: "rerun.components.Interactive".into(),
                        docstring_md: "Whether the entity can be interacted with.\n\nThis property is propagated down the entity hierarchy until another child entity\nsets `interactive` to a different value at which point propagation continues with that value instead.\n\nDefaults to parent's `interactive` value or true if there is no parent.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "visible",
                        display_name: "Visible",
                        component_type: "rerun.components.Visible".into(),
                        docstring_md: "Whether the entity is visible.\n\nThis property is propagated down the entity hierarchy until another child entity\nsets `visible` to a different value at which point propagation continues with that value instead.\n\nDefaults to parent's `visible` value or true if there is no parent.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.EyeControls3D"),
            ArchetypeReflection {
                display_name: "Eye controls 3D",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "kind",
                        display_name: "Kind",
                        component_type: "rerun.blueprint.components.Eye3DKind".into(),
                        docstring_md: "The kind of the eye for the spatial 3D view.\n\nThis controls how the eye movement behaves when the user interact with the view.\nDefaults to orbital.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "position",
                        display_name: "Position",
                        component_type: "rerun.components.Position3D".into(),
                        docstring_md: "The cameras current position.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "look_target",
                        display_name: "Look target",
                        component_type: "rerun.components.Position3D".into(),
                        docstring_md: "The position the camera is currently looking at.\n\nIf this is an orbital camera, this also is the center it orbits around.\n\nBy default this is the center of the scene bounds.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "eye_up",
                        display_name: "Eye up",
                        component_type: "rerun.components.Vector3D".into(),
                        docstring_md: "The up-axis of the eye itself, in world-space.\n\nInitially, the up-axis of the eye will be the same as the up-axis of the scene (or +Z if\nthe scene has no up axis defined).",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "speed",
                        display_name: "Speed",
                        component_type: "rerun.components.LinearSpeed".into(),
                        docstring_md: "Translation speed of the eye in the view (when using WASDQE keys to move in the 3D scene).\n\nThe default depends on the control kind.\nFor orbit cameras it is derived from the distance to the orbit center.\nFor first person cameras it is derived from the scene size.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "tracking_entity",
                        display_name: "Tracking entity",
                        component_type: "rerun.components.EntityPath".into(),
                        docstring_md: "Currently tracked entity.\n\nIf this is a camera, it takes over the camera pose, otherwise follows the entity.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "spin_speed",
                        display_name: "Spin speed",
                        component_type: "rerun.blueprint.components.AngularSpeed".into(),
                        docstring_md: "What speed, if any, the camera should spin around the eye-up axis.\n\nDefaults to zero, meaning no spinning.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ForceCenter"),
            ArchetypeReflection {
                display_name: "Force center",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "enabled",
                        display_name: "Enabled",
                        component_type: "rerun.blueprint.components.Enabled".into(),
                        docstring_md: "Whether the center force is enabled.\n\nThe center force tries to move the center of mass of the graph towards the origin.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "strength",
                        display_name: "Strength",
                        component_type: "rerun.blueprint.components.ForceStrength".into(),
                        docstring_md: "The strength of the force.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ForceCollisionRadius"),
            ArchetypeReflection {
                display_name: "Force collision radius",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "enabled",
                        display_name: "Enabled",
                        component_type: "rerun.blueprint.components.Enabled".into(),
                        docstring_md: "Whether the collision force is enabled.\n\nThe collision force resolves collisions between nodes based on the bounding circle defined by their radius.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "strength",
                        display_name: "Strength",
                        component_type: "rerun.blueprint.components.ForceStrength".into(),
                        docstring_md: "The strength of the force.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "iterations",
                        display_name: "Iterations",
                        component_type: "rerun.blueprint.components.ForceIterations".into(),
                        docstring_md: "Specifies how often this force should be applied per iteration.\n\nIncreasing this parameter can lead to better results at the cost of longer computation time.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ForceLink"),
            ArchetypeReflection {
                display_name: "Force link",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "enabled",
                        display_name: "Enabled",
                        component_type: "rerun.blueprint.components.Enabled".into(),
                        docstring_md: "Whether the link force is enabled.\n\nThe link force aims to achieve a target distance between two nodes that are connected by one ore more edges.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "distance",
                        display_name: "Distance",
                        component_type: "rerun.blueprint.components.ForceDistance".into(),
                        docstring_md: "The target distance between two nodes.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "iterations",
                        display_name: "Iterations",
                        component_type: "rerun.blueprint.components.ForceIterations".into(),
                        docstring_md: "Specifies how often this force should be applied per iteration.\n\nIncreasing this parameter can lead to better results at the cost of longer computation time.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ForceManyBody"),
            ArchetypeReflection {
                display_name: "Force many body",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "enabled",
                        display_name: "Enabled",
                        component_type: "rerun.blueprint.components.Enabled".into(),
                        docstring_md: "Whether the many body force is enabled.\n\nThe many body force is applied on each pair of nodes in a way that ressembles an electrical charge. If the\nstrength is smaller than 0, it pushes nodes apart; if it is larger than 0, it pulls them together.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "strength",
                        display_name: "Strength",
                        component_type: "rerun.blueprint.components.ForceStrength".into(),
                        docstring_md: "The strength of the force.\n\nIf `strength` is smaller than 0, it pushes nodes apart, if it is larger than 0 it pulls them together.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ForcePosition"),
            ArchetypeReflection {
                display_name: "Force position",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "enabled",
                        display_name: "Enabled",
                        component_type: "rerun.blueprint.components.Enabled".into(),
                        docstring_md: "Whether the position force is enabled.\n\nThe position force pulls nodes towards a specific position, similar to gravity.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "strength",
                        display_name: "Strength",
                        component_type: "rerun.blueprint.components.ForceStrength".into(),
                        docstring_md: "The strength of the force.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "position",
                        display_name: "Position",
                        component_type: "rerun.components.Position2D".into(),
                        docstring_md: "The position where the nodes should be pulled towards.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.GraphBackground"),
            ArchetypeReflection {
                display_name: "Graph background",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "color",
                    display_name: "Color",
                    component_type: "rerun.components.Color".into(),
                    docstring_md: "Color used for the background.",
                    is_required: false,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.LineGrid3D"),
            ArchetypeReflection {
                display_name: "Line grid 3D",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "visible",
                        display_name: "Visible",
                        component_type: "rerun.components.Visible".into(),
                        docstring_md: "Whether the grid is visible.\n\nDefaults to true.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "spacing",
                        display_name: "Spacing",
                        component_type: "rerun.blueprint.components.GridSpacing".into(),
                        docstring_md: "Space between grid lines spacing of one line to the next in scene units.\n\nAs you zoom out, successively only every tenth line is shown.\nThis controls the closest zoom level.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "plane",
                        display_name: "Plane",
                        component_type: "rerun.components.Plane3D".into(),
                        docstring_md: "In what plane the grid is drawn.\n\nDefaults to whatever plane is determined as the plane at zero units up/down as defined by [`components.ViewCoordinates`](https://rerun.io/docs/reference/types/components/view_coordinates) if present.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "stroke_width",
                        display_name: "Stroke width",
                        component_type: "rerun.components.StrokeWidth".into(),
                        docstring_md: "How thick the lines should be in ui units.\n\nDefault is 1.0 ui unit.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "color",
                        display_name: "Color",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Color used for the grid.\n\nTransparency via alpha channel is supported.\nDefaults to a slightly transparent light gray.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.MapBackground"),
            ArchetypeReflection {
                display_name: "Map background",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "provider",
                    display_name: "Provider",
                    component_type: "rerun.blueprint.components.MapProvider".into(),
                    docstring_md: "Map provider and style to use.\n\n**Note**: Requires a Mapbox API key in the `RERUN_MAPBOX_ACCESS_TOKEN` environment variable.",
                    is_required: false,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.MapZoom"),
            ArchetypeReflection {
                display_name: "Map zoom",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "zoom",
                    display_name: "Zoom",
                    component_type: "rerun.blueprint.components.ZoomLevel".into(),
                    docstring_md: "Zoom level for the map.\n\nZoom level follow the [`OpenStreetMap` definition](https://wiki.openstreetmap.org/wiki/Zoom_levels).",
                    is_required: false,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.NearClipPlane"),
            ArchetypeReflection {
                display_name: "Near clip plane",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "near_clip_plane",
                    display_name: "Near clip plane",
                    component_type: "rerun.blueprint.components.NearClipPlane".into(),
                    docstring_md: "Controls the distance to the near clip plane in 3D scene units.\n\nContent closer than this distance will not be visible.",
                    is_required: false,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.PanelBlueprint"),
            ArchetypeReflection {
                display_name: "Panel blueprint",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "state",
                    display_name: "State",
                    component_type: "rerun.blueprint.components.PanelState".into(),
                    docstring_md: "Current state of the panel.",
                    is_required: false,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.PlotBackground"),
            ArchetypeReflection {
                display_name: "Plot background",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "color",
                        display_name: "Color",
                        component_type: "rerun.components.Color".into(),
                        docstring_md: "Color used for the background.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_grid",
                        display_name: "Show grid",
                        component_type: "rerun.blueprint.components.Enabled".into(),
                        docstring_md: "Should the grid be drawn?",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.PlotLegend"),
            ArchetypeReflection {
                display_name: "Plot legend",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "corner",
                        display_name: "Corner",
                        component_type: "rerun.blueprint.components.Corner2D".into(),
                        docstring_md: "To what corner the legend is aligned.\n\nDefaults to the right bottom corner.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "visible",
                        display_name: "Visible",
                        component_type: "rerun.components.Visible".into(),
                        docstring_md: "Whether the legend is shown at all.\n\nTrue by default.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ScalarAxis"),
            ArchetypeReflection {
                display_name: "Scalar axis",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "range",
                        display_name: "Range",
                        component_type: "rerun.components.Range1D".into(),
                        docstring_md: "The range of the axis.\n\nIf unset, the range well be automatically determined based on the queried data.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "zoom_lock",
                        display_name: "Zoom lock",
                        component_type: "rerun.blueprint.components.LockRangeDuringZoom".into(),
                        docstring_md: "If enabled, the Y axis range will remain locked to the specified range when zooming.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.SpatialInformation"),
            ArchetypeReflection {
                display_name: "Spatial information",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "target_frame",
                        display_name: "Target frame",
                        component_type: "rerun.components.TransformFrameId".into(),
                        docstring_md: "The target reference frame for all transformations.\n\nDefaults to the coordinate frame used by the space origin entity.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_axes",
                        display_name: "Show axes",
                        component_type: "rerun.blueprint.components.Enabled".into(),
                        docstring_md: "Whether axes should be shown at the origin.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "show_bounding_box",
                        display_name: "Show bounding box",
                        component_type: "rerun.blueprint.components.Enabled".into(),
                        docstring_md: "Whether the bounding box should be shown.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.TensorScalarMapping"),
            ArchetypeReflection {
                display_name: "Tensor scalar mapping",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "mag_filter",
                        display_name: "Mag filter",
                        component_type: "rerun.components.MagnificationFilter".into(),
                        docstring_md: "Filter used when zooming in on the tensor.\n\nNote that the filter is applied to the scalar values *before* they are mapped to color.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "colormap",
                        display_name: "Colormap",
                        component_type: "rerun.components.Colormap".into(),
                        docstring_md: "How scalar values map to colors.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "gamma",
                        display_name: "Gamma",
                        component_type: "rerun.components.GammaCorrection".into(),
                        docstring_md: "Gamma exponent applied to normalized values before mapping to color.\n\nRaises the normalized values to the power of this value before mapping to color.\nActs like an inverse brightness. Defaults to 1.0.\n\nThe final value for display is set as:\n`colormap( ((value - data_display_range.min) / (data_display_range.max - data_display_range.min)) ** gamma )`",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.TensorSliceSelection"),
            ArchetypeReflection {
                display_name: "Tensor slice selection",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "width",
                        display_name: "Width",
                        component_type: "rerun.components.TensorWidthDimension".into(),
                        docstring_md: "Which dimension to map to width.\n\nIf not specified, the height will be determined automatically based on the name and index of the dimension.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "height",
                        display_name: "Height",
                        component_type: "rerun.components.TensorHeightDimension".into(),
                        docstring_md: "Which dimension to map to height.\n\nIf not specified, the height will be determined automatically based on the name and index of the dimension.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "indices",
                        display_name: "Indices",
                        component_type: "rerun.components.TensorDimensionIndexSelection".into(),
                        docstring_md: "Selected indices for all other dimensions.\n\nIf any of the here listed dimensions is equal to `width` or `height`, it will be ignored.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "slider",
                        display_name: "Slider",
                        component_type: "rerun.blueprint.components.TensorDimensionIndexSlider"
                            .into(),
                        docstring_md: "Any dimension listed here will have a slider for the index.\n\nEdits to the sliders will directly manipulate dimensions on the `indices` list.\nIf any of the here listed dimensions is equal to `width` or `height`, it will be ignored.\nIf not specified, adds slides for any dimension in `indices`.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.TensorViewFit"),
            ArchetypeReflection {
                display_name: "Tensor view fit",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "scaling",
                    display_name: "Scaling",
                    component_type: "rerun.blueprint.components.ViewFit".into(),
                    docstring_md: "How the image is scaled to fit the view.",
                    is_required: false,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.TextLogColumns"),
            ArchetypeReflection {
                display_name: "Text log columns",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "timeline_columns",
                        display_name: "Timeline columns",
                        component_type: "rerun.blueprint.components.TimelineColumn".into(),
                        docstring_md: "What timeline columns to show.\n\nDefaults to displaying all timelines.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "text_log_columns",
                        display_name: "Text log columns",
                        component_type: "rerun.blueprint.components.TextLogColumn".into(),
                        docstring_md: "All columns to be displayed.\n\nDefaults to showing all text log column kinds in the order of the enum.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.TextLogFormat"),
            ArchetypeReflection {
                display_name: "Text log format",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "monospace_body",
                    display_name: "Monospace body",
                    component_type: "rerun.blueprint.components.Enabled".into(),
                    docstring_md: "Whether to use a monospace font for the log message body.\n\nDefaults to not being enabled.",
                    is_required: false,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.TextLogRows"),
            ArchetypeReflection {
                display_name: "Text log rows",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "filter_by_log_level",
                    display_name: "Filter by log level",
                    component_type: "rerun.components.TextLogLevel".into(),
                    docstring_md: "Log levels to display.\n\nDefaults to showing all logged levels.",
                    is_required: false,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.TimeAxis"),
            ArchetypeReflection {
                display_name: "Time axis",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "link",
                        display_name: "Link",
                        component_type: "rerun.blueprint.components.LinkAxis".into(),
                        docstring_md: "How should the horizontal/X/time axis be linked across multiple plots?\n\nLinking with global will ignore `view_range`.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "view_range",
                        display_name: "View range",
                        component_type: "rerun.blueprint.components.TimeRange".into(),
                        docstring_md: "The view range of the horizontal/X/time axis.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "zoom_lock",
                        display_name: "Zoom lock",
                        component_type: "rerun.blueprint.components.LockRangeDuringZoom".into(),
                        docstring_md: "If enabled, the X axis range will remain locked to the specified range when zooming.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.TimePanelBlueprint"),
            ArchetypeReflection {
                display_name: "Time panel blueprint",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "state",
                        display_name: "State",
                        component_type: "rerun.blueprint.components.PanelState".into(),
                        docstring_md: "Current state of the panel.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "timeline",
                        display_name: "Timeline",
                        component_type: "rerun.blueprint.components.TimelineName".into(),
                        docstring_md: "What timeline the panel is on.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "playback_speed",
                        display_name: "Playback speed",
                        component_type: "rerun.blueprint.components.PlaybackSpeed".into(),
                        docstring_md: "A time playback speed multiplier.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "fps",
                        display_name: "Fps",
                        component_type: "rerun.blueprint.components.Fps".into(),
                        docstring_md: "Frames per second. Only applicable for sequence timelines.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "play_state",
                        display_name: "Play state",
                        component_type: "rerun.blueprint.components.PlayState".into(),
                        docstring_md: "If the time is currently paused, playing, or following.\n\nDefaults to either playing or following, depending on the data source.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "loop_mode",
                        display_name: "Loop mode",
                        component_type: "rerun.blueprint.components.LoopMode".into(),
                        docstring_md: "How the time should loop. A selection loop only works if there is also a `time_selection` passed.\n\nDefaults to off.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "time_selection",
                        display_name: "Time selection",
                        component_type: "rerun.blueprint.components.AbsoluteTimeRange".into(),
                        docstring_md: "Selects a range of time on the time panel.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ViewBlueprint"),
            ArchetypeReflection {
                display_name: "View blueprint",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "class_identifier",
                        display_name: "Class identifier",
                        component_type: "rerun.blueprint.components.ViewClass".into(),
                        docstring_md: "The class of the view.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "display_name",
                        display_name: "Display name",
                        component_type: "rerun.components.Name".into(),
                        docstring_md: "The name of the view.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "space_origin",
                        display_name: "Space origin",
                        component_type: "rerun.blueprint.components.ViewOrigin".into(),
                        docstring_md: "The \"anchor point\" of this view.\n\nIn other words, the coordinate frame at this entity becomes the reference frame of the view.\n\nDefaults to the root path '/' if not specified.\n\nThe transform at this path forms the reference point for all scene->world transforms in this view.\nI.e. the position of this entity path in space forms the origin of the coordinate system in this view.\nFurthermore, this is the primary indicator for heuristics on what entities we show in this view.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "visible",
                        display_name: "Visible",
                        component_type: "rerun.components.Visible".into(),
                        docstring_md: "Whether this view is visible.\n\nDefaults to true if not specified.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ViewContents"),
            ArchetypeReflection {
                display_name: "View contents",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "query",
                    display_name: "Query",
                    component_type: "rerun.blueprint.components.QueryExpression".into(),
                    docstring_md: "The `QueryExpression` that populates the contents for the view.\n\nThey determine which entities are part of the view.",
                    is_required: false,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.ViewportBlueprint"),
            ArchetypeReflection {
                display_name: "Viewport blueprint",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "root_container",
                        display_name: "Root container",
                        component_type: "rerun.blueprint.components.RootContainer".into(),
                        docstring_md: "The layout of the views",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "maximized",
                        display_name: "Maximized",
                        component_type: "rerun.blueprint.components.ViewMaximized".into(),
                        docstring_md: "Show one tab as maximized?",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "auto_layout",
                        display_name: "Auto layout",
                        component_type: "rerun.blueprint.components.AutoLayout".into(),
                        docstring_md: "Whether the viewport layout is determined automatically.\n\nIf `true`, the container layout will be reset whenever a new view is added or removed.\nThis defaults to `false` and is automatically set to `false` when there is user determined layout.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "auto_views",
                        display_name: "Auto views",
                        component_type: "rerun.blueprint.components.AutoViews".into(),
                        docstring_md: "Whether or not views should be created automatically.\n\nIf `true`, the viewer will only add views that it hasn't considered previously (as identified by `past_viewer_recommendations`)\nand which aren't deemed redundant to existing views.\nThis defaults to `false` and is automatically set to `false` when the user adds views manually in the viewer.",
                        is_required: false,
                    },
                    ArchetypeFieldReflection {
                        name: "past_viewer_recommendations",
                        display_name: "Past viewer recommendations",
                        component_type: "rerun.blueprint.components.ViewerRecommendationHash"
                            .into(),
                        docstring_md: "Hashes of all recommended views the viewer has already added and that should not be added again.\n\nThis is an internal field and should not be set usually.\nIf you want the viewer from stopping to add views, you should set `auto_views` to `false`.\n\nThe viewer uses this to determine whether it should keep adding views.",
                        is_required: false,
                    },
                ],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.VisibleTimeRanges"),
            ArchetypeReflection {
                display_name: "Visible time ranges",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "ranges",
                    display_name: "Ranges",
                    component_type: "rerun.blueprint.components.VisibleTimeRange".into(),
                    docstring_md: "The time ranges to show for each timeline unless specified otherwise on a per-entity basis.\n\nIf a timeline is specified more than once, the first entry will be used.",
                    is_required: true,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.VisualBounds2D"),
            ArchetypeReflection {
                display_name: "Visual bounds 2D",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![ArchetypeFieldReflection {
                    name: "range",
                    display_name: "Range",
                    component_type: "rerun.blueprint.components.VisualBounds2D".into(),
                    docstring_md: "Controls the visible range of a 2D view.\n\nUse this to control pan & zoom of the view.",
                    is_required: true,
                }],
            },
        ),
        (
            ArchetypeName::new("rerun.blueprint.archetypes.VisualizerInstruction"),
            ArchetypeReflection {
                display_name: "Visualizer instruction",
                deprecation_summary: None,
                scope: Some("blueprint"),
                view_types: &[],
                fields: vec![
                    ArchetypeFieldReflection {
                        name: "visualizer_type",
                        display_name: "Visualizer type",
                        component_type: "rerun.blueprint.components.VisualizerType".into(),
                        docstring_md: "The type of the visualizer.",
                        is_required: true,
                    },
                    ArchetypeFieldReflection {
                        name: "component_map",
                        display_name: "Component map",
                        component_type: "rerun.blueprint.components.VisualizerComponentMapping"
                            .into(),
                        docstring_md: "The component mapping pairs.",
                        is_required: false,
                    },
                ],
            },
        ),
    ];
    ArchetypeReflectionMap::from_iter(array)
}
