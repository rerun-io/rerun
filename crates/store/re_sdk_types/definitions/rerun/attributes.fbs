namespace rerun.attributes;

/// Marks a component as required, which is likely to impact the generated code in
/// backend-specific ways.
///
/// Only applies to the fields of an archetype.
attribute "attr.rerun.component_required";

/// Marks a component as recommended, which is likely to impact the generated code in
/// backend-specific ways.
///
/// Only applies to the fields of an archetype.
attribute "attr.rerun.component_recommended";

/// Marks a component as optional, which is likely to impact the generated code in
/// backend-specific ways.
///
/// Only applies to the fields of an archetype.
attribute "attr.rerun.component_optional";

/// Marks a component as editable through the UI.
/// By default all required components are non-editable and all other components are editable.
///
/// Must be set to true or false. Valid usage examples:"
/// - `axis_length: rerun.components.AxisLength ("attr.rerun.component_required", "attr.rerun.component_ui_editable": "true", order: 1000);`
/// - `translation: rerun.components.Translation3D ("attr.rerun.component_optional", "attr.rerun.component_ui_editable": "false", nullable, order: 1100);`
///
/// Note this is only a hint to the Viewer. Blueprint code may always set overrides for any component!
attribute "attr.rerun.component_ui_editable";

/// Override the type of a field.
///
/// The only permitted values are:
/// - `binary`, to override `[ubyte]`
/// - `float16`, to override `ushort`
///
/// For lists this will apply to the inner element.
attribute "attr.rerun.override_type";

/// Set the scope of the type.
///
/// This is used for example to scope blueprint types.
attribute "attr.rerun.scope";

/// Specifies the type identifier for a view type.
///
/// This is mandatory for view types.
attribute "attr.rerun.view_identifier";

/// Specifies the visualizer identifier for an archetype.
///
/// When present with a value, this archetype will be included in the generated
/// `visualizers.py` file with the specified visualizer name.
/// The value should be the name of the visualizer (typically the archetype name).
///
/// Example: `"attr.rerun.visualizer": "Points3D"`
///
/// Only applies to archetypes.
attribute "attr.rerun.visualizer";

/// Marks an archetype as explicitly NOT having a visualizer.
///
/// Use this to opt-out of visualizer generation for archetypes that shouldn't appear
/// in the `visualizers.py` constants file.
///
/// Only applies to archetypes.
attribute "attr.rerun.visualizer_none";

/// Must be set on all archetypes and components.
///
/// Must have one of the following values:
/// - `unstable`
/// - `stable`
/// - `deprecated`
///
/// ### `unstable`
/// Used for types that are likely to be removed or changed significantly,
/// and in a way that the data won't be backwards compatible.
///
/// Sometimes use for new, experimental APIs, or old APIs that we're not ready to stabilize yet.
///
/// ### `stable`
/// Used for types that are unlikely to be removed or changed significantly.
/// If they are changed, we will make sure that the old data can still be read.
///
/// ### `deprecated`
/// Marks something as deprecated followed by a (mandatory!) migration note.
///
/// If specified on an object (struct/enum/union), it becomes deprecated such
/// that using the object should emit a warning in all target languages.
/// Furthermore, documentation will mention that the object is deprecated and display
/// the specified migration note.
///
/// If set, you MUST also set `attr.rerun.deprecated_since` and `attr.rerun.deprecated_notice` to a non-empty string.
attribute "attr.rerun.state";

/// Rerun version string (e.g. `0.23.0`) when the object was first deprecated.
///
/// Must be set if `attr.rerun.state` is set to `deprecated`.
attribute "attr.rerun.deprecated_since";

/// Explain what to do instead.
///
/// Must be set if `attr.rerun.state` is set to `deprecated`.
attribute "attr.rerun.deprecated_notice";
