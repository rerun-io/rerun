use std::process::Stdio;

use cargo_metadata::camino::Utf8PathBuf;

fn target_directory() -> Utf8PathBuf {
    let metadata = cargo_metadata::MetadataCommand::new()
        .manifest_path("./Cargo.toml")
        .features(cargo_metadata::CargoOpt::AllFeatures)
        .exec()
        .unwrap();
    metadata.target_directory
}

// Port of build_web.sh
pub fn build(release: bool) {
    eprintln!("Building web viewer wasm…");
    eprintln!("We assume you've already run ./scripts/setup_web.sh");

    let crate_name = "re_viewer";

    // Where we tell cargo to build to.
    // We want this to be different from the default target folder
    // in order to support recursive cargo builds (calling `cargo` from within a `build.rs`).
    let target_wasm_dir = Utf8PathBuf::from(format!("{}_wasm", target_directory()));

    // Repository root
    let root_dir = target_wasm_dir.parent().unwrap();

    // Where we will place the final .wasm and .js artifacts.
    let build_dir = root_dir.join("web_viewer");

    assert!(
        build_dir.exists(),
        "Failed to find dir {build_dir}. CWD: {:?}, CARGO_MANIFEST_DIR: {:?}",
        std::env::current_dir(),
        std::env!("CARGO_MANIFEST_DIR")
    );

    // The two files we are building:
    let wasm_path = build_dir.join([crate_name, "_bg.wasm"].concat());
    let js_path = build_dir.join([crate_name, ".js"].concat());

    // Clean old versions:
    std::fs::remove_file(wasm_path.clone()).ok();
    std::fs::remove_file(js_path).ok();

    // --------------------------------------------------------------------------------
    eprintln!("Compiling rust to wasm in folder:{target_wasm_dir}…");

    let mut cmd = std::process::Command::new("cargo");
    cmd.current_dir(root_dir);
    cmd.args([
        "build",
        "--target-dir",
        target_wasm_dir.as_str(),
        "-p",
        crate_name,
        "--lib",
        "--target",
        "wasm32-unknown-unknown",
    ]);
    if release {
        cmd.arg("--release");
    }

    // This is required to enable the web_sys clipboard API which egui_web uses
    // https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Clipboard.html
    // https://rustwasm.github.io/docs/wasm-bindgen/web-sys/unstable-apis.html
    cmd.env("RUSTFLAGS", "--cfg=web_sys_unstable_apis");

    // When executing this script from a Rust build script, do _not_, under any circumstances,
    // allow pre-encoded `RUSTFLAGS` to leak into the current environment.
    // These pre-encoded flags are generally generated by Cargo itself when loading its
    // configuration from e.g. `$CARGO_HOME/config.toml`; which means they will contain
    // values that only make sense for the native target host, not for a wasm build.
    cmd.env("CARGO_ENCODED_RUSTFLAGS", "");

    eprintln!("wasm build cmd: {cmd:?}");
    let output = cmd
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .output()
        .expect("Failed to build Wasm");
    assert!(output.status.success(), "Failed to build Wasm");

    // --------------------------------------------------------------------------------
    eprintln!("Generating JS bindings for wasm…");

    let build = if release { "release" } else { "debug" };

    let target_path = target_wasm_dir
        .join("wasm32-unknown-unknown")
        .join(build)
        .join(format!("{crate_name}.wasm"));

    let mut cmd = std::process::Command::new("wasm-bindgen");
    cmd.current_dir(root_dir);
    cmd.args([
        target_path.as_str(),
        "--out-dir",
        build_dir.as_str(),
        "--no-modules",
        "--no-typescript",
    ]);

    eprintln!("wasm-bindgen cmd: {cmd:?}");

    let output = cmd
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .output()
        .unwrap_or_else(|err| panic!("Failed to generate JS bindings: {err}. target_path: {target_path:?}, build_dir: {build_dir}"));

    eprintln!("wasm-bindgen status: {}", output.status);
    if !output.stderr.is_empty() {
        eprintln!(
            "wasm-bindgen stderr: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    assert!(output.status.success());

    // --------------------------------------------------------------------------------
    // Optimize the wasm

    if release {
        eprintln!("Optimizing wasm with wasm-opt…");

        // to get wasm-opt:  apt/brew/dnf install binaryen
        let mut cmd = std::process::Command::new("wasm-opt");
        cmd.current_dir(root_dir);

        // TODO(emilk): add `-g` to keep debug symbols
        cmd.args([
            wasm_path.as_str(),
            "-O2",
            "--fast-math",
            "-o",
            wasm_path.as_str(),
        ]);

        eprintln!("wasm-opt cmd: {cmd:?}");

        let output = cmd
            .stdout(Stdio::inherit())
            .stderr(Stdio::inherit())
            .output()
            .expect("Failed to run wasm-opt");
        assert!(output.status.success(), "Failed to run wasm-opt");
    }

    eprintln!("Finished {wasm_path:?}");
}
