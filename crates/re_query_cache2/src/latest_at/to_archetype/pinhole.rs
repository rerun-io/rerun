// DO NOT EDIT! This file was auto-generated by crates/re_types_builder/src/codegen/rust/to_archetype.rs

#![allow(unused_imports)]
#![allow(unused_parens)]
#![allow(clippy::clone_on_copy)]

use crate::CachedLatestAtResults;
use re_query2::{PromiseResolver, PromiseResult};
use re_types_core::{Archetype, Loggable as _};
use std::sync::Arc;

impl crate::ToArchetype<re_types::archetypes::Pinhole> for CachedLatestAtResults {
    #[inline]
    fn to_archetype(
        &self,
        resolver: &PromiseResolver,
    ) -> PromiseResult<re_types::archetypes::Pinhole> {
        re_tracing::profile_function!(<re_types::archetypes::Pinhole>::name());

        // --- Required ---

        use re_types::components::PinholeProjection;
        let image_from_camera = match self.get_required(<PinholeProjection>::name()) {
            Ok(image_from_camera) => image_from_camera,
            Err(err) => return PromiseResult::Error(Arc::new(err)),
        };
        let image_from_camera = match image_from_camera
            .to_dense::<PinholeProjection>(resolver)
            .flatten()
        {
            PromiseResult::Ready(data) => {
                let Some(first) = data.first().cloned() else {
                    return PromiseResult::Error(std::sync::Arc::new(
                        re_types_core::DeserializationError::missing_data(),
                    ));
                };
                first
            }
            PromiseResult::Pending => return PromiseResult::Pending,
            PromiseResult::Error(err) => return PromiseResult::Error(err),
        };

        // --- Recommended/Optional ---

        use re_types::components::Resolution;
        let resolution = if let Some(resolution) = self.get(<Resolution>::name()) {
            match resolution.to_dense::<Resolution>(resolver).flatten() {
                PromiseResult::Ready(data) => data.first().cloned(),
                PromiseResult::Pending => return PromiseResult::Pending,
                PromiseResult::Error(err) => return PromiseResult::Error(err),
            }
        } else {
            None
        };

        use re_types::components::ViewCoordinates;
        let camera_xyz = if let Some(camera_xyz) = self.get(<ViewCoordinates>::name()) {
            match camera_xyz.to_dense::<ViewCoordinates>(resolver).flatten() {
                PromiseResult::Ready(data) => data.first().cloned(),
                PromiseResult::Pending => return PromiseResult::Pending,
                PromiseResult::Error(err) => return PromiseResult::Error(err),
            }
        } else {
            None
        };

        // ---

        let arch = re_types::archetypes::Pinhole {
            image_from_camera,
            resolution,
            camera_xyz,
        };

        PromiseResult::Ready(arch)
    }
}
