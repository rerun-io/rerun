// DO NOT EDIT! This file was auto-generated by crates/re_types_builder/src/codegen/rust/api.rs
// Based on "crates/re_types/definitions/rerun/blueprint/archetypes/scalar_colormap.fbs".

#![allow(trivial_numeric_casts)]
#![allow(unused_imports)]
#![allow(unused_parens)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::cloned_instead_of_copied)]
#![allow(clippy::iter_on_single_items)]
#![allow(clippy::map_flatten)]
#![allow(clippy::match_wildcard_for_single_variants)]
#![allow(clippy::needless_question_mark)]
#![allow(clippy::new_without_default)]
#![allow(clippy::redundant_closure)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::too_many_lines)]
#![allow(clippy::unnecessary_cast)]

use ::re_types_core::external::arrow2;
use ::re_types_core::ComponentName;
use ::re_types_core::SerializationResult;
use ::re_types_core::{ComponentBatch, MaybeOwnedComponentBatch};
use ::re_types_core::{DeserializationError, DeserializationResult};

/// **Archetype**: Configures the tensor view's color mapping.1
#[derive(Clone, Debug, Default)]
pub struct ScalarColormap {
    /// How scalar values map to colors.
    pub colormap: Option<crate::components::Colormap>,

    /// Gamma exponent applied to normalized values before mapping to color.
    ///
    /// Raises the normalized values to the power of this value before mapping to color.
    /// Acts like an inverse brightness. Defaults to 1.0.
    pub gamma: Option<crate::components::GammaCorrection>,
}

impl ::re_types_core::SizeBytes for ScalarColormap {
    #[inline]
    fn heap_size_bytes(&self) -> u64 {
        self.colormap.heap_size_bytes() + self.gamma.heap_size_bytes()
    }

    #[inline]
    fn is_pod() -> bool {
        <Option<crate::components::Colormap>>::is_pod()
            && <Option<crate::components::GammaCorrection>>::is_pod()
    }
}

static REQUIRED_COMPONENTS: once_cell::sync::Lazy<[ComponentName; 0usize]> =
    once_cell::sync::Lazy::new(|| []);

static RECOMMENDED_COMPONENTS: once_cell::sync::Lazy<[ComponentName; 1usize]> =
    once_cell::sync::Lazy::new(|| ["rerun.blueprint.components.ScalarColormapIndicator".into()]);

static OPTIONAL_COMPONENTS: once_cell::sync::Lazy<[ComponentName; 2usize]> =
    once_cell::sync::Lazy::new(|| {
        [
            "rerun.components.Colormap".into(),
            "rerun.components.GammaCorrection".into(),
        ]
    });

static ALL_COMPONENTS: once_cell::sync::Lazy<[ComponentName; 3usize]> =
    once_cell::sync::Lazy::new(|| {
        [
            "rerun.blueprint.components.ScalarColormapIndicator".into(),
            "rerun.components.Colormap".into(),
            "rerun.components.GammaCorrection".into(),
        ]
    });

static FIELD_INFOS: once_cell::sync::Lazy<[::re_types_core::ArchetypeFieldInfo; 2usize]> =
    once_cell::sync::Lazy::new(|| {
        [
        ::re_types_core::ArchetypeFieldInfo {
            display_name: "Colormap",
            documentation: "How scalar values map to colors.",
            component_name: "rerun.components.Colormap".into(),
        },
        ::re_types_core::ArchetypeFieldInfo {
            display_name: "Gamma",
            documentation: "Gamma exponent applied to normalized values before mapping to color.\n\nRaises the normalized values to the power of this value before mapping to color.\nActs like an inverse brightness. Defaults to 1.0.",
            component_name: "rerun.components.GammaCorrection".into(),
        },
    ]
    });

impl ScalarColormap {
    /// The total number of components in the archetype: 0 required, 1 recommended, 2 optional
    pub const NUM_COMPONENTS: usize = 3usize;
}

/// Indicator component for the [`ScalarColormap`] [`::re_types_core::Archetype`]
pub type ScalarColormapIndicator = ::re_types_core::GenericIndicatorComponent<ScalarColormap>;

impl ::re_types_core::Archetype for ScalarColormap {
    type Indicator = ScalarColormapIndicator;

    #[inline]
    fn name() -> ::re_types_core::ArchetypeName {
        "rerun.blueprint.archetypes.ScalarColormap".into()
    }

    #[inline]
    fn display_name() -> &'static str {
        "Scalar colormap"
    }

    #[inline]
    fn indicator() -> MaybeOwnedComponentBatch<'static> {
        static INDICATOR: ScalarColormapIndicator = ScalarColormapIndicator::DEFAULT;
        MaybeOwnedComponentBatch::Ref(&INDICATOR)
    }

    #[inline]
    fn required_components() -> ::std::borrow::Cow<'static, [ComponentName]> {
        REQUIRED_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn recommended_components() -> ::std::borrow::Cow<'static, [ComponentName]> {
        RECOMMENDED_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn optional_components() -> ::std::borrow::Cow<'static, [ComponentName]> {
        OPTIONAL_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn all_components() -> ::std::borrow::Cow<'static, [ComponentName]> {
        ALL_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn field_infos() -> Option<::std::borrow::Cow<'static, [::re_types_core::ArchetypeFieldInfo]>> {
        Some(FIELD_INFOS.as_slice().into())
    }

    #[inline]
    fn from_arrow_components(
        arrow_data: impl IntoIterator<Item = (ComponentName, Box<dyn arrow2::array::Array>)>,
    ) -> DeserializationResult<Self> {
        re_tracing::profile_function!();
        use ::re_types_core::{Loggable as _, ResultExt as _};
        let arrays_by_name: ::std::collections::HashMap<_, _> = arrow_data
            .into_iter()
            .map(|(name, array)| (name.full_name(), array))
            .collect();
        let colormap = if let Some(array) = arrays_by_name.get("rerun.components.Colormap") {
            <crate::components::Colormap>::from_arrow_opt(&**array)
                .with_context("rerun.blueprint.archetypes.ScalarColormap#colormap")?
                .into_iter()
                .next()
                .flatten()
        } else {
            None
        };
        let gamma = if let Some(array) = arrays_by_name.get("rerun.components.GammaCorrection") {
            <crate::components::GammaCorrection>::from_arrow_opt(&**array)
                .with_context("rerun.blueprint.archetypes.ScalarColormap#gamma")?
                .into_iter()
                .next()
                .flatten()
        } else {
            None
        };
        Ok(Self { colormap, gamma })
    }
}

impl ::re_types_core::AsComponents for ScalarColormap {
    fn as_component_batches(&self) -> Vec<MaybeOwnedComponentBatch<'_>> {
        re_tracing::profile_function!();
        use ::re_types_core::Archetype as _;
        [
            Some(Self::indicator()),
            self.colormap
                .as_ref()
                .map(|comp| (comp as &dyn ComponentBatch).into()),
            self.gamma
                .as_ref()
                .map(|comp| (comp as &dyn ComponentBatch).into()),
        ]
        .into_iter()
        .flatten()
        .collect()
    }
}

impl ScalarColormap {
    /// Create a new `ScalarColormap`.
    #[inline]
    pub fn new() -> Self {
        Self {
            colormap: None,
            gamma: None,
        }
    }

    /// How scalar values map to colors.
    #[inline]
    pub fn with_colormap(mut self, colormap: impl Into<crate::components::Colormap>) -> Self {
        self.colormap = Some(colormap.into());
        self
    }

    /// Gamma exponent applied to normalized values before mapping to color.
    ///
    /// Raises the normalized values to the power of this value before mapping to color.
    /// Acts like an inverse brightness. Defaults to 1.0.
    #[inline]
    pub fn with_gamma(mut self, gamma: impl Into<crate::components::GammaCorrection>) -> Self {
        self.gamma = Some(gamma.into());
        self
    }
}
