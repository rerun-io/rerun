// NOTE: This file was autogenerated by re_types_builder; DO NOT EDIT.

#![allow(trivial_numeric_casts)]
#![allow(unused_parens)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::map_flatten)]
#![allow(clippy::needless_question_mark)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::unnecessary_cast)]

#[derive(Debug, Clone, PartialEq)]
pub struct AffixFuzzer1 {
    pub single_required: crate::datatypes::AffixFuzzer1,
}

impl<'a> From<AffixFuzzer1> for ::std::borrow::Cow<'a, AffixFuzzer1> {
    #[inline]
    fn from(value: AffixFuzzer1) -> Self {
        std::borrow::Cow::Owned(value)
    }
}

impl<'a> From<&'a AffixFuzzer1> for ::std::borrow::Cow<'a, AffixFuzzer1> {
    #[inline]
    fn from(value: &'a AffixFuzzer1) -> Self {
        std::borrow::Cow::Borrowed(value)
    }
}

impl crate::Component for AffixFuzzer1 {
    #[inline]
    fn name() -> crate::ComponentName {
        crate::ComponentName::Borrowed("rerun.testing.components.AffixFuzzer1")
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    #[inline]
    fn to_arrow_datatype() -> arrow2::datatypes::DataType {
        use ::arrow2::datatypes::*;
        DataType::Struct(vec![
            Field {
                name: "single_float_optional".to_owned(),
                data_type: DataType::Float32,
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "single_string_required".to_owned(),
                data_type: DataType::Utf8,
                is_nullable: false,
                metadata: [].into(),
            },
            Field {
                name: "single_string_optional".to_owned(),
                data_type: DataType::Utf8,
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "many_floats_optional".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Float32,
                    is_nullable: true,
                    metadata: [].into(),
                })),
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "many_strings_required".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: false,
                    metadata: [].into(),
                })),
                is_nullable: false,
                metadata: [].into(),
            },
            Field {
                name: "many_strings_optional".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: true,
                    metadata: [].into(),
                })),
                is_nullable: true,
                metadata: [].into(),
            },
        ])
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_to_arrow_opt<'a>(
        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,
        extension_wrapper: Option<&str>,
    ) -> crate::SerializationResult<Box<dyn ::arrow2::array::Array>>
    where
        Self: Clone + 'a,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok({
            let (somes, single_required): (Vec<_>, Vec<_>) = data
                .into_iter()
                .map(|datum| {
                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);
                    let datum = datum.map(|datum| {
                        let Self { single_required } = datum.into_owned();
                        single_required
                    });
                    (datum.is_some(), datum)
                })
                .unzip();
            let single_required_bitmap: Option<::arrow2::bitmap::Bitmap> = {
                let any_nones = somes.iter().any(|some| !*some);
                any_nones.then(|| somes.into())
            };
            {
                _ = single_required_bitmap;
                _ = extension_wrapper;
                crate::datatypes::AffixFuzzer1::try_to_arrow_opt(
                    single_required,
                    Some("rerun.testing.components.AffixFuzzer1"),
                )?
            }
        })
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_from_arrow_opt(
        data: &dyn ::arrow2::array::Array,
    ) -> crate::DeserializationResult<Vec<Option<Self>>>
    where
        Self: Sized,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok(crate::datatypes::AffixFuzzer1::try_from_arrow_opt(data)?
            .into_iter()
            .map(|v| {
                v.ok_or_else(|| crate::DeserializationError::MissingData {
                    datatype: data.data_type().clone(),
                })
            })
            .map(|res| res.map(|single_required| Some(Self { single_required })))
            .collect::<crate::DeserializationResult<Vec<Option<_>>>>()?)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct AffixFuzzer2(pub crate::datatypes::AffixFuzzer1);

impl<'a> From<AffixFuzzer2> for ::std::borrow::Cow<'a, AffixFuzzer2> {
    #[inline]
    fn from(value: AffixFuzzer2) -> Self {
        std::borrow::Cow::Owned(value)
    }
}

impl<'a> From<&'a AffixFuzzer2> for ::std::borrow::Cow<'a, AffixFuzzer2> {
    #[inline]
    fn from(value: &'a AffixFuzzer2) -> Self {
        std::borrow::Cow::Borrowed(value)
    }
}

impl crate::Component for AffixFuzzer2 {
    #[inline]
    fn name() -> crate::ComponentName {
        crate::ComponentName::Borrowed("rerun.testing.components.AffixFuzzer2")
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    #[inline]
    fn to_arrow_datatype() -> arrow2::datatypes::DataType {
        use ::arrow2::datatypes::*;
        DataType::Struct(vec![
            Field {
                name: "single_float_optional".to_owned(),
                data_type: DataType::Float32,
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "single_string_required".to_owned(),
                data_type: DataType::Utf8,
                is_nullable: false,
                metadata: [].into(),
            },
            Field {
                name: "single_string_optional".to_owned(),
                data_type: DataType::Utf8,
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "many_floats_optional".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Float32,
                    is_nullable: true,
                    metadata: [].into(),
                })),
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "many_strings_required".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: false,
                    metadata: [].into(),
                })),
                is_nullable: false,
                metadata: [].into(),
            },
            Field {
                name: "many_strings_optional".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: true,
                    metadata: [].into(),
                })),
                is_nullable: true,
                metadata: [].into(),
            },
        ])
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_to_arrow_opt<'a>(
        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,
        extension_wrapper: Option<&str>,
    ) -> crate::SerializationResult<Box<dyn ::arrow2::array::Array>>
    where
        Self: Clone + 'a,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok({
            let (somes, data0): (Vec<_>, Vec<_>) = data
                .into_iter()
                .map(|datum| {
                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);
                    let datum = datum.map(|datum| {
                        let Self(data0) = datum.into_owned();
                        data0
                    });
                    (datum.is_some(), datum)
                })
                .unzip();
            let data0_bitmap: Option<::arrow2::bitmap::Bitmap> = {
                let any_nones = somes.iter().any(|some| !*some);
                any_nones.then(|| somes.into())
            };
            {
                _ = data0_bitmap;
                _ = extension_wrapper;
                crate::datatypes::AffixFuzzer1::try_to_arrow_opt(
                    data0,
                    Some("rerun.testing.components.AffixFuzzer2"),
                )?
            }
        })
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_from_arrow_opt(
        data: &dyn ::arrow2::array::Array,
    ) -> crate::DeserializationResult<Vec<Option<Self>>>
    where
        Self: Sized,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok(crate::datatypes::AffixFuzzer1::try_from_arrow_opt(data)?
            .into_iter()
            .map(|v| {
                v.ok_or_else(|| crate::DeserializationError::MissingData {
                    datatype: data.data_type().clone(),
                })
            })
            .map(|res| res.map(|v| Some(Self(v))))
            .collect::<crate::DeserializationResult<Vec<Option<_>>>>()?)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct AffixFuzzer3 {
    pub single_required: crate::datatypes::AffixFuzzer1,
}

impl<'a> From<AffixFuzzer3> for ::std::borrow::Cow<'a, AffixFuzzer3> {
    #[inline]
    fn from(value: AffixFuzzer3) -> Self {
        std::borrow::Cow::Owned(value)
    }
}

impl<'a> From<&'a AffixFuzzer3> for ::std::borrow::Cow<'a, AffixFuzzer3> {
    #[inline]
    fn from(value: &'a AffixFuzzer3) -> Self {
        std::borrow::Cow::Borrowed(value)
    }
}

impl crate::Component for AffixFuzzer3 {
    #[inline]
    fn name() -> crate::ComponentName {
        crate::ComponentName::Borrowed("rerun.testing.components.AffixFuzzer3")
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    #[inline]
    fn to_arrow_datatype() -> arrow2::datatypes::DataType {
        use ::arrow2::datatypes::*;
        DataType::Struct(vec![Field {
            name: "single_required".to_owned(),
            data_type: DataType::Struct(vec![
                Field {
                    name: "single_float_optional".to_owned(),
                    data_type: DataType::Float32,
                    is_nullable: true,
                    metadata: [].into(),
                },
                Field {
                    name: "single_string_required".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: false,
                    metadata: [].into(),
                },
                Field {
                    name: "single_string_optional".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: true,
                    metadata: [].into(),
                },
                Field {
                    name: "many_floats_optional".to_owned(),
                    data_type: DataType::List(Box::new(Field {
                        name: "item".to_owned(),
                        data_type: DataType::Float32,
                        is_nullable: true,
                        metadata: [].into(),
                    })),
                    is_nullable: true,
                    metadata: [].into(),
                },
                Field {
                    name: "many_strings_required".to_owned(),
                    data_type: DataType::List(Box::new(Field {
                        name: "item".to_owned(),
                        data_type: DataType::Utf8,
                        is_nullable: false,
                        metadata: [].into(),
                    })),
                    is_nullable: false,
                    metadata: [].into(),
                },
                Field {
                    name: "many_strings_optional".to_owned(),
                    data_type: DataType::List(Box::new(Field {
                        name: "item".to_owned(),
                        data_type: DataType::Utf8,
                        is_nullable: true,
                        metadata: [].into(),
                    })),
                    is_nullable: true,
                    metadata: [].into(),
                },
            ]),
            is_nullable: false,
            metadata: [].into(),
        }])
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_to_arrow_opt<'a>(
        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,
        extension_wrapper: Option<&str>,
    ) -> crate::SerializationResult<Box<dyn ::arrow2::array::Array>>
    where
        Self: Clone + 'a,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok({
            let (somes, data): (Vec<_>, Vec<_>) = data
                .into_iter()
                .map(|datum| {
                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);
                    (datum.is_some(), datum)
                })
                .unzip();
            let bitmap: Option<::arrow2::bitmap::Bitmap> = {
                let any_nones = somes.iter().any(|some| !*some);
                any_nones.then(|| somes.into())
            };
            StructArray::new(
                (if let Some(ext) = extension_wrapper {
                    DataType::Extension(
                        ext.to_owned(),
                        Box::new(<crate::components::AffixFuzzer3>::to_arrow_datatype()),
                        None,
                    )
                } else {
                    <crate::components::AffixFuzzer3>::to_arrow_datatype()
                })
                .to_logical_type()
                .clone(),
                vec![{
                    let (somes, single_required): (Vec<_>, Vec<_>) = data
                        .iter()
                        .map(|datum| {
                            let datum = datum.as_ref().map(|datum| {
                                let Self {
                                    single_required, ..
                                } = &**datum;
                                single_required.clone()
                            });
                            (datum.is_some(), datum)
                        })
                        .unzip();
                    let single_required_bitmap: Option<::arrow2::bitmap::Bitmap> = {
                        let any_nones = somes.iter().any(|some| !*some);
                        any_nones.then(|| somes.into())
                    };
                    {
                        _ = single_required_bitmap;
                        _ = extension_wrapper;
                        crate::datatypes::AffixFuzzer1::try_to_arrow_opt(
                            single_required,
                            None::<&str>,
                        )?
                    }
                }],
                bitmap,
            )
            .boxed()
        })
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_from_arrow_opt(
        data: &dyn ::arrow2::array::Array,
    ) -> crate::DeserializationResult<Vec<Option<Self>>>
    where
        Self: Sized,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok({
            let data = data
                .as_any()
                .downcast_ref::<::arrow2::array::StructArray>()
                .ok_or_else(|| crate::DeserializationError::SchemaMismatch {
                    expected: data.data_type().clone(),
                    got: data.data_type().clone(),
                })?;
            let (data_fields, data_arrays, data_bitmap) =
                (data.fields(), data.values(), data.validity());
            let is_valid = |i| data_bitmap.map_or(true, |bitmap| bitmap.get_bit(i));
            let arrays_by_name: ::std::collections::HashMap<_, _> = data_fields
                .iter()
                .map(|field| field.name.as_str())
                .zip(data_arrays)
                .collect();
            let single_required = {
                let data = &**arrays_by_name["single_required"];

                crate::datatypes::AffixFuzzer1::try_from_arrow_opt(data)?.into_iter()
            };
            ::itertools::izip!(single_required)
                .enumerate()
                .map(|(i, (single_required))| {
                    is_valid(i)
                        .then(|| {
                            Ok(Self {
                                single_required: single_required.ok_or_else(|| {
                                    crate::DeserializationError::MissingData {
                                        datatype: data.data_type().clone(),
                                    }
                                })?,
                            })
                        })
                        .transpose()
                })
                .collect::<crate::DeserializationResult<Vec<_>>>()?
        })
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct AffixFuzzer4 {
    pub single_optional: Option<crate::datatypes::AffixFuzzer1>,
}

impl<'a> From<AffixFuzzer4> for ::std::borrow::Cow<'a, AffixFuzzer4> {
    #[inline]
    fn from(value: AffixFuzzer4) -> Self {
        std::borrow::Cow::Owned(value)
    }
}

impl<'a> From<&'a AffixFuzzer4> for ::std::borrow::Cow<'a, AffixFuzzer4> {
    #[inline]
    fn from(value: &'a AffixFuzzer4) -> Self {
        std::borrow::Cow::Borrowed(value)
    }
}

impl crate::Component for AffixFuzzer4 {
    #[inline]
    fn name() -> crate::ComponentName {
        crate::ComponentName::Borrowed("rerun.testing.components.AffixFuzzer4")
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    #[inline]
    fn to_arrow_datatype() -> arrow2::datatypes::DataType {
        use ::arrow2::datatypes::*;
        DataType::Struct(vec![
            Field {
                name: "single_float_optional".to_owned(),
                data_type: DataType::Float32,
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "single_string_required".to_owned(),
                data_type: DataType::Utf8,
                is_nullable: false,
                metadata: [].into(),
            },
            Field {
                name: "single_string_optional".to_owned(),
                data_type: DataType::Utf8,
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "many_floats_optional".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Float32,
                    is_nullable: true,
                    metadata: [].into(),
                })),
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "many_strings_required".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: false,
                    metadata: [].into(),
                })),
                is_nullable: false,
                metadata: [].into(),
            },
            Field {
                name: "many_strings_optional".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: true,
                    metadata: [].into(),
                })),
                is_nullable: true,
                metadata: [].into(),
            },
        ])
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_to_arrow_opt<'a>(
        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,
        extension_wrapper: Option<&str>,
    ) -> crate::SerializationResult<Box<dyn ::arrow2::array::Array>>
    where
        Self: Clone + 'a,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok({
            let (somes, single_optional): (Vec<_>, Vec<_>) = data
                .into_iter()
                .map(|datum| {
                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);
                    let datum = datum
                        .map(|datum| {
                            let Self { single_optional } = datum.into_owned();
                            single_optional
                        })
                        .flatten();
                    (datum.is_some(), datum)
                })
                .unzip();
            let single_optional_bitmap: Option<::arrow2::bitmap::Bitmap> = {
                let any_nones = somes.iter().any(|some| !*some);
                any_nones.then(|| somes.into())
            };
            {
                _ = single_optional_bitmap;
                _ = extension_wrapper;
                crate::datatypes::AffixFuzzer1::try_to_arrow_opt(
                    single_optional,
                    Some("rerun.testing.components.AffixFuzzer4"),
                )?
            }
        })
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_from_arrow_opt(
        data: &dyn ::arrow2::array::Array,
    ) -> crate::DeserializationResult<Vec<Option<Self>>>
    where
        Self: Sized,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok(crate::datatypes::AffixFuzzer1::try_from_arrow_opt(data)?
            .into_iter()
            .map(Ok)
            .map(|res| res.map(|single_optional| Some(Self { single_optional })))
            .collect::<crate::DeserializationResult<Vec<Option<_>>>>()?)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct AffixFuzzer5(pub Option<crate::datatypes::AffixFuzzer1>);

impl<'a> From<AffixFuzzer5> for ::std::borrow::Cow<'a, AffixFuzzer5> {
    #[inline]
    fn from(value: AffixFuzzer5) -> Self {
        std::borrow::Cow::Owned(value)
    }
}

impl<'a> From<&'a AffixFuzzer5> for ::std::borrow::Cow<'a, AffixFuzzer5> {
    #[inline]
    fn from(value: &'a AffixFuzzer5) -> Self {
        std::borrow::Cow::Borrowed(value)
    }
}

impl crate::Component for AffixFuzzer5 {
    #[inline]
    fn name() -> crate::ComponentName {
        crate::ComponentName::Borrowed("rerun.testing.components.AffixFuzzer5")
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    #[inline]
    fn to_arrow_datatype() -> arrow2::datatypes::DataType {
        use ::arrow2::datatypes::*;
        DataType::Struct(vec![
            Field {
                name: "single_float_optional".to_owned(),
                data_type: DataType::Float32,
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "single_string_required".to_owned(),
                data_type: DataType::Utf8,
                is_nullable: false,
                metadata: [].into(),
            },
            Field {
                name: "single_string_optional".to_owned(),
                data_type: DataType::Utf8,
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "many_floats_optional".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Float32,
                    is_nullable: true,
                    metadata: [].into(),
                })),
                is_nullable: true,
                metadata: [].into(),
            },
            Field {
                name: "many_strings_required".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: false,
                    metadata: [].into(),
                })),
                is_nullable: false,
                metadata: [].into(),
            },
            Field {
                name: "many_strings_optional".to_owned(),
                data_type: DataType::List(Box::new(Field {
                    name: "item".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: true,
                    metadata: [].into(),
                })),
                is_nullable: true,
                metadata: [].into(),
            },
        ])
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_to_arrow_opt<'a>(
        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,
        extension_wrapper: Option<&str>,
    ) -> crate::SerializationResult<Box<dyn ::arrow2::array::Array>>
    where
        Self: Clone + 'a,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok({
            let (somes, data0): (Vec<_>, Vec<_>) = data
                .into_iter()
                .map(|datum| {
                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);
                    let datum = datum
                        .map(|datum| {
                            let Self(data0) = datum.into_owned();
                            data0
                        })
                        .flatten();
                    (datum.is_some(), datum)
                })
                .unzip();
            let data0_bitmap: Option<::arrow2::bitmap::Bitmap> = {
                let any_nones = somes.iter().any(|some| !*some);
                any_nones.then(|| somes.into())
            };
            {
                _ = data0_bitmap;
                _ = extension_wrapper;
                crate::datatypes::AffixFuzzer1::try_to_arrow_opt(
                    data0,
                    Some("rerun.testing.components.AffixFuzzer5"),
                )?
            }
        })
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_from_arrow_opt(
        data: &dyn ::arrow2::array::Array,
    ) -> crate::DeserializationResult<Vec<Option<Self>>>
    where
        Self: Sized,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok(crate::datatypes::AffixFuzzer1::try_from_arrow_opt(data)?
            .into_iter()
            .map(Ok)
            .map(|res| res.map(|v| Some(Self(v))))
            .collect::<crate::DeserializationResult<Vec<Option<_>>>>()?)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct AffixFuzzer6 {
    pub single_optional: Option<crate::datatypes::AffixFuzzer1>,
}

impl<'a> From<AffixFuzzer6> for ::std::borrow::Cow<'a, AffixFuzzer6> {
    #[inline]
    fn from(value: AffixFuzzer6) -> Self {
        std::borrow::Cow::Owned(value)
    }
}

impl<'a> From<&'a AffixFuzzer6> for ::std::borrow::Cow<'a, AffixFuzzer6> {
    #[inline]
    fn from(value: &'a AffixFuzzer6) -> Self {
        std::borrow::Cow::Borrowed(value)
    }
}

impl crate::Component for AffixFuzzer6 {
    #[inline]
    fn name() -> crate::ComponentName {
        crate::ComponentName::Borrowed("rerun.testing.components.AffixFuzzer6")
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    #[inline]
    fn to_arrow_datatype() -> arrow2::datatypes::DataType {
        use ::arrow2::datatypes::*;
        DataType::Struct(vec![Field {
            name: "single_optional".to_owned(),
            data_type: DataType::Struct(vec![
                Field {
                    name: "single_float_optional".to_owned(),
                    data_type: DataType::Float32,
                    is_nullable: true,
                    metadata: [].into(),
                },
                Field {
                    name: "single_string_required".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: false,
                    metadata: [].into(),
                },
                Field {
                    name: "single_string_optional".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: true,
                    metadata: [].into(),
                },
                Field {
                    name: "many_floats_optional".to_owned(),
                    data_type: DataType::List(Box::new(Field {
                        name: "item".to_owned(),
                        data_type: DataType::Float32,
                        is_nullable: true,
                        metadata: [].into(),
                    })),
                    is_nullable: true,
                    metadata: [].into(),
                },
                Field {
                    name: "many_strings_required".to_owned(),
                    data_type: DataType::List(Box::new(Field {
                        name: "item".to_owned(),
                        data_type: DataType::Utf8,
                        is_nullable: false,
                        metadata: [].into(),
                    })),
                    is_nullable: false,
                    metadata: [].into(),
                },
                Field {
                    name: "many_strings_optional".to_owned(),
                    data_type: DataType::List(Box::new(Field {
                        name: "item".to_owned(),
                        data_type: DataType::Utf8,
                        is_nullable: true,
                        metadata: [].into(),
                    })),
                    is_nullable: true,
                    metadata: [].into(),
                },
            ]),
            is_nullable: true,
            metadata: [].into(),
        }])
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_to_arrow_opt<'a>(
        data: impl IntoIterator<Item = Option<impl Into<::std::borrow::Cow<'a, Self>>>>,
        extension_wrapper: Option<&str>,
    ) -> crate::SerializationResult<Box<dyn ::arrow2::array::Array>>
    where
        Self: Clone + 'a,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok({
            let (somes, data): (Vec<_>, Vec<_>) = data
                .into_iter()
                .map(|datum| {
                    let datum: Option<::std::borrow::Cow<'a, Self>> = datum.map(Into::into);
                    (datum.is_some(), datum)
                })
                .unzip();
            let bitmap: Option<::arrow2::bitmap::Bitmap> = {
                let any_nones = somes.iter().any(|some| !*some);
                any_nones.then(|| somes.into())
            };
            StructArray::new(
                (if let Some(ext) = extension_wrapper {
                    DataType::Extension(
                        ext.to_owned(),
                        Box::new(<crate::components::AffixFuzzer6>::to_arrow_datatype()),
                        None,
                    )
                } else {
                    <crate::components::AffixFuzzer6>::to_arrow_datatype()
                })
                .to_logical_type()
                .clone(),
                vec![{
                    let (somes, single_optional): (Vec<_>, Vec<_>) = data
                        .iter()
                        .map(|datum| {
                            let datum = datum
                                .as_ref()
                                .map(|datum| {
                                    let Self {
                                        single_optional, ..
                                    } = &**datum;
                                    single_optional.clone()
                                })
                                .flatten();
                            (datum.is_some(), datum)
                        })
                        .unzip();
                    let single_optional_bitmap: Option<::arrow2::bitmap::Bitmap> = {
                        let any_nones = somes.iter().any(|some| !*some);
                        any_nones.then(|| somes.into())
                    };
                    {
                        _ = single_optional_bitmap;
                        _ = extension_wrapper;
                        crate::datatypes::AffixFuzzer1::try_to_arrow_opt(
                            single_optional,
                            None::<&str>,
                        )?
                    }
                }],
                bitmap,
            )
            .boxed()
        })
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    fn try_from_arrow_opt(
        data: &dyn ::arrow2::array::Array,
    ) -> crate::DeserializationResult<Vec<Option<Self>>>
    where
        Self: Sized,
    {
        use crate::{Component as _, Datatype as _};
        use ::arrow2::{array::*, datatypes::*};
        Ok({
            let data = data
                .as_any()
                .downcast_ref::<::arrow2::array::StructArray>()
                .ok_or_else(|| crate::DeserializationError::SchemaMismatch {
                    expected: data.data_type().clone(),
                    got: data.data_type().clone(),
                })?;
            let (data_fields, data_arrays, data_bitmap) =
                (data.fields(), data.values(), data.validity());
            let is_valid = |i| data_bitmap.map_or(true, |bitmap| bitmap.get_bit(i));
            let arrays_by_name: ::std::collections::HashMap<_, _> = data_fields
                .iter()
                .map(|field| field.name.as_str())
                .zip(data_arrays)
                .collect();
            let single_optional = {
                let data = &**arrays_by_name["single_optional"];

                crate::datatypes::AffixFuzzer1::try_from_arrow_opt(data)?.into_iter()
            };
            ::itertools::izip!(single_optional)
                .enumerate()
                .map(|(i, (single_optional))| {
                    is_valid(i)
                        .then(|| Ok(Self { single_optional }))
                        .transpose()
                })
                .collect::<crate::DeserializationResult<Vec<_>>>()?
        })
    }
}
