// NOTE: This file was autogenerated by re_types_builder; DO NOT EDIT.

/// A 2D point cloud with positions and optional colors, radii, labels, etc.
#[derive(Debug, Clone, PartialEq)]
pub struct Points2D {
    /// All the actual 2D points that make up the point cloud.
    pub points: Vec<crate::components::Point2D>,

    /// Optional radii for the points, effectively turning them into circles.
    pub radii: Option<Vec<crate::components::Radius>>,

    /// Optional colors for the points.
    pub colors: Option<Vec<crate::components::Color>>,

    /// Optional text labels for the points.
    pub labels: Option<Vec<crate::components::Label>>,

    /// An optional floating point value that specifies the 2D drawing order.
    /// Objects with higher values are drawn on top of those with lower values.
    ///
    /// The default for 2D points is 30.0.
    pub draw_order: Option<crate::components::DrawOrder>,

    /// Optional class Ids for the points.
    ///
    /// The class ID provides colors and labels if not specified explicitly.
    pub class_ids: Option<Vec<crate::components::ClassId>>,

    /// Optional keypoint IDs for the points, identifying them within a class.
    ///
    /// If keypoint IDs are passed in but no class IDs were specified, the class ID will
    /// default to 0.
    /// This is useful to identify points within a single classification (which is identified
    /// with `class_id`).
    /// E.g. the classification might be 'Person' and the keypoints refer to joints on a
    /// detected skeleton.
    pub keypoint_ids: Option<Vec<crate::components::KeypointId>>,

    /// Unique identifiers for each individual point in the batch.
    pub instance_keys: Option<Vec<crate::components::InstanceKey>>,
}

impl Points2D {
    pub const REQUIRED_COMPONENTS: [crate::ComponentName; 1] =
        [crate::ComponentName::Borrowed("rerun.components.Point2D")];

    pub const RECOMMENDED_COMPONENTS: [crate::ComponentName; 2] = [
        crate::ComponentName::Borrowed("rerun.components.Radius"),
        crate::ComponentName::Borrowed("rerun.components.Color"),
    ];

    pub const OPTIONAL_COMPONENTS: [crate::ComponentName; 5] = [
        crate::ComponentName::Borrowed("rerun.components.Label"),
        crate::ComponentName::Borrowed("rerun.components.DrawOrder"),
        crate::ComponentName::Borrowed("rerun.components.ClassId"),
        crate::ComponentName::Borrowed("rerun.components.KeypointId"),
        crate::ComponentName::Borrowed("rerun.components.InstanceKey"),
    ];

    pub const ALL_COMPONENTS: [crate::ComponentName; 8] = [
        crate::ComponentName::Borrowed("rerun.components.Point2D"),
        crate::ComponentName::Borrowed("rerun.components.Radius"),
        crate::ComponentName::Borrowed("rerun.components.Color"),
        crate::ComponentName::Borrowed("rerun.components.Label"),
        crate::ComponentName::Borrowed("rerun.components.DrawOrder"),
        crate::ComponentName::Borrowed("rerun.components.ClassId"),
        crate::ComponentName::Borrowed("rerun.components.KeypointId"),
        crate::ComponentName::Borrowed("rerun.components.InstanceKey"),
    ];
}

impl crate::Archetype for Points2D {
    fn name() -> crate::ArchetypeName {
        crate::ArchetypeName::Borrowed("rerun.archetypes.Points2D")
    }

    fn required_components() -> Vec<crate::ComponentName> {
        Self::REQUIRED_COMPONENTS.to_vec()
    }

    fn recommended_components() -> Vec<crate::ComponentName> {
        Self::RECOMMENDED_COMPONENTS.to_vec()
    }

    fn optional_components() -> Vec<crate::ComponentName> {
        Self::OPTIONAL_COMPONENTS.to_vec()
    }

    #[allow(clippy::unimplemented)]
    fn to_arrow_datatypes() -> Vec<arrow2::datatypes::DataType> {
        // TODO(#2368): dump the arrow registry into the generated code
        unimplemented!("query the registry for all fqnames"); // NOLINT
    }
}

impl Points2D {
    pub fn new(points: impl IntoIterator<Item = impl Into<crate::components::Point2D>>) -> Self {
        Self {
            points: points.into_iter().map(Into::into).collect(),
            radii: None,
            colors: None,
            labels: None,
            draw_order: None,
            class_ids: None,
            keypoint_ids: None,
            instance_keys: None,
        }
    }

    pub fn with_radii(
        mut self,
        radii: impl IntoIterator<Item = impl Into<crate::components::Radius>>,
    ) -> Self {
        self.radii = Some(radii.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_colors(
        mut self,
        colors: impl IntoIterator<Item = impl Into<crate::components::Color>>,
    ) -> Self {
        self.colors = Some(colors.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_labels(
        mut self,
        labels: impl IntoIterator<Item = impl Into<crate::components::Label>>,
    ) -> Self {
        self.labels = Some(labels.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_draw_order(mut self, draw_order: impl Into<crate::components::DrawOrder>) -> Self {
        self.draw_order = Some(draw_order.into());
        self
    }

    pub fn with_class_ids(
        mut self,
        class_ids: impl IntoIterator<Item = impl Into<crate::components::ClassId>>,
    ) -> Self {
        self.class_ids = Some(class_ids.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_keypoint_ids(
        mut self,
        keypoint_ids: impl IntoIterator<Item = impl Into<crate::components::KeypointId>>,
    ) -> Self {
        self.keypoint_ids = Some(keypoint_ids.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_instance_keys(
        mut self,
        instance_keys: impl IntoIterator<Item = impl Into<crate::components::InstanceKey>>,
    ) -> Self {
        self.instance_keys = Some(instance_keys.into_iter().map(Into::into).collect());
        self
    }
}
