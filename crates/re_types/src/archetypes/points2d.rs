// NOTE: This file was autogenerated by re_types_builder; DO NOT EDIT.

/// A 2D point cloud with positions and optional colors, radii, labels, etc.
#[derive(Debug, Clone, PartialEq)]
pub struct Points2D {
    /// All the actual 2D points that make up the point cloud.
    pub points: Vec<crate::components::Point2D>,

    /// Optional radii for the points, effectively turning them into circles.
    pub radii: Option<Vec<crate::components::Radius>>,

    /// Optional colors for the points.
    pub colors: Option<Vec<crate::components::Color>>,

    /// Optional text labels for the points.
    pub labels: Option<Vec<crate::components::Label>>,

    /// An optional floating point value that specifies the 2D drawing order.
    /// Objects with higher values are drawn on top of those with lower values.
    ///
    /// The default for 2D points is 30.0.
    pub draw_order: Option<crate::components::DrawOrder>,

    /// Optional class Ids for the points.
    ///
    /// The class ID provides colors and labels if not specified explicitly.
    pub class_ids: Option<Vec<crate::components::ClassId>>,

    /// Optional keypoint IDs for the points, identifying them within a class.
    ///
    /// If keypoint IDs are passed in but no class IDs were specified, the class ID will
    /// default to 0.
    /// This is useful to identify points within a single classification (which is identified
    /// with `class_id`).
    /// E.g. the classification might be 'Person' and the keypoints refer to joints on a
    /// detected skeleton.
    pub keypoint_ids: Option<Vec<crate::components::KeypointId>>,

    /// Unique identifiers for each individual point in the batch.
    pub instance_keys: Option<Vec<crate::components::InstanceKey>>,
}

impl Points2D {
    pub const REQUIRED_COMPONENTS: [crate::ComponentName; 1] =
        [crate::ComponentName::Borrowed("rerun.components.Point2D")];

    pub const RECOMMENDED_COMPONENTS: [crate::ComponentName; 2] = [
        crate::ComponentName::Borrowed("rerun.components.Radius"),
        crate::ComponentName::Borrowed("rerun.components.Color"),
    ];

    pub const OPTIONAL_COMPONENTS: [crate::ComponentName; 5] = [
        crate::ComponentName::Borrowed("rerun.components.Label"),
        crate::ComponentName::Borrowed("rerun.components.DrawOrder"),
        crate::ComponentName::Borrowed("rerun.components.ClassId"),
        crate::ComponentName::Borrowed("rerun.components.KeypointId"),
        crate::ComponentName::Borrowed("rerun.components.InstanceKey"),
    ];

    pub const ALL_COMPONENTS: [crate::ComponentName; 8] = [
        crate::ComponentName::Borrowed("rerun.components.Point2D"),
        crate::ComponentName::Borrowed("rerun.components.Radius"),
        crate::ComponentName::Borrowed("rerun.components.Color"),
        crate::ComponentName::Borrowed("rerun.components.Label"),
        crate::ComponentName::Borrowed("rerun.components.DrawOrder"),
        crate::ComponentName::Borrowed("rerun.components.ClassId"),
        crate::ComponentName::Borrowed("rerun.components.KeypointId"),
        crate::ComponentName::Borrowed("rerun.components.InstanceKey"),
    ];
}

impl crate::Archetype for Points2D {
    fn name() -> crate::ArchetypeName {
        crate::ArchetypeName::Borrowed("rerun.archetypes.Points2D")
    }

    fn required_components() -> Vec<crate::ComponentName> {
        Self::REQUIRED_COMPONENTS.to_vec()
    }

    fn recommended_components() -> Vec<crate::ComponentName> {
        Self::RECOMMENDED_COMPONENTS.to_vec()
    }

    fn optional_components() -> Vec<crate::ComponentName> {
        Self::OPTIONAL_COMPONENTS.to_vec()
    }

    // TODO: hashmaps

    #[allow(clippy::unimplemented)]
    fn to_arrow_datatypes() -> Vec<::arrow2::datatypes::DataType> {
        use crate::Component as _;
        vec![
            crate::components::Point2D::to_arrow_datatype(),
            crate::components::Radius::to_arrow_datatype(),
            crate::components::Color::to_arrow_datatype(),
            crate::components::Label::to_arrow_datatype(),
            crate::components::DrawOrder::to_arrow_datatype(),
            crate::components::ClassId::to_arrow_datatype(),
            crate::components::KeypointId::to_arrow_datatype(),
            crate::components::InstanceKey::to_arrow_datatype(),
        ]
    }

    fn to_arrow(&self) -> ::re_log_types::DataCellVec {
        [
            Some(crate::to_arrow::<crate::components::Point2D>(
                self.points.iter().map(::std::borrow::Cow::Borrowed),
            )),
            crate::to_arrow_opt::<crate::components::Radius>(self.radii.as_ref()),
            crate::to_arrow_opt::<crate::components::Color>(self.colors.as_ref()),
            crate::to_arrow_opt::<crate::components::Label>(self.labels.as_ref()),
            crate::to_arrow_opt::<crate::components::DrawOrder>(
                self.draw_order.as_ref().map(|data| [data]),
            ),
            crate::to_arrow_opt::<crate::components::ClassId>(self.class_ids.as_ref()),
            crate::to_arrow_opt::<crate::components::KeypointId>(self.keypoint_ids.as_ref()),
            crate::to_arrow_opt::<crate::components::InstanceKey>(self.instance_keys.as_ref()),
        ]
        .into_iter()
        .flatten()
        .collect()
    }

    // fn from_arrow(cells: &[&::re_log_types::DataCell]) -> Self
    // where
    //     Self: Sized;
}

impl Points2D {
    pub fn new(points: impl IntoIterator<Item = impl Into<crate::components::Point2D>>) -> Self {
        Self {
            points: points.into_iter().map(Into::into).collect(),
            radii: None,
            colors: None,
            labels: None,
            draw_order: None,
            class_ids: None,
            keypoint_ids: None,
            instance_keys: None,
        }
    }

    pub fn with_radii(
        mut self,
        radii: impl IntoIterator<Item = impl Into<crate::components::Radius>>,
    ) -> Self {
        self.radii = Some(radii.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_colors(
        mut self,
        colors: impl IntoIterator<Item = impl Into<crate::components::Color>>,
    ) -> Self {
        self.colors = Some(colors.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_labels(
        mut self,
        labels: impl IntoIterator<Item = impl Into<crate::components::Label>>,
    ) -> Self {
        self.labels = Some(labels.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_draw_order(mut self, draw_order: impl Into<crate::components::DrawOrder>) -> Self {
        self.draw_order = Some(draw_order.into());
        self
    }

    pub fn with_class_ids(
        mut self,
        class_ids: impl IntoIterator<Item = impl Into<crate::components::ClassId>>,
    ) -> Self {
        self.class_ids = Some(class_ids.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_keypoint_ids(
        mut self,
        keypoint_ids: impl IntoIterator<Item = impl Into<crate::components::KeypointId>>,
    ) -> Self {
        self.keypoint_ids = Some(keypoint_ids.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_instance_keys(
        mut self,
        instance_keys: impl IntoIterator<Item = impl Into<crate::components::InstanceKey>>,
    ) -> Self {
        self.instance_keys = Some(instance_keys.into_iter().map(Into::into).collect());
        self
    }
}
