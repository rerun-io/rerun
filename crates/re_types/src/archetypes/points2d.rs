// NOTE: This file was autogenerated by re_types_builder; DO NOT EDIT.

#![allow(trivial_numeric_casts)]
#![allow(unused_parens)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::map_flatten)]
#![allow(clippy::needless_question_mark)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::unnecessary_cast)]

#[doc = "A 2D point cloud with positions and optional colors, radii, labels, etc."]
#[derive(Debug, Clone, PartialEq)]
pub struct Points2D {
    #[doc = "All the actual 2D points that make up the point cloud."]
    pub points: Vec<crate::components::Point2D>,

    #[doc = "Optional radii for the points, effectively turning them into circles."]
    pub radii: Option<Vec<crate::components::Radius>>,

    #[doc = "Optional colors for the points."]
    pub colors: Option<Vec<crate::components::Color>>,

    #[doc = "Optional text labels for the points."]
    pub labels: Option<Vec<crate::components::Label>>,

    #[doc = "An optional floating point value that specifies the 2D drawing order."]
    #[doc = "Objects with higher values are drawn on top of those with lower values."]
    #[doc = ""]
    #[doc = "The default for 2D points is 30.0."]
    pub draw_order: Option<crate::components::DrawOrder>,

    #[doc = "Optional class Ids for the points."]
    #[doc = ""]
    #[doc = "The class ID provides colors and labels if not specified explicitly."]
    pub class_ids: Option<Vec<crate::components::ClassId>>,

    #[doc = "Optional keypoint IDs for the points, identifying them within a class."]
    #[doc = ""]
    #[doc = "If keypoint IDs are passed in but no class IDs were specified, the class ID will"]
    #[doc = "default to 0."]
    #[doc = "This is useful to identify points within a single classification (which is identified"]
    #[doc = "with `class_id`)."]
    #[doc = "E.g. the classification might be 'Person' and the keypoints refer to joints on a"]
    #[doc = "detected skeleton."]
    pub keypoint_ids: Option<Vec<crate::components::KeypointId>>,

    #[doc = "Unique identifiers for each individual point in the batch."]
    pub instance_keys: Option<Vec<crate::components::InstanceKey>>,
}

impl Points2D {
    pub const REQUIRED_COMPONENTS: [crate::ComponentName; 1usize] =
        [crate::ComponentName::Borrowed("rerun.components.Point2D")];

    pub const RECOMMENDED_COMPONENTS: [crate::ComponentName; 2usize] = [
        crate::ComponentName::Borrowed("rerun.components.Radius"),
        crate::ComponentName::Borrowed("rerun.components.Color"),
    ];

    pub const OPTIONAL_COMPONENTS: [crate::ComponentName; 5usize] = [
        crate::ComponentName::Borrowed("rerun.components.Label"),
        crate::ComponentName::Borrowed("rerun.components.DrawOrder"),
        crate::ComponentName::Borrowed("rerun.components.ClassId"),
        crate::ComponentName::Borrowed("rerun.components.KeypointId"),
        crate::ComponentName::Borrowed("rerun.components.InstanceKey"),
    ];

    pub const ALL_COMPONENTS: [crate::ComponentName; 8usize] = [
        crate::ComponentName::Borrowed("rerun.components.Point2D"),
        crate::ComponentName::Borrowed("rerun.components.Radius"),
        crate::ComponentName::Borrowed("rerun.components.Color"),
        crate::ComponentName::Borrowed("rerun.components.Label"),
        crate::ComponentName::Borrowed("rerun.components.DrawOrder"),
        crate::ComponentName::Borrowed("rerun.components.ClassId"),
        crate::ComponentName::Borrowed("rerun.components.KeypointId"),
        crate::ComponentName::Borrowed("rerun.components.InstanceKey"),
    ];
}

impl crate::Archetype for Points2D {
    fn name() -> crate::ArchetypeName {
        crate::ArchetypeName::Borrowed("rerun.archetypes.Points2D")
    }

    fn required_components() -> Vec<crate::ComponentName> {
        Self::REQUIRED_COMPONENTS.to_vec()
    }

    fn recommended_components() -> Vec<crate::ComponentName> {
        Self::RECOMMENDED_COMPONENTS.to_vec()
    }

    fn optional_components() -> Vec<crate::ComponentName> {
        Self::OPTIONAL_COMPONENTS.to_vec()
    }

    #[allow(clippy::todo)]
    fn to_arrow_datatypes() -> Vec<arrow2::datatypes::DataType> {
        todo!("query the registry for all fqnames");
    }
}

impl Points2D {
    pub fn new(points: impl IntoIterator<Item = impl Into<crate::components::Point2D>>) -> Self {
        Self {
            points: points.into_iter().map(Into::into).collect(),
            radii: None,
            colors: None,
            labels: None,
            draw_order: None,
            class_ids: None,
            keypoint_ids: None,
            instance_keys: None,
        }
    }

    pub fn with_radii(
        mut self,
        radii: impl IntoIterator<Item = impl Into<crate::components::Radius>>,
    ) -> Self {
        self.radii = Some(radii.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_colors(
        mut self,
        colors: impl IntoIterator<Item = impl Into<crate::components::Color>>,
    ) -> Self {
        self.colors = Some(colors.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_labels(
        mut self,
        labels: impl IntoIterator<Item = impl Into<crate::components::Label>>,
    ) -> Self {
        self.labels = Some(labels.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_draw_order(mut self, draw_order: impl Into<crate::components::DrawOrder>) -> Self {
        self.draw_order = Some(draw_order.into());
        self
    }

    pub fn with_class_ids(
        mut self,
        class_ids: impl IntoIterator<Item = impl Into<crate::components::ClassId>>,
    ) -> Self {
        self.class_ids = Some(class_ids.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_keypoint_ids(
        mut self,
        keypoint_ids: impl IntoIterator<Item = impl Into<crate::components::KeypointId>>,
    ) -> Self {
        self.keypoint_ids = Some(keypoint_ids.into_iter().map(Into::into).collect());
        self
    }

    pub fn with_instance_keys(
        mut self,
        instance_keys: impl IntoIterator<Item = impl Into<crate::components::InstanceKey>>,
    ) -> Self {
        self.instance_keys = Some(instance_keys.into_iter().map(Into::into).collect());
        self
    }
}
