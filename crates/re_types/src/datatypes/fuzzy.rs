// NOTE: This file was autogenerated by re_types_builder; DO NOT EDIT.

#![allow(trivial_numeric_casts)]
#![allow(unused_parens)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::map_flatten)]
#![allow(clippy::needless_question_mark)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::unnecessary_cast)]

#[derive(Debug, Clone, PartialEq)]
pub struct AffixFuzzer1 {
    pub single_float_optional: Option<f32>,
    pub single_string_required: String,
    pub single_string_optional: Option<String>,
    pub many_floats_optional: Option<Vec<f32>>,
    pub many_strings_required: Vec<String>,
    pub many_strings_optional: Option<Vec<String>>,
}

impl crate::Datatype for AffixFuzzer1 {
    #[inline]
    fn name() -> crate::DatatypeName {
        crate::DatatypeName::Borrowed("rerun.testing.datatypes.AffixFuzzer1")
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    #[inline]
    fn to_arrow_datatype() -> arrow2::datatypes::DataType {
        use ::arrow2::datatypes::*;
        DataType::Extension(
            "rerun.testing.datatypes.AffixFuzzer1".to_owned(),
            Box::new(DataType::Struct(vec![
                Field {
                    name: "single_float_optional".to_owned(),
                    data_type: DataType::Float32,
                    is_nullable: true,
                    metadata: [].into(),
                },
                Field {
                    name: "single_string_required".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: false,
                    metadata: [].into(),
                },
                Field {
                    name: "single_string_optional".to_owned(),
                    data_type: DataType::Utf8,
                    is_nullable: true,
                    metadata: [].into(),
                },
                Field {
                    name: "many_floats_optional".to_owned(),
                    data_type: DataType::List(Box::new(Field {
                        name: "item".to_owned(),
                        data_type: DataType::Float32,
                        is_nullable: true,
                        metadata: [].into(),
                    })),
                    is_nullable: true,
                    metadata: [].into(),
                },
                Field {
                    name: "many_strings_required".to_owned(),
                    data_type: DataType::List(Box::new(Field {
                        name: "item".to_owned(),
                        data_type: DataType::Utf8,
                        is_nullable: false,
                        metadata: [].into(),
                    })),
                    is_nullable: false,
                    metadata: [].into(),
                },
                Field {
                    name: "many_strings_optional".to_owned(),
                    data_type: DataType::List(Box::new(Field {
                        name: "item".to_owned(),
                        data_type: DataType::Utf8,
                        is_nullable: true,
                        metadata: [].into(),
                    })),
                    is_nullable: true,
                    metadata: [].into(),
                },
            ])),
            None,
        )
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct AffixFuzzer2(pub Option<f32>);

impl crate::Datatype for AffixFuzzer2 {
    #[inline]
    fn name() -> crate::DatatypeName {
        crate::DatatypeName::Borrowed("rerun.testing.datatypes.AffixFuzzer2")
    }

    #[allow(unused_imports, clippy::wildcard_imports)]
    #[inline]
    fn to_arrow_datatype() -> arrow2::datatypes::DataType {
        use ::arrow2::datatypes::*;
        DataType::Extension(
            "rerun.testing.datatypes.AffixFuzzer2".to_owned(),
            Box::new(DataType::Float32),
            None,
        )
    }
}
