include "arrow/attributes.fbs";
include "fbs/attributes.fbs";
include "rust/attributes.fbs";

include "rerun/testing/datatypes/fuzzy.fbs";

namespace rerun.testing.components;

// ---

table AffixFuzzer1 (
  "attr.arrow.transparent",
  "attr.rust.derive": "Debug, Clone, PartialEq",
  order: 100
) {
  single_required: rerun.testing.datatypes.AffixFuzzer1 (required);
}

table AffixFuzzer2 (
  "attr.arrow.transparent",
  "attr.rust.derive": "Debug, Clone, PartialEq",
  "attr.rust.tuple_struct",
  order: 200
) {
  single_required: rerun.testing.datatypes.AffixFuzzer1 (required);
}

table AffixFuzzer3 (
  "attr.rust.derive": "Debug, Clone, PartialEq",
  order: 300
) {
  single_required: rerun.testing.datatypes.AffixFuzzer1 (required);
}

table AffixFuzzer4 (
  "attr.arrow.transparent",
  "attr.rust.derive": "Debug, Clone, PartialEq",
  order: 400
) {
  single_optional: rerun.testing.datatypes.AffixFuzzer1;
}

table AffixFuzzer5 (
  "attr.arrow.transparent",
  "attr.rust.derive": "Debug, Clone, PartialEq",
  "attr.rust.tuple_struct",
  order: 500
) {
  single_optional: rerun.testing.datatypes.AffixFuzzer1;
}

table AffixFuzzer6 (
  "attr.rust.derive": "Debug, Clone, PartialEq",
  order: 600
) {
  single_optional: rerun.testing.datatypes.AffixFuzzer1;
}

table AffixFuzzer7 (
  "attr.rust.derive": "Debug, Clone, PartialEq",
  order: 700
) {
  many_optional: [rerun.testing.datatypes.AffixFuzzer1] (order: 100);
  single_float_optional: float (order: 101);
  single_string_required: string (order: 102, required);
  single_string_optional: string (order: 103);
  many_floats_optional: [float] (order: 104);
  many_strings_required: [string] (order: 105, required);
  many_strings_optional: [string] (order: 106);
  // TODO(cmc): the ugly bug we need to take care of at some point
  // many_transparent_optionals: rerun.testing.datatypes.AffixFuzzer2 (order: 107);
}
