include "fbs/attributes.fbs";

include "rerun/datatypes.fbs";
include "rerun/components.fbs";

namespace rerun.archetypes;

// ---

/// Log a double-precision scalar that will be visualized as a timeseries plot.
///
/// The current simulation time will be used for the time/X-axis, hence scalars
/// cannot be timeless!
///
/// TODO: example
///
/// Understanding the plot and attributes hierarchy
/// -----------------------------------------------
///
/// Timeseries come in three parts: points, lines and finally the plots
/// themselves. As a user of the Rerun SDK, your one and only entrypoint into
/// that hierarchy is through the lowest-level layer: the points.
///
/// When logging scalars and their attributes (label, color, radius, scattered)
/// through this function, Rerun will turn them into points with similar
/// attributes. From these points, lines with appropriate attributes can then be
/// inferred; and from these inferred lines, plots with appropriate attributes
/// will be inferred in turn!
///
/// In terms of actual hierarchy:
///
/// - Each space represents a single plot.
/// - Each entity path within a space that contains scalar data is a line within that plot.
/// - Each logged scalar is a point.
///
/// E.g. the following:
/// TODO: update and fuse into examples
/// ```python
/// t=1.0
/// rerun.log_scalar("trig/sin", math.sin(t), label="sin(t)", color=[255, 0, 0])
/// rerun.log_scalar("trig/cos", math.cos(t), label="cos(t)", color=[0, 0, 255])
/// ```
/// will yield a single plot (space = `trig`), comprised of two lines
/// (entity paths `trig/sin` and `trig/cos`).
table TimeSeriesScalar (
  "attr.rust.derive": "PartialEq",
  order: 100
) {
  // --- Required ---

  /// The scalar value to log.
  scalar: rerun.components.Scalar ("attr.rerun.component_required", order: 1000);

  // --- Recommended ---

  /// An optional radius for the point.
  ///
  /// Points within a single line do not have to share the same radius, the line
  /// will have differently sized segments as appropriate.
  ///
  /// If all points within a single entity path (i.e. a line) share the same
  /// radius, then this radius will be used as the line width too. Otherwise, the
  /// line will use the default width of `1.0`.
  radius: rerun.components.Radius ("attr.rerun.component_recommended", nullable, order: 2000);

  /// Optional color for the scalar entry.
  ///
  /// If left unspecified, a pseudo-random color will be used instead. That
  /// same color will apply to all points residing in the same entity path
  /// that don't have a color specified.
  ///
  /// Points within a single line do not have to share the same color, the line
  /// will have differently colored segments as appropriate.
  /// If all points within a single entity path (i.e. a line) share the same
  /// color, then this color will be used as the line color in the plot legend.
  /// Otherwise, the line will appear gray in the legend.
  color: rerun.components.Color ("attr.rerun.component_recommended", nullable, order: 2100);

  // --- Optional ---

  /// An optional label for the point.
  ///
  /// This won't show up on points at the moment, as our plots don't yet
  /// support displaying labels for individual points
  /// TODO(https://github.com/rerun-io/rerun/issues/1289). If all points
  /// within a single entity path (i.e. a line) share the same label, then
  /// this label will be used as the label for the line itself. Otherwise, the
  /// line will be named after the entity path. The plot itself is named after
  /// the space it's in.
  label: rerun.components.Text ("attr.rerun.component_optional", nullable, order: 3000);

  /// Specifies whether a point in a scatter plot should form a continuous line.
  ///
  /// If set to true, this scalar will be drawn as a point, akin to a scatterplot.
  /// Otherwise, it will form a continuous line with its neighbors.
  /// Points within a single line do not have to all share the same scatteredness:
  /// the line will switch between a scattered and a continuous representation as
  /// required.
  scattered: rerun.components.ScalarScattering ("attr.rerun.component_optional", nullable, order: 3100);
}
