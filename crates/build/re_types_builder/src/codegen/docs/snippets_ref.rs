//! Generate the snippets reference.

use std::cmp::Ordering;
use std::collections::{BTreeMap, BTreeSet, HashMap};
use std::path::PathBuf;

use anyhow::Context as _;
use camino::{Utf8Path, Utf8PathBuf};
use itertools::Itertools as _;

use crate::{CodeGenerator, GeneratedFiles, Object, ObjectKind, Objects, Reporter};

// ---

/// See `docs/snippets/snippets.toml` for more info
#[derive(Debug, serde::Deserialize)]
struct Config {
    snippets_ref: SnippetsRef,
}

#[derive(Debug, serde::Deserialize)]
struct SnippetsRef {
    snippets: OptOut,
    archetypes: OptOut,
    components: OptOut,

    // <feature_name, vec<snippet_name_qualified>>
    features: Vec<(String, Vec<String>)>,
}

#[derive(Debug, serde::Deserialize)]
struct OptOut {
    // <name, vec<snippet_name_qualified>>
    opt_out: BTreeMap<String, Vec<String>>,
}

/// Everything we know about a snippet, including which objects (archetypes, components, etc) it references.
#[expect(dead_code)]
#[derive(Debug, Clone)]
struct Snippet<'o> {
    path: PathBuf,
    name: String,
    name_qualified: String,

    python: bool,
    rust: bool,
    cpp: bool,

    description: Option<String>,
    contents: String,

    archetypes: BTreeSet<&'o Object>,
    components: BTreeSet<&'o Object>,
    archetypes_blueprint: BTreeSet<&'o Object>,
    components_blueprint: BTreeSet<&'o Object>,
    views: BTreeSet<&'o Object>,
}

/// Maps objects (archetypes, components, etc) back to snippets.
#[derive(Default, Debug)]
struct Snippets<'o> {
    per_name_qualified: HashMap<String, Snippet<'o>>,
    per_feature: Vec<(String, Vec<Snippet<'o>>)>,
    per_archetype: BTreeMap<&'o Object, Vec<Snippet<'o>>>,
    per_archetype_blueprint: BTreeMap<&'o Object, Vec<Snippet<'o>>>,
    per_view: BTreeMap<&'o Object, Vec<Snippet<'o>>>,
}

impl<'o> Snippets<'o> {
    fn merge_extend(&mut self, rhs: Self) {
        let Self {
            per_name_qualified,
            per_feature,
            per_archetype,
            per_archetype_blueprint,
            per_view,
        } = self;

        per_name_qualified.extend(rhs.per_name_qualified);
        per_feature.extend(rhs.per_feature);

        let merge_extend = |a: &mut BTreeMap<&'o Object, Vec<Snippet<'o>>>, b| {
            for (obj, snippets) in b {
                a.entry(obj).or_default().extend(snippets);
            }
        };

        merge_extend(per_archetype, rhs.per_archetype);
        merge_extend(per_view, rhs.per_view);
        merge_extend(per_archetype_blueprint, rhs.per_archetype_blueprint);
    }
}

// ---

pub struct SnippetsRefCodeGenerator {
    out_dir: Utf8PathBuf,
}

impl SnippetsRefCodeGenerator {
    pub fn new(out_dir: impl Into<Utf8PathBuf>) -> Self {
        Self {
            out_dir: out_dir.into(),
        }
    }
}

impl CodeGenerator for SnippetsRefCodeGenerator {
    fn generate(
        &mut self,
        reporter: &Reporter,
        objects: &Objects,
        _type_registry: &crate::TypeRegistry,
    ) -> GeneratedFiles {
        match self.generate_fallible(objects) {
            Ok(files) => files,
            Err(err) => {
                reporter.error_any(err);
                Default::default()
            }
        }
    }
}

impl SnippetsRefCodeGenerator {
    fn generate_fallible(&self, objects: &Objects) -> anyhow::Result<GeneratedFiles> {
        re_tracing::profile_function!();

        // NOTE: We're pointing to `main` instead of `latest` for now, because a lot of snippets
        // were recently renamed.
        // We can change that back during the next release.
        const SNIPPETS_URL: &str = "https://github.com/rerun-io/rerun/blob/main/docs/snippets/all";

        let mut files_to_write = GeneratedFiles::default();

        let snippets_dir = re_build_tools::cargo_metadata()
            .context("failed to read cargo metadata")?
            .workspace_root
            .join("docs/snippets");

        let snippets_dir_root = snippets_dir.join("all");
        let snippets_dir_archetypes = snippets_dir_root.clone();

        let config_path = snippets_dir.join("snippets.toml");
        let config = std::fs::read_to_string(config_path)?;
        let config: Config = toml::from_str(&config)?;

        let known_objects = KnownObjects::init(objects);

        let snippets = collect_snippets_recursively(
            &known_objects,
            &snippets_dir_archetypes,
            &config,
            &snippets_dir_root,
        )?;

        /// Generates a single row for one of the autogenerated tables.
        fn snippet_row(obj: &Object, snippet: &Snippet<'_>) -> anyhow::Result<String> {
            let obj_name = &obj.name;
            let obj_name_snake = obj.snake_case_name();
            let obj_kind = match obj.kind {
                ObjectKind::Datatype => "datatypes",
                ObjectKind::Component => "components",
                ObjectKind::Archetype => "archetypes",
                ObjectKind::View => "views",
            };

            let link_docs =
                format!("https://rerun.io/docs/reference/types/{obj_kind}/{obj_name_snake}");
            let link_docs = make_speculative_if_needed(obj_name, &link_docs)?;
            let obj_name_rendered =
                if obj.kind != ObjectKind::View && obj.scope().as_deref() == Some("blueprint") {
                    // Blueprint types have no website pages yet.
                    format!("`{obj_name}`")
                } else {
                    format!("[`{obj_name}`]({link_docs})")
                };

            let snippet_name_qualified = &snippet.name_qualified;
            let snippet_descr = snippet.description.clone().unwrap_or_default();

            let link_py = if snippet.python {
                let link = format!("{SNIPPETS_URL}/{snippet_name_qualified}.py");
                let link = make_speculative_if_needed(obj_name, &link)?;
                let link = make_speculative_if_needed(snippet_name_qualified, &link)?;
                format!("[üêç]({link})")
            } else {
                String::new()
            };
            let link_rs = if snippet.rust {
                let link = format!("{SNIPPETS_URL}/{snippet_name_qualified}.rs");
                let link = make_speculative_if_needed(obj_name, &link)?;
                let link = make_speculative_if_needed(snippet_name_qualified, &link)?;
                format!("[ü¶Ä]({link})")
            } else {
                String::new()
            };
            let link_cpp = if snippet.cpp {
                let link = format!("{SNIPPETS_URL}/{snippet_name_qualified}.cpp");
                let link = make_speculative_if_needed(obj_name, &link)?;
                let link = make_speculative_if_needed(snippet_name_qualified, &link)?;
                format!("[üåä]({link})")
            } else {
                String::new()
            };

            // NOTE: `/` is written with a UTF8 zero-width word joiner (<https://unicode-explorer.com/c/2060>)
            // on both sides in order to force the markdown renderer to *not* split it into two lines ("archetype/\nthing").
            #[expect(clippy::invisible_characters)]
            let snippet_name_qualified = &snippet.name_qualified.replace('/', "‚Å†/‚Å†");

            let row = format!(
                "| **{obj_name_rendered}** | `{snippet_name_qualified}` | {snippet_descr} | {link_py} | {link_rs} | {link_cpp} |"
            );

            Ok(row)
        }

        let opt_outs = &config.snippets_ref.snippets.opt_out;
        let archetype_opt_outs = &config.snippets_ref.archetypes.opt_out;
        let component_opt_outs = &config.snippets_ref.components.opt_out;

        let snippets_table = |snippets: &BTreeMap<&Object, Vec<Snippet<'_>>>| {
            let table = snippets
                .iter()
                .flat_map(|(obj, snippets)| {
                    let mut snippets = snippets.clone();
                    // NOTE: Gotta sort twice to make sure it stays stable after the second one.
                    snippets.sort_by(|a, b| a.name_qualified.cmp(&b.name_qualified));
                    snippets.sort_by(|a, b| {
                        if contains_whole_word(&a.name_qualified, &obj.snake_case_name()) {
                            // Snippets that contain the object in question in their name should
                            // bubble up to the top.
                            Ordering::Less
                        } else {
                            a.name_qualified.cmp(&b.name_qualified)
                        }
                    });
                    snippets.into_iter().map(move |snippet| (obj, snippet))
                })
                .filter(|(obj, snippet)| {
                    if opt_outs.contains_key(&snippet.name_qualified) {
                        return false;
                    }

                    if let Some(deprecation_summary) = obj.deprecation_summary() {
                        panic!("Snippet {} contained reference to deprecated object '{}'. Please migrate the snippet. Migration notice: {deprecation_summary}", snippet.name_qualified, obj.fqname);
                    }

                    if obj.kind == ObjectKind::Archetype
                        && let Some(opt_outs) = archetype_opt_outs.get(&obj.name)
                        && opt_outs.contains(&snippet.name_qualified) {
                        return false;
                    }

                    if obj.kind == ObjectKind::Component
                        && let Some(opt_outs) = component_opt_outs.get(&obj.name)
                        && opt_outs.contains(&snippet.name_qualified) {
                        return false;
                    }

                    true
                })
                .map(|(obj, snippet)| snippet_row(obj, &snippet))
                .collect::<Result<Vec<_>, _>>()?
                .join("\n");

            Ok::<_, anyhow::Error>(table)
        };

        let per_feature_table = snippets
            .per_feature
            .iter()
            .flat_map(|(feature, snippets)| {
                snippets.iter().map(move |snippet| (feature, snippet))
            })
            .map(|(feature, snippet)| {
                let snippet_name = &snippet.name;
                let snippet_name_qualified = &snippet.name_qualified;
                let snippet_descr = snippet.description.clone().unwrap_or_default();

                let link_py = if snippet.python {
                    let link = format!("{SNIPPETS_URL}/{snippet_name_qualified}.py");
                    let link = make_speculative_if_needed(&snippet.name_qualified, &link)?;
                    format!("[üêç]({link})")
                } else {
                    String::new()
                };
                let link_rs = if snippet.rust {
                    let link = format!("{SNIPPETS_URL}/{snippet_name_qualified}.rs");
                    let link = make_speculative_if_needed(&snippet.name_qualified, &link)?;
                    format!("[ü¶Ä]({link})")
                } else {
                    String::new()
                };
                let link_cpp = if snippet.cpp {
                    let link = format!("{SNIPPETS_URL}/{snippet_name_qualified}.cpp");
                    let link = make_speculative_if_needed(&snippet.name_qualified, &link)?;
                    format!("[üåä]({link})")
                } else {
                    String::new()
                };

                let row = format!("| **{feature}** | `{snippet_name}` | {snippet_descr} | {link_py} | {link_rs} | {link_cpp} |");

                Ok::<_, anyhow::Error>(row)
            })
                .collect::<Result<Vec<_>, _>>()?
            .join("\n");

        let per_archetype_table = snippets_table(&snippets.per_archetype)?;
        let per_archetype_blueprint_table = snippets_table(&snippets.per_archetype_blueprint)?;
        let per_view_table = snippets_table(&snippets.per_view)?;

        let autogen_warning = format!(
            "<!-- DO NOT EDIT! This file was auto-generated by {} -->",
            file!().replace('\\', "/")
        );
        // NOTE: `C++` is written with a UTF8 zero-width word joiner (<https://unicode-explorer.com/c/2060>) in
        // order to force the markdown renderer to *not* split it into two lines ("C+\n+").
        #[expect(clippy::invisible_characters)]
        let out = format!(
            "
{autogen_warning}

# Snippet index reference

This file acts as an index reference for all of our [snippets](./README.md).

Use it to quickly find copy-pastable snippets of code for any Rerun feature you're interested in (APIs, Archetypes, Blueprint, etc).

---

*Table of contents:*
* [Features](#features)
* [Types](#types)
    * [Archetypes](#archetypes)
    * [Views](#views-blueprint)
    * [Archetypes (blueprint)](#archetypes-blueprint)


## Features

| Feature | Example | Description | Python | Rust | C+‚Å†+ |
| ------- | ------- | ----------- | :----: | :--: | :-------: |
{per_feature_table}


## Types


### Archetypes

_All snippets, organized by the [`Archetype`](https://rerun.io/docs/reference/types/archetypes)(s) they use._

| Archetype | Snippet | Description | Python | Rust | C+‚Å†+ |
| --------- | ------- | ----------- | :----: | :--: | :-------: |
{per_archetype_table}


### Views (blueprint)

_All snippets, organized by the [`View`](https://rerun.io/docs/reference/types/views)(s) they use._

| Component | Snippet | Description | Python | Rust | C+‚Å†+ |
| --------- | ------- | ----------- | :----: | :--: | :-------: |
{per_view_table}


### Archetypes (blueprint)

_All snippets, organized by the blueprint-related [`Archetype`](https://rerun.io/docs/reference/types/archetypes)(s) they use._

| Archetype | Snippet | Description | Python | Rust | C+‚Å†+ |
| --------- | ------- | ----------- | :----: | :--: | :-------: |
{per_archetype_blueprint_table}
"
        );

        #[expect(clippy::string_add)]
        files_to_write.insert(self.out_dir.join("INDEX.md"), out.trim().to_owned() + "\n");

        Ok(files_to_write)
    }
}

fn collect_snippets_recursively<'o>(
    known_objects: &KnownObjects<'o>,
    dir: &Utf8Path,
    config: &Config,
    snippet_root_path: &Utf8Path,
) -> anyhow::Result<Snippets<'o>> {
    let mut snippets = Snippets::default();

    #[expect(clippy::unwrap_used)] // we just use unwrap for string <-> path conversion here
    for snippet in dir.read_dir()? {
        let snippet = snippet?;
        let meta = snippet.metadata()?;
        let path = snippet.path();

        if path.file_name().is_some_and(|name| name == "__init__.py") {
            continue;
        }

        let name = path.file_stem().unwrap().to_str().unwrap().to_owned();
        let name_qualified = path.strip_prefix(snippet_root_path)?.with_extension("");
        let name_qualified = name_qualified.to_str().unwrap().replace('\\', "/");

        if meta.is_dir() {
            snippets.merge_extend(collect_snippets_recursively(
                known_objects,
                Utf8Path::from_path(&path).unwrap(),
                config,
                snippet_root_path,
            )?);
            continue;
        }

        // We only track the Python one. We'll derive the other two from there, if they exist at all.
        if path.extension().is_none_or(|p| p != "py") {
            continue;
        }

        let contents = std::fs::read_to_string(&path)?;

        let description = {
            let lines = contents
                .lines()
                .skip_while(|line| line.trim().is_empty()) // Strip leading empty lines.
                .collect_vec();
            if lines.first().is_some_and(|line| line.trim() == "\"\"\"") {
                // Multi-line Python docstrings.
                lines.iter().skip(1).take(1).next()
            } else {
                // Single-line Python docstrings.
                lines.iter().take(1).next().filter(|s| s.contains("\"\"\""))
            }
            .map(|s| s.replace("\"\"\"", "").trim_end_matches('.').to_owned())
        };

        // All archetypes, components, etc that this snippet refers to.
        let mut archetypes = BTreeSet::default();
        let mut components = BTreeSet::default();
        let mut archetypes_blueprint = BTreeSet::default();
        let mut components_blueprint = BTreeSet::default();
        let mut views = BTreeSet::default();

        // Fill the sets by grepping into the snippet's contents.
        for (objs, set) in [
            (&known_objects.archetypes, &mut archetypes),
            (&known_objects.components, &mut components),
            (&known_objects.views, &mut views),
            (
                &known_objects.archetypes_blueprint,
                &mut archetypes_blueprint,
            ),
            (
                &known_objects.components_blueprint,
                &mut components_blueprint,
            ),
        ] {
            for obj in objs {
                if contains_whole_word(&contents, &obj.name) {
                    set.insert(*obj);
                }
            }
        }

        let python = true;
        let rust = path.with_extension("rs").exists();
        let cpp = path.with_extension("cpp").exists();

        let snippet = Snippet {
            path,
            name,
            name_qualified,

            python,
            rust,

            cpp,
            description,
            contents,

            archetypes,
            components,
            archetypes_blueprint,
            components_blueprint,
            views,
        };

        snippets
            .per_name_qualified
            .insert(snippet.name_qualified.clone(), snippet.clone());

        // Fill the reverse indices.
        for (objs, index) in [
            (&snippet.archetypes, &mut snippets.per_archetype),
            (&snippet.views, &mut snippets.per_view),
            (
                &snippet.archetypes_blueprint,
                &mut snippets.per_archetype_blueprint,
            ),
        ] {
            for obj in objs {
                index.entry(obj).or_default().push(snippet.clone());
            }
        }
    }

    {
        let mut per_feature = Vec::new();
        for (feature, names_qualified) in &config.snippets_ref.features {
            per_feature.push((
                feature.clone(),
                names_qualified
                    .iter()
                    .filter_map(|name_qualified| {
                        snippets.per_name_qualified.get(name_qualified).cloned()
                    })
                    .collect_vec(),
            ));
        }
        snippets.per_feature = per_feature;
    }

    Ok(snippets)
}

/// Does the source text contain the given word as a whole word,
/// i.e. with word-breaking characters before and after it?
fn contains_whole_word(contents: &str, needle: &str) -> bool {
    let Some(pos) = contents.find(needle) else {
        return false;
    };

    if 0 < pos {
        let byte_before = contents.as_bytes()[pos - 1];
        if byte_before.is_ascii_alphanumeric() || byte_before == b':' {
            return false;
        }
    }
    if pos + needle.len() < contents.len()
        && contents.as_bytes()[pos + needle.len()].is_ascii_alphanumeric()
    {
        return false;
    }
    true
}

#[test]
fn test_contains_whole_word() {
    assert!(contains_whole_word("foo", "foo"));
    assert!(contains_whole_word("foo bar", "foo"));
    assert!(contains_whole_word("foo bar", "bar"));
    assert!(contains_whole_word("foo bar baz", "foo"));
    assert!(contains_whole_word("foo bar baz", "bar"));
    assert!(contains_whole_word("foo bar baz", "baz"));
    assert!(!contains_whole_word("foobar", "foo"));
    assert!(!contains_whole_word("foobar", "bar"));
    assert!(contains_whole_word("underscore_is_breaking", "underscore"));
    assert!(contains_whole_word("underscore_is_breaking", "is_breaking"));
    assert!(contains_whole_word(
        "rrb.ActiveVisualizers(rrb.visualizers.SeriesPoints)",
        "SeriesPoints" // plural!
    ));
    assert!(!contains_whole_word(
        "rrb.ActiveVisualizers(rrb.visualizers.SeriesPoints)",
        "SeriesPoint" // singular!
    ));
    assert!(
        !contains_whole_word("jawOpen:Scalar", "Scalar"),
        "Special handling"
    );
}

/// Neatly organized [`Object`]s (archetypes, components, etc).
#[derive(Debug)]
struct KnownObjects<'o> {
    archetypes: BTreeSet<&'o Object>,
    components: BTreeSet<&'o Object>,

    archetypes_blueprint: BTreeSet<&'o Object>,
    components_blueprint: BTreeSet<&'o Object>,

    views: BTreeSet<&'o Object>,
}

impl<'o> KnownObjects<'o> {
    fn init(objects: &'o Objects) -> Self {
        let (
            mut archetypes,
            mut components,
            mut archetypes_blueprint,
            mut components_blueprint,
            mut views,
        ) = (
            BTreeSet::new(),
            BTreeSet::new(),
            BTreeSet::new(),
            BTreeSet::new(),
            BTreeSet::new(),
        );

        for object in objects.values() {
            // skip test-only archetypes
            if object.is_testing() {
                continue;
            }

            match object.kind {
                ObjectKind::Archetype if object.scope().as_deref() == Some("blueprint") => {
                    archetypes_blueprint.insert(object);
                }

                ObjectKind::Archetype => {
                    archetypes.insert(object);
                }

                ObjectKind::Component if object.scope().as_deref() == Some("blueprint") => {
                    components_blueprint.insert(object);
                }

                ObjectKind::Component => {
                    components.insert(object);
                }

                ObjectKind::View => {
                    views.insert(object);
                }

                ObjectKind::Datatype => {}
            }
        }

        Self {
            archetypes,
            components,
            archetypes_blueprint,
            components_blueprint,
            views,
        }
    }
}

// ---

/// Returns `true` if the given name has not been released yet.
fn is_speculative(any_name: &str) -> anyhow::Result<bool> {
    let is_pre_0_25_release = {
        // Reminder of what those look like:
        // env!("CARGO_PKG_VERSION") = "0.21.0-alpha.1+dev"
        // env!("CARGO_PKG_VERSION_MAJOR") = "0"
        // env!("CARGO_PKG_VERSION_MINOR") = "21"
        // env!("CARGO_PKG_VERSION_PATCH") = "0"
        // env!("CARGO_PKG_VERSION_PRE") = "alpha.1"

        let minor: u32 = env!("CARGO_PKG_VERSION_MINOR")
            .parse()
            .context("couldn't parse minor crate version")?;

        minor < 25
    };

    const RELEASED_IN_0_25: &[&str] = &[
        // archetypes & components
        "DynamicArchetype",
        // snippets
        "tutorials/dynamic_archetype",
    ];

    let is_speculative = is_pre_0_25_release && RELEASED_IN_0_25.contains(&any_name);

    Ok(is_speculative)
}

/// Appends `?speculative-link` to the given link if the associated object has not been released yet.
fn make_speculative_if_needed(name: &str, link: &str) -> anyhow::Result<String> {
    if is_speculative(name)? {
        return Ok(format!("{link}?speculative-link"));
    }
    Ok(link.to_owned())
}
