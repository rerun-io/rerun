// NOTE: This file was autogenerated by re_types_builder; DO NOT EDIT.
// Based on "crates/re_types/definitions/rerun/datatypes/image_variant.fbs"

#pragma once

#include "../result.hpp"

#include <cstdint>
#include <cstring>
#include <memory>
#include <utility>

namespace arrow {
    class DataType;
    class DenseUnionBuilder;
    class MemoryPool;
} // namespace arrow

namespace rerun {
    namespace datatypes {
        namespace detail {
            enum class ImageVariantTag : uint8_t {
                /// Having a special empty state makes it possible to implement move-semantics. We
                /// need to be able to leave the object in a state which we can run the destructor
                /// on.
                NONE = 0,
                Mono,
                Rgb,
                Rgba,
                Segmentation,
                Depth,
            };

            union ImageVariantData {
                /// An MxN tensor, treated as a grayscale image.
                bool mono;

                /// An MxNx3 tensor, treated as an RGB image.
                bool rgb;

                /// An MxNx4 tensor, treated as an RGBA image.
                bool rgba;

                /// An MxN tensor where each element is a ClassID, to be used with an
                /// AnnotationContext.
                bool segmentation;

                /// An MxN tensor where each element represents a depth value.
                bool depth;

                ImageVariantData() {}

                ~ImageVariantData() {}

                void swap(ImageVariantData &other) noexcept {
                    // This bitwise swap would fail for self-referential types, but we don't have
                    // any of those.
                    char temp[sizeof(ImageVariantData)];
                    void *otherbytes = reinterpret_cast<void *>(&other);
                    void *thisbytes = reinterpret_cast<void *>(this);
                    std::memcpy(temp, thisbytes, sizeof(ImageVariantData));
                    std::memcpy(thisbytes, otherbytes, sizeof(ImageVariantData));
                    std::memcpy(otherbytes, temp, sizeof(ImageVariantData));
                }
            };
        } // namespace detail

        /// An enum indicating the type of `Image`
        struct ImageVariant {
            ImageVariant() : _tag(detail::ImageVariantTag::NONE) {}

            ImageVariant(const ImageVariant &other) : _tag(other._tag) {
                const void *otherbytes = reinterpret_cast<const void *>(&other._data);
                void *thisbytes = reinterpret_cast<void *>(&this->_data);
                std::memcpy(thisbytes, otherbytes, sizeof(detail::ImageVariantData));
            }

            ImageVariant &operator=(const ImageVariant &other) noexcept {
                ImageVariant tmp(other);
                this->swap(tmp);
                return *this;
            }

            ImageVariant(ImageVariant &&other) noexcept : _tag(detail::ImageVariantTag::NONE) {
                this->swap(other);
            }

            ImageVariant &operator=(ImageVariant &&other) noexcept {
                this->swap(other);
                return *this;
            }

            void swap(ImageVariant &other) noexcept {
                auto tag_temp = this->_tag;
                this->_tag = other._tag;
                other._tag = tag_temp;
                this->_data.swap(other._data);
            }

            /// An MxN tensor, treated as a grayscale image.
            static ImageVariant mono(bool mono) {
                ImageVariant self;
                self._tag = detail::ImageVariantTag::Mono;
                self._data.mono = std::move(mono);
                return self;
            }

            /// An MxNx3 tensor, treated as an RGB image.
            static ImageVariant rgb(bool rgb) {
                ImageVariant self;
                self._tag = detail::ImageVariantTag::Rgb;
                self._data.rgb = std::move(rgb);
                return self;
            }

            /// An MxNx4 tensor, treated as an RGBA image.
            static ImageVariant rgba(bool rgba) {
                ImageVariant self;
                self._tag = detail::ImageVariantTag::Rgba;
                self._data.rgba = std::move(rgba);
                return self;
            }

            /// An MxN tensor where each element is a ClassID, to be used with an AnnotationContext.
            static ImageVariant segmentation(bool segmentation) {
                ImageVariant self;
                self._tag = detail::ImageVariantTag::Segmentation;
                self._data.segmentation = std::move(segmentation);
                return self;
            }

            /// An MxN tensor where each element represents a depth value.
            static ImageVariant depth(bool depth) {
                ImageVariant self;
                self._tag = detail::ImageVariantTag::Depth;
                self._data.depth = std::move(depth);
                return self;
            }

            /// Returns the arrow data type this type corresponds to.
            static const std::shared_ptr<arrow::DataType> &arrow_datatype();

            /// Creates a new array builder with an array of this type.
            static Result<std::shared_ptr<arrow::DenseUnionBuilder>> new_arrow_array_builder(
                arrow::MemoryPool *memory_pool
            );

            /// Fills an arrow array builder with an array of this type.
            static Error fill_arrow_array_builder(
                arrow::DenseUnionBuilder *builder, const ImageVariant *elements, size_t num_elements
            );

          private:
            detail::ImageVariantTag _tag;
            detail::ImageVariantData _data;
        };
    } // namespace datatypes
} // namespace rerun
