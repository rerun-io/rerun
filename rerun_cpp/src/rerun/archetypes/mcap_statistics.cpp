// DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/cpp/mod.rs
// Based on "crates/store/re_sdk_types/definitions/rerun/archetypes/mcap_statistics.fbs".

#include "mcap_statistics.hpp"

#include "../collection_adapter_builtins.hpp"

namespace rerun::archetypes {
    McapStatistics McapStatistics::clear_fields() {
        auto archetype = McapStatistics();
        archetype.message_count =
            ComponentBatch::empty<rerun::components::Count>(Descriptor_message_count)
                .value_or_throw();
        archetype.schema_count =
            ComponentBatch::empty<rerun::components::Count>(Descriptor_schema_count)
                .value_or_throw();
        archetype.channel_count =
            ComponentBatch::empty<rerun::components::Count>(Descriptor_channel_count)
                .value_or_throw();
        archetype.attachment_count =
            ComponentBatch::empty<rerun::components::Count>(Descriptor_attachment_count)
                .value_or_throw();
        archetype.metadata_count =
            ComponentBatch::empty<rerun::components::Count>(Descriptor_metadata_count)
                .value_or_throw();
        archetype.chunk_count =
            ComponentBatch::empty<rerun::components::Count>(Descriptor_chunk_count)
                .value_or_throw();
        archetype.message_start_time =
            ComponentBatch::empty<rerun::components::Timestamp>(Descriptor_message_start_time)
                .value_or_throw();
        archetype.message_end_time =
            ComponentBatch::empty<rerun::components::Timestamp>(Descriptor_message_end_time)
                .value_or_throw();
        archetype.channel_message_counts =
            ComponentBatch::empty<rerun::components::ChannelMessageCounts>(
                Descriptor_channel_message_counts
            )
                .value_or_throw();
        return archetype;
    }

    Collection<ComponentColumn> McapStatistics::columns(const Collection<uint32_t>& lengths_) {
        std::vector<ComponentColumn> columns;
        columns.reserve(9);
        if (message_count.has_value()) {
            columns.push_back(message_count.value().partitioned(lengths_).value_or_throw());
        }
        if (schema_count.has_value()) {
            columns.push_back(schema_count.value().partitioned(lengths_).value_or_throw());
        }
        if (channel_count.has_value()) {
            columns.push_back(channel_count.value().partitioned(lengths_).value_or_throw());
        }
        if (attachment_count.has_value()) {
            columns.push_back(attachment_count.value().partitioned(lengths_).value_or_throw());
        }
        if (metadata_count.has_value()) {
            columns.push_back(metadata_count.value().partitioned(lengths_).value_or_throw());
        }
        if (chunk_count.has_value()) {
            columns.push_back(chunk_count.value().partitioned(lengths_).value_or_throw());
        }
        if (message_start_time.has_value()) {
            columns.push_back(message_start_time.value().partitioned(lengths_).value_or_throw());
        }
        if (message_end_time.has_value()) {
            columns.push_back(message_end_time.value().partitioned(lengths_).value_or_throw());
        }
        if (channel_message_counts.has_value()) {
            columns.push_back(channel_message_counts.value().partitioned(lengths_).value_or_throw()
            );
        }
        return columns;
    }

    Collection<ComponentColumn> McapStatistics::columns() {
        if (message_count.has_value()) {
            return columns(std::vector<uint32_t>(message_count.value().length(), 1));
        }
        if (schema_count.has_value()) {
            return columns(std::vector<uint32_t>(schema_count.value().length(), 1));
        }
        if (channel_count.has_value()) {
            return columns(std::vector<uint32_t>(channel_count.value().length(), 1));
        }
        if (attachment_count.has_value()) {
            return columns(std::vector<uint32_t>(attachment_count.value().length(), 1));
        }
        if (metadata_count.has_value()) {
            return columns(std::vector<uint32_t>(metadata_count.value().length(), 1));
        }
        if (chunk_count.has_value()) {
            return columns(std::vector<uint32_t>(chunk_count.value().length(), 1));
        }
        if (message_start_time.has_value()) {
            return columns(std::vector<uint32_t>(message_start_time.value().length(), 1));
        }
        if (message_end_time.has_value()) {
            return columns(std::vector<uint32_t>(message_end_time.value().length(), 1));
        }
        if (channel_message_counts.has_value()) {
            return columns(std::vector<uint32_t>(channel_message_counts.value().length(), 1));
        }
        return Collection<ComponentColumn>();
    }
} // namespace rerun::archetypes

namespace rerun {

    Result<Collection<ComponentBatch>> AsComponents<archetypes::McapStatistics>::as_batches(
        const archetypes::McapStatistics& archetype
    ) {
        using namespace archetypes;
        std::vector<ComponentBatch> cells;
        cells.reserve(9);

        if (archetype.message_count.has_value()) {
            cells.push_back(archetype.message_count.value());
        }
        if (archetype.schema_count.has_value()) {
            cells.push_back(archetype.schema_count.value());
        }
        if (archetype.channel_count.has_value()) {
            cells.push_back(archetype.channel_count.value());
        }
        if (archetype.attachment_count.has_value()) {
            cells.push_back(archetype.attachment_count.value());
        }
        if (archetype.metadata_count.has_value()) {
            cells.push_back(archetype.metadata_count.value());
        }
        if (archetype.chunk_count.has_value()) {
            cells.push_back(archetype.chunk_count.value());
        }
        if (archetype.message_start_time.has_value()) {
            cells.push_back(archetype.message_start_time.value());
        }
        if (archetype.message_end_time.has_value()) {
            cells.push_back(archetype.message_end_time.value());
        }
        if (archetype.channel_message_counts.has_value()) {
            cells.push_back(archetype.channel_message_counts.value());
        }

        return rerun::take_ownership(std::move(cells));
    }
} // namespace rerun
