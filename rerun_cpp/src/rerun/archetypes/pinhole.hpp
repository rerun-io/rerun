// DO NOT EDIT! This file was auto-generated by crates/re_types_builder/src/codegen/cpp/mod.rs
// Based on "crates/re_types/definitions/rerun/archetypes/pinhole.fbs".

#pragma once

#include "../arrow.hpp"
#include "../component_batch.hpp"
#include "../components/pinhole_projection.hpp"
#include "../components/resolution.hpp"
#include "../data_cell.hpp"
#include "../result.hpp"

#include <cstdint>
#include <optional>
#include <utility>
#include <vector>

namespace rerun {
    namespace archetypes {
        /// Camera perspective projection (a.k.a. intrinsics).
        ///
        /// ## Example
        ///
        /// ```cpp,ignore
        /// // Log a pinhole and a random image.
        ///
        /// #include <rerun.hpp>
        ///
        /// #include <algorithm>
        /// #include <cstdlib>
        /// #include <ctime>
        ///
        /// namespace rr = rerun;
        ///
        /// int main() {
        ///     auto rec = rr::RecordingStream("rerun_example_line_strip3d");
        ///     rec.connect("127.0.0.1:9876").throw_on_failure();
        ///
        ///     rec.log("world/image", rerun::Pinhole::focal_length_and_resolution({3.0f, 3.0f},
        ///     {3.0f, 3.0f}));
        ///
        ///     // TODO(andreas): Improve ergonomics.
        ///     rerun::datatypes::TensorData tensor;
        ///     rerun::datatypes::TensorDimension dim3;
        ///     dim3.size = 3;
        ///     tensor.shape = {dim3, dim3, dim3};
        ///     std::srand(static_cast<uint32_t>(std::time(nullptr)));
        ///     std::vector<uint8_t> random_data(3 * 3 * 3);
        ///     std::generate(random_data.begin(), random_data.end(), std::rand);
        ///     tensor.buffer = rerun::datatypes::TensorBuffer::u8(random_data);
        ///
        ///     rec.log("world/image", rerun::Image(tensor));
        /// }
        /// ```
        struct Pinhole {
            /// Camera projection, from image coordinates to view coordinates.
            rerun::components::PinholeProjection image_from_camera;

            /// Pixel resolution (usually integers) of child image space. Width and height.
            ///
            /// Example:
            /// ```text
            /// [1920.0, 1440.0]
            /// ```
            ///
            /// `image_from_camera` project onto the space spanned by `(0,0)` and `resolution - 1`.
            std::optional<rerun::components::Resolution> resolution;

            /// Name of the indicator component, used to identify the archetype when converting to a
            /// list of components.
            static const char INDICATOR_COMPONENT_NAME[];

          public:
            // Extensions to generated type defined in 'pinhole_ext.cpp'

            /// Creates a pinhole from the camera focal length and resolution, both specified in
            /// pixels.
            ///
            /// The focal length is the diagonal of the projection matrix.
            /// Set the same value for x & y value for symmetric cameras, or two values for
            /// anamorphic cameras.
            ///
            /// Assumes the principal point to be in the middle of the sensor.
            static Pinhole focal_length_and_resolution(
                const datatypes::Vec2D& focal_length, const datatypes::Vec2D& resolution
            );

          public:
            Pinhole() = default;

            Pinhole(rerun::components::PinholeProjection _image_from_camera)
                : image_from_camera(std::move(_image_from_camera)) {}

            /// Pixel resolution (usually integers) of child image space. Width and height.
            ///
            /// Example:
            /// ```text
            /// [1920.0, 1440.0]
            /// ```
            ///
            /// `image_from_camera` project onto the space spanned by `(0,0)` and `resolution - 1`.
            Pinhole& with_resolution(rerun::components::Resolution _resolution) {
                resolution = std::move(_resolution);
                return *this;
            }

            /// Returns the number of primary instances of this archetype.
            size_t num_instances() const {
                return 1;
            }

            /// Collections all component lists into a list of component collections. *Attention:*
            /// The returned vector references this instance and does not take ownership of any
            /// data. Adding any new components to this archetype will invalidate the returned
            /// component lists!
            std::vector<AnonymousComponentBatch> as_component_batches() const;
        };
    } // namespace archetypes
} // namespace rerun
