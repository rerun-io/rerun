// DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/cpp/mod.rs
// Based on "crates/store/re_sdk_types/definitions/rerun/archetypes/instance_poses3d.fbs".

#pragma once

#include "../collection.hpp"
#include "../component_batch.hpp"
#include "../component_column.hpp"
#include "../components/rotation_axis_angle.hpp"
#include "../components/rotation_quat.hpp"
#include "../components/scale3d.hpp"
#include "../components/transform_mat3x3.hpp"
#include "../components/translation3d.hpp"
#include "../result.hpp"

#include <cstdint>
#include <optional>
#include <utility>
#include <vector>

namespace rerun::archetypes {
    /// **Archetype**: One or more transforms applied on the current entity's transform frame.
    ///
    /// Unlike `archetypes::Transform3D`, it is *not* propagated in the transform hierarchy.
    /// If `archetypes::CoordinateFrame` is specified, it acts relative to that coordinate frame,
    /// otherwise it is relative to the entity's implicit coordinate frame.
    ///
    /// Whenever you log this archetype, the state of the resulting overall pose is fully reset to the new archetype.
    /// This means that if you first log a pose with only a translation, and then log one with only a rotation,
    /// it will be resolved to a pose with only a rotation.
    /// (This is unlike how we usually apply latest-at semantics on an archetype where we take the latest state of any component independently)
    ///
    /// From the point of view of the entity's coordinate system,
    /// all components are applied in the inverse order they are listed here.
    /// E.g. if both a translation and a mat3x3 transform are present,
    /// the 3x3 matrix is applied first, followed by the translation.
    ///
    /// Currently, many visualizers support only a single instance transform per entity.
    /// Check archetype documentations for details - if not otherwise specified, only the first instance transform is applied.
    /// Some visualizers like the mesh visualizer used for `archetypes::Mesh3D`,
    /// will draw an object for every pose, a behavior also known as "instancing".
    ///
    /// ## Example
    ///
    /// ### Regular & instance transforms in tandem
    /// ![image](https://static.rerun.io/leaf_transform3d/41674f0082d6de489f8a1cd1583f60f6b5820ddf/full.png)
    ///
    /// ```cpp
    /// #include <rerun.hpp>
    /// #include <rerun/demo_utils.hpp>
    ///
    /// int main() {
    ///     const auto rec = rerun::RecordingStream("rerun_example_instance_pose3d_combined");
    ///     rec.set_time_sequence("frame", 0);
    ///
    ///     // Log a box and points further down in the hierarchy.
    ///     rec.log("world/box", rerun::Boxes3D::from_half_sizes({{1.0, 1.0, 1.0}}));
    ///     rec.log(
    ///         "world/box/points",
    ///         rerun::Points3D(rerun::demo::grid3d<rerun::Position3D, float>(-10.0f, 10.0f, 10))
    ///     );
    ///
    ///     for (int i = 0; i <180; ++i) {
    ///         rec.set_time_sequence("frame", i);
    ///
    ///         // Log a regular transform which affects both the box and the points.
    ///         rec.log(
    ///             "world/box",
    ///             rerun::Transform3D::from_rotation(rerun::RotationAxisAngle{
    ///                 {0.0f, 0.0f, 1.0f},
    ///                 rerun::Angle::degrees(static_cast<float>(i) * 2.0f)})
    ///         );
    ///
    ///         // Log an instance pose which affects only the box.
    ///         rec.log(
    ///             "world/box",
    ///             rerun::InstancePoses3D().with_translations(
    ///                 {{0.0f, 0.0f, std::abs(static_cast<float>(i) * 0.1f - 5.0f) - 5.0f}}
    ///             )
    ///         );
    ///     }
    /// }
    /// ```
    struct InstancePoses3D {
        /// Translation vectors.
        std::optional<ComponentBatch> translations;

        /// Rotations via axis + angle.
        std::optional<ComponentBatch> rotation_axis_angles;

        /// Rotations via quaternion.
        std::optional<ComponentBatch> quaternions;

        /// Scaling factors.
        std::optional<ComponentBatch> scales;

        /// 3x3 transformation matrices.
        std::optional<ComponentBatch> mat3x3;

      public:
        /// The name of the archetype as used in `ComponentDescriptor`s.
        static constexpr const char ArchetypeName[] = "rerun.archetypes.InstancePoses3D";

        /// `ComponentDescriptor` for the `translations` field.
        static constexpr auto Descriptor_translations = ComponentDescriptor(
            ArchetypeName, "InstancePoses3D:translations",
            Loggable<rerun::components::Translation3D>::ComponentType
        );
        /// `ComponentDescriptor` for the `rotation_axis_angles` field.
        static constexpr auto Descriptor_rotation_axis_angles = ComponentDescriptor(
            ArchetypeName, "InstancePoses3D:rotation_axis_angles",
            Loggable<rerun::components::RotationAxisAngle>::ComponentType
        );
        /// `ComponentDescriptor` for the `quaternions` field.
        static constexpr auto Descriptor_quaternions = ComponentDescriptor(
            ArchetypeName, "InstancePoses3D:quaternions",
            Loggable<rerun::components::RotationQuat>::ComponentType
        );
        /// `ComponentDescriptor` for the `scales` field.
        static constexpr auto Descriptor_scales = ComponentDescriptor(
            ArchetypeName, "InstancePoses3D:scales",
            Loggable<rerun::components::Scale3D>::ComponentType
        );
        /// `ComponentDescriptor` for the `mat3x3` field.
        static constexpr auto Descriptor_mat3x3 = ComponentDescriptor(
            ArchetypeName, "InstancePoses3D:mat3x3",
            Loggable<rerun::components::TransformMat3x3>::ComponentType
        );

      public:
        InstancePoses3D() = default;
        InstancePoses3D(InstancePoses3D&& other) = default;
        InstancePoses3D(const InstancePoses3D& other) = default;
        InstancePoses3D& operator=(const InstancePoses3D& other) = default;
        InstancePoses3D& operator=(InstancePoses3D&& other) = default;

        /// Update only some specific fields of a `InstancePoses3D`.
        static InstancePoses3D update_fields() {
            return InstancePoses3D();
        }

        /// Clear all the fields of a `InstancePoses3D`.
        static InstancePoses3D clear_fields();

        /// Translation vectors.
        InstancePoses3D with_translations(
            const Collection<rerun::components::Translation3D>& _translations
        ) && {
            translations = ComponentBatch::from_loggable(_translations, Descriptor_translations)
                               .value_or_throw();
            return std::move(*this);
        }

        /// Rotations via axis + angle.
        InstancePoses3D with_rotation_axis_angles(
            const Collection<rerun::components::RotationAxisAngle>& _rotation_axis_angles
        ) && {
            rotation_axis_angles = ComponentBatch::from_loggable(
                                       _rotation_axis_angles,
                                       Descriptor_rotation_axis_angles
            )
                                       .value_or_throw();
            return std::move(*this);
        }

        /// Rotations via quaternion.
        InstancePoses3D with_quaternions(
            const Collection<rerun::components::RotationQuat>& _quaternions
        ) && {
            quaternions = ComponentBatch::from_loggable(_quaternions, Descriptor_quaternions)
                              .value_or_throw();
            return std::move(*this);
        }

        /// Scaling factors.
        InstancePoses3D with_scales(const Collection<rerun::components::Scale3D>& _scales) && {
            scales = ComponentBatch::from_loggable(_scales, Descriptor_scales).value_or_throw();
            return std::move(*this);
        }

        /// 3x3 transformation matrices.
        InstancePoses3D with_mat3x3(const Collection<rerun::components::TransformMat3x3>& _mat3x3
        ) && {
            mat3x3 = ComponentBatch::from_loggable(_mat3x3, Descriptor_mat3x3).value_or_throw();
            return std::move(*this);
        }

        /// Partitions the component data into multiple sub-batches.
        ///
        /// Specifically, this transforms the existing `ComponentBatch` data into `ComponentColumn`s
        /// instead, via `ComponentBatch::partitioned`.
        ///
        /// This makes it possible to use `RecordingStream::send_columns` to send columnar data directly into Rerun.
        ///
        /// The specified `lengths` must sum to the total length of the component batch.
        Collection<ComponentColumn> columns(const Collection<uint32_t>& lengths_);

        /// Partitions the component data into unit-length sub-batches.
        ///
        /// This is semantically similar to calling `columns` with `std::vector<uint32_t>(n, 1)`,
        /// where `n` is automatically guessed.
        Collection<ComponentColumn> columns();
    };

} // namespace rerun::archetypes

namespace rerun {
    /// \private
    template <typename T>
    struct AsComponents;

    /// \private
    template <>
    struct AsComponents<archetypes::InstancePoses3D> {
        /// Serialize all set component batches.
        static Result<Collection<ComponentBatch>> as_batches(
            const archetypes::InstancePoses3D& archetype
        );
    };
} // namespace rerun
