#!/usr/bin/env python3
"""
Runs custom linting on our code.

Adding "NOLINT" to any line makes the linter ignore that line.
"""

import argparse
import glob
import os
import re
import sys

todo_pattern = re.compile(r'TODO([^(]|$)')


def lint_line(line):
    if 'NOLINT' in line:
        return None  # NOLINT ignores the linter

    if 'FIXME' in line:
        return 'we prefer TODO over FIXME'

    if 'HACK' in line:
        return 'we prefer TODO over HACK'

    if 'todo!()' in line:
        return 'todo!() should be written as todo!("$details")'

    if 'unimplemented!' in line:
        return 'unimplemented!(): either implement this, or rewrite it as a todo!()'

    if todo_pattern.search(line):
        return 'TODO:s should be written as `TODO(yourname): what to do`'

    if 'rerurn' in line.lower():
        return "Emil: you put an extra 'r' in 'Rerun' again!"

    return None


def test_lint():
    assert lint_line("hello world") == None

    should_pass = [
        'hello world',
        'todo lowercase is fine',
        'todo!("macro is ok with text")',
        'TODO(emilk):',
    ]

    should_error = [
        'FIXME',
        'HACK',
        'TODO',
        'TODO:',
        'todo!()'
        'unimplemented!()',
        'unimplemented!("even with text!")',
    ]

    for line in should_pass:
        assert lint_line(line) == None, f'exepcted "{line}" to pass'

    for line in should_error:
        assert lint_line(line) != None, f'exepcted "{line}" to fail'


def lint_file(filepath, args):
    with open(filepath) as f:
        lines_in = f.readlines()

    num_errors = 0

    for line_nr, line in enumerate(lines_in):
        error = lint_line(line)
        if error != None:
            num_errors += 1
            print(f'{filepath}:{line_nr+1}: {error}')

    return num_errors


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Lint code with custom linter.')
    parser.add_argument('files', metavar='file', type=str, nargs='*',
                        help='File paths. Empty = all files, recursively.')

    args = parser.parse_args()

    num_errors = 0

    if args.files:
        for filepath in args.files:
            num_errors += lint_file(filepath, args)
    else:
        script_dirpath = os.path.dirname(os.path.realpath(__file__))
        root_dirpath = os.path.abspath(f'{script_dirpath}/..')
        os.chdir(root_dirpath)

        exclude_dirs = set(['env', 'venv', 'target', 'target_wasm'])

        exclude_paths = set([
            './CONTRIBUTING.md',
            './scripts/lint.py',  # we contain all the patterns we are linting against
            './web_viewer/re_viewer.js',  # auto-generated by wasm_bindgen
        ])

        for root, dirs, files in os.walk('.', topdown=True):
            dirs[:] = [d for d in dirs if d not in exclude_dirs]
            for filename in files:
                extension = filename.split('.')[-1]
                if extension in ['html', 'js', 'py', 'rs', 'sh', 'toml']:
                    filepath = os.path.join(root, filename)
                    if not filepath in exclude_paths:
                        num_errors += lint_file(filepath, args)

    if num_errors == 0:
        print('lint.py finished without error')
        sys.exit(0)
    else:
        print(f'{num_errors} errors.')
        sys.exit(1)
