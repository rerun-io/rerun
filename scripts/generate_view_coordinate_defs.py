#!/usr/bin/env python3
"""
Generates the permutations of view coordinate name definitions.

This will modify the different archetype extensions to include the appropriate constants.
"""
from __future__ import annotations

import argparse
import itertools
import os
from dataclasses import dataclass
from typing import Iterable

BEGIN_MARKER = "<BEGIN_GENERATED:{}>"
END_MARKER = "<END_GENERATED:{}>"

RUST_EXTENSION_FILE = "crates/re_types/src/archetypes/view_coordinates_ext.rs"
PYTHON_EXTENSION_FILE = "rerun_py/rerun_sdk/rerun/archetypes/view_coordinates_ext.py"
CPP_EXTENSION_FILE = "rerun_cpp/src/rerun/archetypes/view_coordinates_ext.cpp"

SCRIPT_PATH = os.path.relpath(__file__, os.getcwd())

################################################################################


@dataclass
class ViewCoordinates:
    name: str
    x: str
    y: str
    z: str


def generate_view_permutations() -> Iterable[ViewCoordinates]:
    D1 = ["Up", "Down"]
    D2 = ["Left", "Right"]
    D3 = ["Forward", "Back"]
    for i in D1:
        for j in D2:
            for k in D3:
                for x, y, z in itertools.permutations([i, j, k]):
                    name = f"{x[0]}{y[0]}{z[0]}"
                    yield ViewCoordinates(name, x, y, z)


def generate_up_handed_permutations() -> Iterable[ViewCoordinates]:
    return [
        ViewCoordinates(name="RIGHT_HAND_X_UP", x="Up", y="Right", z="Forward"),
        ViewCoordinates(name="RIGHT_HAND_X_DOWN", x="Down", y="Right", z="Back"),
        ViewCoordinates(name="RIGHT_HAND_Y_UP", x="Right", y="Up", z="Back"),
        ViewCoordinates(name="RIGHT_HAND_Y_DOWN", x="Right", y="Down", z="Forward"),
        ViewCoordinates(name="RIGHT_HAND_Z_UP", x="Right", y="Forward", z="Up"),
        ViewCoordinates(name="RIGHT_HAND_Z_DOWN", x="Right", y="Back", z="Down"),
        ViewCoordinates(name="LEFT_HAND_X_UP", x="Up", y="Right", z="Back"),
        ViewCoordinates(name="LEFT_HAND_X_DOWN", x="Down", y="Right", z="Forward"),
        ViewCoordinates(name="LEFT_HAND_Y_UP", x="Right", y="Up", z="Forward"),
        ViewCoordinates(name="LEFT_HAND_Y_DOWN", x="Right", y="Down", z="Back"),
        ViewCoordinates(name="LEFT_HAND_Z_UP", x="Right", y="Back", z="Up"),
        ViewCoordinates(name="LEFT_HAND_Z_DOWN", x="Right", y="Forward", z="Down"),
    ]


################################################################################


def rust_definition(coords: ViewCoordinates) -> str:
    return f"define_coordinates!({coords.name} => ({coords.x}, {coords.y}, {coords.z}));\n"


def gen_rust_definitions() -> list[str]:
    key = "definitions"
    lines = []
    lines.append(f"// {BEGIN_MARKER.format(key)}\n")
    lines.append(f"// This section is generated by running `{SCRIPT_PATH} --rust`\n")
    lines.extend(rust_definition(v) for v in generate_view_permutations())
    lines.extend(rust_definition(v) for v in generate_up_handed_permutations())
    lines.append(f"// {END_MARKER.format(key)}\n")
    return lines


################################################################################


def py_definition(coords: ViewCoordinates) -> str:
    return f"{coords.name} = Component([Component.ViewDir.{coords.x}, Component.ViewDir.{coords.y}, Component.ViewDir.{coords.z}])\n"


def gen_py_definitions() -> list[str]:
    key = "definitions"
    lines = []
    lines.append(f"# {BEGIN_MARKER.format(key)}\n")
    lines.append(f"# This section is generated by running `{SCRIPT_PATH} --python`\n")
    lines.extend(py_definition(v) for v in generate_view_permutations())
    lines.extend(py_definition(v) for v in generate_up_handed_permutations())
    lines.append(f"# {END_MARKER.format(key)}\n")
    lines = [" " * 4 + line for line in lines]
    return lines


################################################################################


def cpp_declaration(coords: ViewCoordinates) -> str:
    return f"static const rerun::archetypes::ViewCoordinates {coords.name};\n"


def gen_cpp_declarations() -> list[str]:
    key = "declarations"
    lines = []
    lines.append(f"// {BEGIN_MARKER.format(key)}\n")
    lines.append(f"// This section is generated by running `{SCRIPT_PATH} --cpp`\n")
    lines.extend(cpp_declaration(v) for v in generate_view_permutations())
    lines.extend(cpp_declaration(v) for v in generate_up_handed_permutations())
    lines.append(f"// {END_MARKER.format(key)}\n")
    lines = [" " * 4 + line for line in lines]
    return lines


def cpp_definition(coords: ViewCoordinates) -> str:
    return (
        f"const ViewCoordinates ViewCoordinates::{coords.name} = ViewCoordinates(\n"
        + f"rerun::components::ViewCoordinates::{coords.x}, rerun::components::ViewCoordinates::{coords.y}, rerun::components::ViewCoordinates::{coords.z}\n"
        + ");\n"
    )


def gen_cpp_definitions() -> list[str]:
    key = "definitions"
    lines = []
    lines.append(f"// {BEGIN_MARKER.format(key)}\n")
    lines.append(f"// This section is generated by running `{SCRIPT_PATH} --cpp`\n")
    lines.extend(cpp_definition(v) for v in generate_view_permutations())
    lines.extend(cpp_definition(v) for v in generate_up_handed_permutations())
    lines.append(f"// {END_MARKER.format(key)}\n")
    lines = [" " * 4 + line for line in lines]
    return lines


################################################################################


def show_preview(lines: list[str]) -> None:
    print("".join(lines))


def patch_file(filename: str, lines: list[str], key: str) -> None:
    contents = open(filename).readlines()
    start_line = next((i for i, line in enumerate(contents) if BEGIN_MARKER.format(key) in line), None)
    end_line = next((i for i, line in enumerate(contents) if END_MARKER.format(key) in line), None)
    if (start_line is None) or (end_line is None):
        raise Exception("Could not find the generated section in the file.")
    new_contents = contents[:start_line] + lines + contents[end_line + 1 :]
    open(filename, "w").writelines(new_contents)


################################################################################


def main() -> None:
    parser = argparse.ArgumentParser(description="Modify the ViewCoordinate archetypes.")
    parser.add_argument(
        "--rust",
        action="store_true",
        default=False,
        help="Generate the rust code for the view coordinates.",
    )
    parser.add_argument(
        "--python",
        action="store_true",
        default=False,
        help="Generate the python code for the view coordinates.",
    )
    parser.add_argument(
        "--cpp",
        action="store_true",
        default=False,
        help="Generate the cpp code for the view coordinates.",
    )
    parser.add_argument(
        "--preview", action="store_true", default=False, help="Just print the preview of the generated sections"
    )
    args = parser.parse_args()

    if args.rust:
        if args.preview:
            show_preview(gen_rust_definitions())
            print("".join(gen_rust_definitions()))
        else:
            patch_file(RUST_EXTENSION_FILE, gen_rust_definitions(), "definitions")

    if args.python:
        if args.preview:
            show_preview(gen_py_definitions())
        else:
            patch_file(PYTHON_EXTENSION_FILE, gen_py_definitions(), "definitions")

    if args.cpp:
        if args.preview:
            print("Declarations:")
            show_preview(gen_cpp_declarations())
            print("\nDefinitions:")
            show_preview(gen_cpp_definitions())
        else:
            patch_file(CPP_EXTENSION_FILE, gen_cpp_declarations(), "declarations")
            patch_file(CPP_EXTENSION_FILE, gen_cpp_definitions(), "definitions")


if __name__ == "__main__":
    main()
