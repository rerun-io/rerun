# Rerun architecture
This document describes the technical architecture of Rerun.

## See also
* [`BUILD.md`](BUILD.md)
* [`CODE_STYLE.md`](CODE_STYLE.md)
* [`CONTRIBUTING.md`](CONTRIBUTING.md)
* [`RELEASES.md`](RELEASES.md)

## The major components
### Logging SDKs
It all starts with logging. You can log rich data (point clouds, images, etc) with either our Python SDK or our Rust SDK.

The logging SDK:s encodes the data using Apache Arrow (see more below).

The logging data can be written to disk as `.rrd` files, or transmitted over TCP to either a Rerun Viewer or a Rerun Server.

### Rerun viewer
The Rerun Viewer is where log data is visualized. It is usually run as a native app, but can also be compiled to WebAssembly (WASM) and run in a browser.

#### Web viewer
You can try running the viewer in a browser using `rr.serve()` in python, or using `rerun --web-viewer mydata.rrd`.

The web viewer consists of just a few small files - a thin `.html`, a `.wasm` blob, and an auto-generated `.js` bridge for the wasm. These files are served using the [`re_web_server`](https://github.com/rerun-io/rerun/tree/main/crates/re_web_server) crate.

The web viewer can load `.rrd` files (just drag-drop them into the browser), or read logging data streamed over WebSockets.

### `.rrd` files
`.rrd` ("**R**e**r**un **D**ata") is just a bunch of log messages appended one after the other to a file.

NOTE: `.rrd` files do not yet guarantee any backwards or forwards compatibility. One version of Rerun will likely not be able to open an `.rrd` file generated by another Rerun version.

## The major technologies we use
### Apache Arrow

### maturing / pyo3

### wgpu

### egui
